
TWI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c4e  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stab         000012c0  00000000  00000000  00000ca4  2**2
                  CONTENTS, READONLY, DEBUGGING
  2 .stabstr      00000ac8  00000000  00000000  00001f64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 1c 06 	call	0xc38	; 0xc38 <main>
  78:	0c 94 25 06 	jmp	0xc4a	; 0xc4a <_exit>

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <DIO_voidInit>:
/* MCAL layer */
#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"
void DIO_voidInit(void)
{
  80:	df 93       	push	r29
  82:	cf 93       	push	r28
  84:	cd b7       	in	r28, 0x3d	; 61
  86:	de b7       	in	r29, 0x3e	; 62
    DIO_DDRB_REG = CONC(DIO_u8_PB7_DIRECTION,DIO_u8_PB6_DIRECTION,DIO_u8_PB5_DIRECTION,DIO_u8_PB4_DIRECTION
  88:	e4 e2       	ldi	r30, 0x24	; 36
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	10 82       	st	Z, r1
    				   ,DIO_u8_PB3_DIRECTION,DIO_u8_PB2_DIRECTION,DIO_u8_PB1_DIRECTION,DIO_u8_PB0_DIRECTION);
    DIO_DDRC_REG = CONC(DIO_u8_PC7_DIRECTION,DIO_u8_PC6_DIRECTION,DIO_u8_PC5_DIRECTION,DIO_u8_PC4_DIRECTION
  8e:	e7 e2       	ldi	r30, 0x27	; 39
  90:	f0 e0       	ldi	r31, 0x00	; 0
  92:	10 82       	st	Z, r1
                       ,DIO_u8_PC3_DIRECTION,DIO_u8_PC2_DIRECTION,DIO_u8_PC1_DIRECTION,DIO_u8_PC0_DIRECTION);
    DIO_DDRD_REG = CONC(DIO_u8_PD7_DIRECTION,DIO_u8_PD6_DIRECTION,DIO_u8_PD5_DIRECTION,DIO_u8_PD4_DIRECTION
  94:	ea e2       	ldi	r30, 0x2A	; 42
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	10 82       	st	Z, r1
                       ,DIO_u8_PD3_DIRECTION,DIO_u8_PD2_DIRECTION,DIO_u8_PD1_DIRECTION,DIO_u8_PD0_DIRECTION);
    /*INITIAL VALUES FOR PINS*/                
     DIO_PORTB_REG = CONC(DIO_u8_PB7_VALUE,DIO_u8_PB6_VALUE,DIO_u8_PB5_VALUE,DIO_u8_PB4_VALUE
  9a:	e5 e2       	ldi	r30, 0x25	; 37
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	10 82       	st	Z, r1
                         ,DIO_u8_PB3_VALUE,DIO_u8_PB2_VALUE,DIO_u8_PB1_VALUE,DIO_u8_PB0_VALUE);
     DIO_PORTC_REG = CONC(DIO_u8_PC7_VALUE,DIO_u8_PC6_VALUE,DIO_u8_PC5_VALUE,DIO_u8_PC4_VALUE
  a0:	e8 e2       	ldi	r30, 0x28	; 40
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	10 82       	st	Z, r1
                         ,DIO_u8_PC3_VALUE,DIO_u8_PC2_VALUE,DIO_u8_PC1_VALUE,DIO_u8_PC0_VALUE);
     DIO_PORTD_REG = CONC(DIO_u8_PD7_VALUE,DIO_u8_PD6_VALUE,DIO_u8_PD5_VALUE,DIO_u8_PD4_VALUE
  a6:	eb e2       	ldi	r30, 0x2B	; 43
  a8:	f0 e0       	ldi	r31, 0x00	; 0
  aa:	10 82       	st	Z, r1
                         ,DIO_u8_PD3_VALUE,DIO_u8_PD2_VALUE,DIO_u8_PD1_VALUE,DIO_u8_PD0_VALUE);
}
  ac:	cf 91       	pop	r28
  ae:	df 91       	pop	r29
  b0:	08 95       	ret

000000b2 <DIO_u8SetPinDirection>:
                        
u8 DIO_u8SetPinDirection  (u8 Copy_u8PortId, u8 Copy_u8PinId,u8 Copy_u8PinDirection)
{
  b2:	df 93       	push	r29
  b4:	cf 93       	push	r28
  b6:	cd b7       	in	r28, 0x3d	; 61
  b8:	de b7       	in	r29, 0x3e	; 62
  ba:	2c 97       	sbiw	r28, 0x0c	; 12
  bc:	0f b6       	in	r0, 0x3f	; 63
  be:	f8 94       	cli
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	cd bf       	out	0x3d, r28	; 61
  c6:	8a 83       	std	Y+2, r24	; 0x02
  c8:	6b 83       	std	Y+3, r22	; 0x03
  ca:	4c 83       	std	Y+4, r20	; 0x04
    u8 Local_u8ReturnState = STD_TYPE_OK ;
  cc:	81 e0       	ldi	r24, 0x01	; 1
  ce:	89 83       	std	Y+1, r24	; 0x01
    if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <= DIO_u8_PIN7) && ((Copy_u8PinDirection == DIO_u8_INPUT)||(Copy_u8PinDirection == DIO_u8_OUTPUT)) )
  d0:	8a 81       	ldd	r24, Y+2	; 0x02
  d2:	83 30       	cpi	r24, 0x03	; 3
  d4:	08 f0       	brcs	.+2      	; 0xd8 <DIO_u8SetPinDirection+0x26>
  d6:	c8 c0       	rjmp	.+400    	; 0x268 <DIO_u8SetPinDirection+0x1b6>
  d8:	8b 81       	ldd	r24, Y+3	; 0x03
  da:	88 30       	cpi	r24, 0x08	; 8
  dc:	08 f0       	brcs	.+2      	; 0xe0 <DIO_u8SetPinDirection+0x2e>
  de:	c4 c0       	rjmp	.+392    	; 0x268 <DIO_u8SetPinDirection+0x1b6>
  e0:	8c 81       	ldd	r24, Y+4	; 0x04
  e2:	88 23       	and	r24, r24
  e4:	21 f0       	breq	.+8      	; 0xee <DIO_u8SetPinDirection+0x3c>
  e6:	8c 81       	ldd	r24, Y+4	; 0x04
  e8:	81 30       	cpi	r24, 0x01	; 1
  ea:	09 f0       	breq	.+2      	; 0xee <DIO_u8SetPinDirection+0x3c>
  ec:	bd c0       	rjmp	.+378    	; 0x268 <DIO_u8SetPinDirection+0x1b6>
    {
        switch (Copy_u8PortId)
  ee:	8a 81       	ldd	r24, Y+2	; 0x02
  f0:	28 2f       	mov	r18, r24
  f2:	30 e0       	ldi	r19, 0x00	; 0
  f4:	3c 87       	std	Y+12, r19	; 0x0c
  f6:	2b 87       	std	Y+11, r18	; 0x0b
  f8:	8b 85       	ldd	r24, Y+11	; 0x0b
  fa:	9c 85       	ldd	r25, Y+12	; 0x0c
  fc:	81 30       	cpi	r24, 0x01	; 1
  fe:	91 05       	cpc	r25, r1
 100:	09 f4       	brne	.+2      	; 0x104 <DIO_u8SetPinDirection+0x52>
 102:	43 c0       	rjmp	.+134    	; 0x18a <DIO_u8SetPinDirection+0xd8>
 104:	2b 85       	ldd	r18, Y+11	; 0x0b
 106:	3c 85       	ldd	r19, Y+12	; 0x0c
 108:	22 30       	cpi	r18, 0x02	; 2
 10a:	31 05       	cpc	r19, r1
 10c:	09 f4       	brne	.+2      	; 0x110 <DIO_u8SetPinDirection+0x5e>
 10e:	75 c0       	rjmp	.+234    	; 0x1fa <DIO_u8SetPinDirection+0x148>
 110:	8b 85       	ldd	r24, Y+11	; 0x0b
 112:	9c 85       	ldd	r25, Y+12	; 0x0c
 114:	00 97       	sbiw	r24, 0x00	; 0
 116:	09 f0       	breq	.+2      	; 0x11a <DIO_u8SetPinDirection+0x68>
 118:	a8 c0       	rjmp	.+336    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
        {
        case DIO_u8_PORTB : 
            switch (Copy_u8PinDirection)
 11a:	8c 81       	ldd	r24, Y+4	; 0x04
 11c:	28 2f       	mov	r18, r24
 11e:	30 e0       	ldi	r19, 0x00	; 0
 120:	3a 87       	std	Y+10, r19	; 0x0a
 122:	29 87       	std	Y+9, r18	; 0x09
 124:	89 85       	ldd	r24, Y+9	; 0x09
 126:	9a 85       	ldd	r25, Y+10	; 0x0a
 128:	00 97       	sbiw	r24, 0x00	; 0
 12a:	d1 f0       	breq	.+52     	; 0x160 <DIO_u8SetPinDirection+0xae>
 12c:	29 85       	ldd	r18, Y+9	; 0x09
 12e:	3a 85       	ldd	r19, Y+10	; 0x0a
 130:	21 30       	cpi	r18, 0x01	; 1
 132:	31 05       	cpc	r19, r1
 134:	09 f0       	breq	.+2      	; 0x138 <DIO_u8SetPinDirection+0x86>
 136:	99 c0       	rjmp	.+306    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            {
                case DIO_u8_OUTPUT : SET_BIT(DIO_DDRB_REG,Copy_u8PinId)  ; break;
 138:	a4 e2       	ldi	r26, 0x24	; 36
 13a:	b0 e0       	ldi	r27, 0x00	; 0
 13c:	e4 e2       	ldi	r30, 0x24	; 36
 13e:	f0 e0       	ldi	r31, 0x00	; 0
 140:	80 81       	ld	r24, Z
 142:	48 2f       	mov	r20, r24
 144:	8b 81       	ldd	r24, Y+3	; 0x03
 146:	28 2f       	mov	r18, r24
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	02 2e       	mov	r0, r18
 150:	02 c0       	rjmp	.+4      	; 0x156 <DIO_u8SetPinDirection+0xa4>
 152:	88 0f       	add	r24, r24
 154:	99 1f       	adc	r25, r25
 156:	0a 94       	dec	r0
 158:	e2 f7       	brpl	.-8      	; 0x152 <DIO_u8SetPinDirection+0xa0>
 15a:	84 2b       	or	r24, r20
 15c:	8c 93       	st	X, r24
 15e:	85 c0       	rjmp	.+266    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
                case DIO_u8_INPUT  : CLR_BIT(DIO_DDRB_REG,Copy_u8PinId)  ; break;
 160:	a4 e2       	ldi	r26, 0x24	; 36
 162:	b0 e0       	ldi	r27, 0x00	; 0
 164:	e4 e2       	ldi	r30, 0x24	; 36
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	80 81       	ld	r24, Z
 16a:	48 2f       	mov	r20, r24
 16c:	8b 81       	ldd	r24, Y+3	; 0x03
 16e:	28 2f       	mov	r18, r24
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	02 2e       	mov	r0, r18
 178:	02 c0       	rjmp	.+4      	; 0x17e <DIO_u8SetPinDirection+0xcc>
 17a:	88 0f       	add	r24, r24
 17c:	99 1f       	adc	r25, r25
 17e:	0a 94       	dec	r0
 180:	e2 f7       	brpl	.-8      	; 0x17a <DIO_u8SetPinDirection+0xc8>
 182:	80 95       	com	r24
 184:	84 23       	and	r24, r20
 186:	8c 93       	st	X, r24
 188:	70 c0       	rjmp	.+224    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            }    
            break;
        case DIO_u8_PORTC : 
            switch (Copy_u8PinDirection)
 18a:	8c 81       	ldd	r24, Y+4	; 0x04
 18c:	28 2f       	mov	r18, r24
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	38 87       	std	Y+8, r19	; 0x08
 192:	2f 83       	std	Y+7, r18	; 0x07
 194:	8f 81       	ldd	r24, Y+7	; 0x07
 196:	98 85       	ldd	r25, Y+8	; 0x08
 198:	00 97       	sbiw	r24, 0x00	; 0
 19a:	d1 f0       	breq	.+52     	; 0x1d0 <DIO_u8SetPinDirection+0x11e>
 19c:	2f 81       	ldd	r18, Y+7	; 0x07
 19e:	38 85       	ldd	r19, Y+8	; 0x08
 1a0:	21 30       	cpi	r18, 0x01	; 1
 1a2:	31 05       	cpc	r19, r1
 1a4:	09 f0       	breq	.+2      	; 0x1a8 <DIO_u8SetPinDirection+0xf6>
 1a6:	61 c0       	rjmp	.+194    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            {
                case DIO_u8_OUTPUT : SET_BIT(DIO_DDRC_REG,Copy_u8PinId)  ; break;
 1a8:	a7 e2       	ldi	r26, 0x27	; 39
 1aa:	b0 e0       	ldi	r27, 0x00	; 0
 1ac:	e7 e2       	ldi	r30, 0x27	; 39
 1ae:	f0 e0       	ldi	r31, 0x00	; 0
 1b0:	80 81       	ld	r24, Z
 1b2:	48 2f       	mov	r20, r24
 1b4:	8b 81       	ldd	r24, Y+3	; 0x03
 1b6:	28 2f       	mov	r18, r24
 1b8:	30 e0       	ldi	r19, 0x00	; 0
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	02 2e       	mov	r0, r18
 1c0:	02 c0       	rjmp	.+4      	; 0x1c6 <DIO_u8SetPinDirection+0x114>
 1c2:	88 0f       	add	r24, r24
 1c4:	99 1f       	adc	r25, r25
 1c6:	0a 94       	dec	r0
 1c8:	e2 f7       	brpl	.-8      	; 0x1c2 <DIO_u8SetPinDirection+0x110>
 1ca:	84 2b       	or	r24, r20
 1cc:	8c 93       	st	X, r24
 1ce:	4d c0       	rjmp	.+154    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
                case DIO_u8_INPUT  : CLR_BIT(DIO_DDRC_REG,Copy_u8PinId)  ; break;  
 1d0:	a7 e2       	ldi	r26, 0x27	; 39
 1d2:	b0 e0       	ldi	r27, 0x00	; 0
 1d4:	e7 e2       	ldi	r30, 0x27	; 39
 1d6:	f0 e0       	ldi	r31, 0x00	; 0
 1d8:	80 81       	ld	r24, Z
 1da:	48 2f       	mov	r20, r24
 1dc:	8b 81       	ldd	r24, Y+3	; 0x03
 1de:	28 2f       	mov	r18, r24
 1e0:	30 e0       	ldi	r19, 0x00	; 0
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	02 2e       	mov	r0, r18
 1e8:	02 c0       	rjmp	.+4      	; 0x1ee <DIO_u8SetPinDirection+0x13c>
 1ea:	88 0f       	add	r24, r24
 1ec:	99 1f       	adc	r25, r25
 1ee:	0a 94       	dec	r0
 1f0:	e2 f7       	brpl	.-8      	; 0x1ea <DIO_u8SetPinDirection+0x138>
 1f2:	80 95       	com	r24
 1f4:	84 23       	and	r24, r20
 1f6:	8c 93       	st	X, r24
 1f8:	38 c0       	rjmp	.+112    	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            } 
            break;
        case DIO_u8_PORTD : 
            switch (Copy_u8PinDirection)
 1fa:	8c 81       	ldd	r24, Y+4	; 0x04
 1fc:	28 2f       	mov	r18, r24
 1fe:	30 e0       	ldi	r19, 0x00	; 0
 200:	3e 83       	std	Y+6, r19	; 0x06
 202:	2d 83       	std	Y+5, r18	; 0x05
 204:	8d 81       	ldd	r24, Y+5	; 0x05
 206:	9e 81       	ldd	r25, Y+6	; 0x06
 208:	00 97       	sbiw	r24, 0x00	; 0
 20a:	c9 f0       	breq	.+50     	; 0x23e <DIO_u8SetPinDirection+0x18c>
 20c:	2d 81       	ldd	r18, Y+5	; 0x05
 20e:	3e 81       	ldd	r19, Y+6	; 0x06
 210:	21 30       	cpi	r18, 0x01	; 1
 212:	31 05       	cpc	r19, r1
 214:	51 f5       	brne	.+84     	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            {
                case DIO_u8_OUTPUT : SET_BIT(DIO_DDRD_REG,Copy_u8PinId)  ; break;
 216:	aa e2       	ldi	r26, 0x2A	; 42
 218:	b0 e0       	ldi	r27, 0x00	; 0
 21a:	ea e2       	ldi	r30, 0x2A	; 42
 21c:	f0 e0       	ldi	r31, 0x00	; 0
 21e:	80 81       	ld	r24, Z
 220:	48 2f       	mov	r20, r24
 222:	8b 81       	ldd	r24, Y+3	; 0x03
 224:	28 2f       	mov	r18, r24
 226:	30 e0       	ldi	r19, 0x00	; 0
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	02 2e       	mov	r0, r18
 22e:	02 c0       	rjmp	.+4      	; 0x234 <DIO_u8SetPinDirection+0x182>
 230:	88 0f       	add	r24, r24
 232:	99 1f       	adc	r25, r25
 234:	0a 94       	dec	r0
 236:	e2 f7       	brpl	.-8      	; 0x230 <DIO_u8SetPinDirection+0x17e>
 238:	84 2b       	or	r24, r20
 23a:	8c 93       	st	X, r24
 23c:	16 c0       	rjmp	.+44     	; 0x26a <DIO_u8SetPinDirection+0x1b8>
                case DIO_u8_INPUT  : CLR_BIT(DIO_DDRD_REG,Copy_u8PinId)  ; break;  
 23e:	aa e2       	ldi	r26, 0x2A	; 42
 240:	b0 e0       	ldi	r27, 0x00	; 0
 242:	ea e2       	ldi	r30, 0x2A	; 42
 244:	f0 e0       	ldi	r31, 0x00	; 0
 246:	80 81       	ld	r24, Z
 248:	48 2f       	mov	r20, r24
 24a:	8b 81       	ldd	r24, Y+3	; 0x03
 24c:	28 2f       	mov	r18, r24
 24e:	30 e0       	ldi	r19, 0x00	; 0
 250:	81 e0       	ldi	r24, 0x01	; 1
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	02 2e       	mov	r0, r18
 256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_u8SetPinDirection+0x1aa>
 258:	88 0f       	add	r24, r24
 25a:	99 1f       	adc	r25, r25
 25c:	0a 94       	dec	r0
 25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_u8SetPinDirection+0x1a6>
 260:	80 95       	com	r24
 262:	84 23       	and	r24, r20
 264:	8c 93       	st	X, r24
 266:	01 c0       	rjmp	.+2      	; 0x26a <DIO_u8SetPinDirection+0x1b8>
            } 
        }
    }
    else 
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 268:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 26a:	89 81       	ldd	r24, Y+1	; 0x01
}
 26c:	2c 96       	adiw	r28, 0x0c	; 12
 26e:	0f b6       	in	r0, 0x3f	; 63
 270:	f8 94       	cli
 272:	de bf       	out	0x3e, r29	; 62
 274:	0f be       	out	0x3f, r0	; 63
 276:	cd bf       	out	0x3d, r28	; 61
 278:	cf 91       	pop	r28
 27a:	df 91       	pop	r29
 27c:	08 95       	ret

0000027e <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue      (u8 Copy_u8PortId,u8 Copy_u8PinId,u8 Copy_u8PinValue)
{
 27e:	df 93       	push	r29
 280:	cf 93       	push	r28
 282:	cd b7       	in	r28, 0x3d	; 61
 284:	de b7       	in	r29, 0x3e	; 62
 286:	2c 97       	sbiw	r28, 0x0c	; 12
 288:	0f b6       	in	r0, 0x3f	; 63
 28a:	f8 94       	cli
 28c:	de bf       	out	0x3e, r29	; 62
 28e:	0f be       	out	0x3f, r0	; 63
 290:	cd bf       	out	0x3d, r28	; 61
 292:	8a 83       	std	Y+2, r24	; 0x02
 294:	6b 83       	std	Y+3, r22	; 0x03
 296:	4c 83       	std	Y+4, r20	; 0x04
    u8 Local_u8ReturnState = STD_TYPE_OK;
 298:	81 e0       	ldi	r24, 0x01	; 1
 29a:	89 83       	std	Y+1, r24	; 0x01
    if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <=DIO_u8_PIN7)&& ((Copy_u8PinValue == DIO_u8_HIGH)||(Copy_u8PinValue == DIO_u8_LOW)))
 29c:	8a 81       	ldd	r24, Y+2	; 0x02
 29e:	83 30       	cpi	r24, 0x03	; 3
 2a0:	08 f0       	brcs	.+2      	; 0x2a4 <DIO_u8SetPinValue+0x26>
 2a2:	c8 c0       	rjmp	.+400    	; 0x434 <DIO_u8SetPinValue+0x1b6>
 2a4:	8b 81       	ldd	r24, Y+3	; 0x03
 2a6:	88 30       	cpi	r24, 0x08	; 8
 2a8:	08 f0       	brcs	.+2      	; 0x2ac <DIO_u8SetPinValue+0x2e>
 2aa:	c4 c0       	rjmp	.+392    	; 0x434 <DIO_u8SetPinValue+0x1b6>
 2ac:	8c 81       	ldd	r24, Y+4	; 0x04
 2ae:	81 30       	cpi	r24, 0x01	; 1
 2b0:	21 f0       	breq	.+8      	; 0x2ba <DIO_u8SetPinValue+0x3c>
 2b2:	8c 81       	ldd	r24, Y+4	; 0x04
 2b4:	88 23       	and	r24, r24
 2b6:	09 f0       	breq	.+2      	; 0x2ba <DIO_u8SetPinValue+0x3c>
 2b8:	bd c0       	rjmp	.+378    	; 0x434 <DIO_u8SetPinValue+0x1b6>
    {
        switch (Copy_u8PortId)
 2ba:	8a 81       	ldd	r24, Y+2	; 0x02
 2bc:	28 2f       	mov	r18, r24
 2be:	30 e0       	ldi	r19, 0x00	; 0
 2c0:	3c 87       	std	Y+12, r19	; 0x0c
 2c2:	2b 87       	std	Y+11, r18	; 0x0b
 2c4:	8b 85       	ldd	r24, Y+11	; 0x0b
 2c6:	9c 85       	ldd	r25, Y+12	; 0x0c
 2c8:	81 30       	cpi	r24, 0x01	; 1
 2ca:	91 05       	cpc	r25, r1
 2cc:	09 f4       	brne	.+2      	; 0x2d0 <DIO_u8SetPinValue+0x52>
 2ce:	43 c0       	rjmp	.+134    	; 0x356 <DIO_u8SetPinValue+0xd8>
 2d0:	2b 85       	ldd	r18, Y+11	; 0x0b
 2d2:	3c 85       	ldd	r19, Y+12	; 0x0c
 2d4:	22 30       	cpi	r18, 0x02	; 2
 2d6:	31 05       	cpc	r19, r1
 2d8:	09 f4       	brne	.+2      	; 0x2dc <DIO_u8SetPinValue+0x5e>
 2da:	75 c0       	rjmp	.+234    	; 0x3c6 <DIO_u8SetPinValue+0x148>
 2dc:	8b 85       	ldd	r24, Y+11	; 0x0b
 2de:	9c 85       	ldd	r25, Y+12	; 0x0c
 2e0:	00 97       	sbiw	r24, 0x00	; 0
 2e2:	09 f0       	breq	.+2      	; 0x2e6 <DIO_u8SetPinValue+0x68>
 2e4:	a8 c0       	rjmp	.+336    	; 0x436 <DIO_u8SetPinValue+0x1b8>
        {
        case DIO_u8_PORTB : 
            switch (Copy_u8PinValue)
 2e6:	8c 81       	ldd	r24, Y+4	; 0x04
 2e8:	28 2f       	mov	r18, r24
 2ea:	30 e0       	ldi	r19, 0x00	; 0
 2ec:	3a 87       	std	Y+10, r19	; 0x0a
 2ee:	29 87       	std	Y+9, r18	; 0x09
 2f0:	89 85       	ldd	r24, Y+9	; 0x09
 2f2:	9a 85       	ldd	r25, Y+10	; 0x0a
 2f4:	00 97       	sbiw	r24, 0x00	; 0
 2f6:	d1 f0       	breq	.+52     	; 0x32c <DIO_u8SetPinValue+0xae>
 2f8:	29 85       	ldd	r18, Y+9	; 0x09
 2fa:	3a 85       	ldd	r19, Y+10	; 0x0a
 2fc:	21 30       	cpi	r18, 0x01	; 1
 2fe:	31 05       	cpc	r19, r1
 300:	09 f0       	breq	.+2      	; 0x304 <DIO_u8SetPinValue+0x86>
 302:	99 c0       	rjmp	.+306    	; 0x436 <DIO_u8SetPinValue+0x1b8>
            {
                case DIO_u8_HIGH : SET_BIT(DIO_PORTB_REG,Copy_u8PinId)   ; break;
 304:	a5 e2       	ldi	r26, 0x25	; 37
 306:	b0 e0       	ldi	r27, 0x00	; 0
 308:	e5 e2       	ldi	r30, 0x25	; 37
 30a:	f0 e0       	ldi	r31, 0x00	; 0
 30c:	80 81       	ld	r24, Z
 30e:	48 2f       	mov	r20, r24
 310:	8b 81       	ldd	r24, Y+3	; 0x03
 312:	28 2f       	mov	r18, r24
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	02 2e       	mov	r0, r18
 31c:	02 c0       	rjmp	.+4      	; 0x322 <DIO_u8SetPinValue+0xa4>
 31e:	88 0f       	add	r24, r24
 320:	99 1f       	adc	r25, r25
 322:	0a 94       	dec	r0
 324:	e2 f7       	brpl	.-8      	; 0x31e <DIO_u8SetPinValue+0xa0>
 326:	84 2b       	or	r24, r20
 328:	8c 93       	st	X, r24
 32a:	85 c0       	rjmp	.+266    	; 0x436 <DIO_u8SetPinValue+0x1b8>
                case DIO_u8_LOW  : CLR_BIT(DIO_PORTB_REG,Copy_u8PinId)   ; break;  
 32c:	a5 e2       	ldi	r26, 0x25	; 37
 32e:	b0 e0       	ldi	r27, 0x00	; 0
 330:	e5 e2       	ldi	r30, 0x25	; 37
 332:	f0 e0       	ldi	r31, 0x00	; 0
 334:	80 81       	ld	r24, Z
 336:	48 2f       	mov	r20, r24
 338:	8b 81       	ldd	r24, Y+3	; 0x03
 33a:	28 2f       	mov	r18, r24
 33c:	30 e0       	ldi	r19, 0x00	; 0
 33e:	81 e0       	ldi	r24, 0x01	; 1
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	02 2e       	mov	r0, r18
 344:	02 c0       	rjmp	.+4      	; 0x34a <DIO_u8SetPinValue+0xcc>
 346:	88 0f       	add	r24, r24
 348:	99 1f       	adc	r25, r25
 34a:	0a 94       	dec	r0
 34c:	e2 f7       	brpl	.-8      	; 0x346 <DIO_u8SetPinValue+0xc8>
 34e:	80 95       	com	r24
 350:	84 23       	and	r24, r20
 352:	8c 93       	st	X, r24
 354:	70 c0       	rjmp	.+224    	; 0x436 <DIO_u8SetPinValue+0x1b8>
            }    
            break;
        case DIO_u8_PORTC : 
            switch (Copy_u8PinValue)
 356:	8c 81       	ldd	r24, Y+4	; 0x04
 358:	28 2f       	mov	r18, r24
 35a:	30 e0       	ldi	r19, 0x00	; 0
 35c:	38 87       	std	Y+8, r19	; 0x08
 35e:	2f 83       	std	Y+7, r18	; 0x07
 360:	8f 81       	ldd	r24, Y+7	; 0x07
 362:	98 85       	ldd	r25, Y+8	; 0x08
 364:	00 97       	sbiw	r24, 0x00	; 0
 366:	d1 f0       	breq	.+52     	; 0x39c <DIO_u8SetPinValue+0x11e>
 368:	2f 81       	ldd	r18, Y+7	; 0x07
 36a:	38 85       	ldd	r19, Y+8	; 0x08
 36c:	21 30       	cpi	r18, 0x01	; 1
 36e:	31 05       	cpc	r19, r1
 370:	09 f0       	breq	.+2      	; 0x374 <DIO_u8SetPinValue+0xf6>
 372:	61 c0       	rjmp	.+194    	; 0x436 <DIO_u8SetPinValue+0x1b8>
                {
                    case DIO_u8_HIGH : SET_BIT(DIO_PORTC_REG ,Copy_u8PinId)   ; break;
 374:	a8 e2       	ldi	r26, 0x28	; 40
 376:	b0 e0       	ldi	r27, 0x00	; 0
 378:	e8 e2       	ldi	r30, 0x28	; 40
 37a:	f0 e0       	ldi	r31, 0x00	; 0
 37c:	80 81       	ld	r24, Z
 37e:	48 2f       	mov	r20, r24
 380:	8b 81       	ldd	r24, Y+3	; 0x03
 382:	28 2f       	mov	r18, r24
 384:	30 e0       	ldi	r19, 0x00	; 0
 386:	81 e0       	ldi	r24, 0x01	; 1
 388:	90 e0       	ldi	r25, 0x00	; 0
 38a:	02 2e       	mov	r0, r18
 38c:	02 c0       	rjmp	.+4      	; 0x392 <DIO_u8SetPinValue+0x114>
 38e:	88 0f       	add	r24, r24
 390:	99 1f       	adc	r25, r25
 392:	0a 94       	dec	r0
 394:	e2 f7       	brpl	.-8      	; 0x38e <DIO_u8SetPinValue+0x110>
 396:	84 2b       	or	r24, r20
 398:	8c 93       	st	X, r24
 39a:	4d c0       	rjmp	.+154    	; 0x436 <DIO_u8SetPinValue+0x1b8>
                    case DIO_u8_LOW  : CLR_BIT(DIO_PORTC_REG ,Copy_u8PinId)   ; break;
 39c:	a8 e2       	ldi	r26, 0x28	; 40
 39e:	b0 e0       	ldi	r27, 0x00	; 0
 3a0:	e8 e2       	ldi	r30, 0x28	; 40
 3a2:	f0 e0       	ldi	r31, 0x00	; 0
 3a4:	80 81       	ld	r24, Z
 3a6:	48 2f       	mov	r20, r24
 3a8:	8b 81       	ldd	r24, Y+3	; 0x03
 3aa:	28 2f       	mov	r18, r24
 3ac:	30 e0       	ldi	r19, 0x00	; 0
 3ae:	81 e0       	ldi	r24, 0x01	; 1
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	02 2e       	mov	r0, r18
 3b4:	02 c0       	rjmp	.+4      	; 0x3ba <DIO_u8SetPinValue+0x13c>
 3b6:	88 0f       	add	r24, r24
 3b8:	99 1f       	adc	r25, r25
 3ba:	0a 94       	dec	r0
 3bc:	e2 f7       	brpl	.-8      	; 0x3b6 <DIO_u8SetPinValue+0x138>
 3be:	80 95       	com	r24
 3c0:	84 23       	and	r24, r20
 3c2:	8c 93       	st	X, r24
 3c4:	38 c0       	rjmp	.+112    	; 0x436 <DIO_u8SetPinValue+0x1b8>
                }
            break;
        case DIO_u8_PORTD : 
            switch (Copy_u8PinValue)
 3c6:	8c 81       	ldd	r24, Y+4	; 0x04
 3c8:	28 2f       	mov	r18, r24
 3ca:	30 e0       	ldi	r19, 0x00	; 0
 3cc:	3e 83       	std	Y+6, r19	; 0x06
 3ce:	2d 83       	std	Y+5, r18	; 0x05
 3d0:	8d 81       	ldd	r24, Y+5	; 0x05
 3d2:	9e 81       	ldd	r25, Y+6	; 0x06
 3d4:	00 97       	sbiw	r24, 0x00	; 0
 3d6:	c9 f0       	breq	.+50     	; 0x40a <DIO_u8SetPinValue+0x18c>
 3d8:	2d 81       	ldd	r18, Y+5	; 0x05
 3da:	3e 81       	ldd	r19, Y+6	; 0x06
 3dc:	21 30       	cpi	r18, 0x01	; 1
 3de:	31 05       	cpc	r19, r1
 3e0:	51 f5       	brne	.+84     	; 0x436 <DIO_u8SetPinValue+0x1b8>
                {
                    case DIO_u8_HIGH : SET_BIT(DIO_PORTD_REG,Copy_u8PinId)   ; break;
 3e2:	ab e2       	ldi	r26, 0x2B	; 43
 3e4:	b0 e0       	ldi	r27, 0x00	; 0
 3e6:	eb e2       	ldi	r30, 0x2B	; 43
 3e8:	f0 e0       	ldi	r31, 0x00	; 0
 3ea:	80 81       	ld	r24, Z
 3ec:	48 2f       	mov	r20, r24
 3ee:	8b 81       	ldd	r24, Y+3	; 0x03
 3f0:	28 2f       	mov	r18, r24
 3f2:	30 e0       	ldi	r19, 0x00	; 0
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	02 2e       	mov	r0, r18
 3fa:	02 c0       	rjmp	.+4      	; 0x400 <DIO_u8SetPinValue+0x182>
 3fc:	88 0f       	add	r24, r24
 3fe:	99 1f       	adc	r25, r25
 400:	0a 94       	dec	r0
 402:	e2 f7       	brpl	.-8      	; 0x3fc <DIO_u8SetPinValue+0x17e>
 404:	84 2b       	or	r24, r20
 406:	8c 93       	st	X, r24
 408:	16 c0       	rjmp	.+44     	; 0x436 <DIO_u8SetPinValue+0x1b8>
                    case DIO_u8_LOW  : CLR_BIT(DIO_PORTD_REG,Copy_u8PinId)   ; break; 
 40a:	ab e2       	ldi	r26, 0x2B	; 43
 40c:	b0 e0       	ldi	r27, 0x00	; 0
 40e:	eb e2       	ldi	r30, 0x2B	; 43
 410:	f0 e0       	ldi	r31, 0x00	; 0
 412:	80 81       	ld	r24, Z
 414:	48 2f       	mov	r20, r24
 416:	8b 81       	ldd	r24, Y+3	; 0x03
 418:	28 2f       	mov	r18, r24
 41a:	30 e0       	ldi	r19, 0x00	; 0
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	90 e0       	ldi	r25, 0x00	; 0
 420:	02 2e       	mov	r0, r18
 422:	02 c0       	rjmp	.+4      	; 0x428 <DIO_u8SetPinValue+0x1aa>
 424:	88 0f       	add	r24, r24
 426:	99 1f       	adc	r25, r25
 428:	0a 94       	dec	r0
 42a:	e2 f7       	brpl	.-8      	; 0x424 <DIO_u8SetPinValue+0x1a6>
 42c:	80 95       	com	r24
 42e:	84 23       	and	r24, r20
 430:	8c 93       	st	X, r24
 432:	01 c0       	rjmp	.+2      	; 0x436 <DIO_u8SetPinValue+0x1b8>
            break;        
        }
    }
    else 
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 434:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 436:	89 81       	ldd	r24, Y+1	; 0x01
}
 438:	2c 96       	adiw	r28, 0x0c	; 12
 43a:	0f b6       	in	r0, 0x3f	; 63
 43c:	f8 94       	cli
 43e:	de bf       	out	0x3e, r29	; 62
 440:	0f be       	out	0x3f, r0	; 63
 442:	cd bf       	out	0x3d, r28	; 61
 444:	cf 91       	pop	r28
 446:	df 91       	pop	r29
 448:	08 95       	ret

0000044a <DIO_u8TogglePin>:

u8 DIO_u8TogglePin     (u8 Copy_u8PortId,u8 Copy_u8PinId)
{
 44a:	df 93       	push	r29
 44c:	cf 93       	push	r28
 44e:	00 d0       	rcall	.+0      	; 0x450 <DIO_u8TogglePin+0x6>
 450:	00 d0       	rcall	.+0      	; 0x452 <DIO_u8TogglePin+0x8>
 452:	0f 92       	push	r0
 454:	cd b7       	in	r28, 0x3d	; 61
 456:	de b7       	in	r29, 0x3e	; 62
 458:	8a 83       	std	Y+2, r24	; 0x02
 45a:	6b 83       	std	Y+3, r22	; 0x03
    u8 Local_u8ReturnState = STD_TYPE_OK;
 45c:	81 e0       	ldi	r24, 0x01	; 1
 45e:	89 83       	std	Y+1, r24	; 0x01
    if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <=DIO_u8_PIN7))
 460:	8a 81       	ldd	r24, Y+2	; 0x02
 462:	83 30       	cpi	r24, 0x03	; 3
 464:	08 f0       	brcs	.+2      	; 0x468 <DIO_u8TogglePin+0x1e>
 466:	53 c0       	rjmp	.+166    	; 0x50e <DIO_u8TogglePin+0xc4>
 468:	8b 81       	ldd	r24, Y+3	; 0x03
 46a:	88 30       	cpi	r24, 0x08	; 8
 46c:	08 f0       	brcs	.+2      	; 0x470 <DIO_u8TogglePin+0x26>
 46e:	4f c0       	rjmp	.+158    	; 0x50e <DIO_u8TogglePin+0xc4>
    {
        switch (Copy_u8PortId)
 470:	8a 81       	ldd	r24, Y+2	; 0x02
 472:	28 2f       	mov	r18, r24
 474:	30 e0       	ldi	r19, 0x00	; 0
 476:	3d 83       	std	Y+5, r19	; 0x05
 478:	2c 83       	std	Y+4, r18	; 0x04
 47a:	8c 81       	ldd	r24, Y+4	; 0x04
 47c:	9d 81       	ldd	r25, Y+5	; 0x05
 47e:	81 30       	cpi	r24, 0x01	; 1
 480:	91 05       	cpc	r25, r1
 482:	e9 f0       	breq	.+58     	; 0x4be <DIO_u8TogglePin+0x74>
 484:	2c 81       	ldd	r18, Y+4	; 0x04
 486:	3d 81       	ldd	r19, Y+5	; 0x05
 488:	22 30       	cpi	r18, 0x02	; 2
 48a:	31 05       	cpc	r19, r1
 48c:	61 f1       	breq	.+88     	; 0x4e6 <DIO_u8TogglePin+0x9c>
 48e:	8c 81       	ldd	r24, Y+4	; 0x04
 490:	9d 81       	ldd	r25, Y+5	; 0x05
 492:	00 97       	sbiw	r24, 0x00	; 0
 494:	e9 f5       	brne	.+122    	; 0x510 <DIO_u8TogglePin+0xc6>
        {
        case DIO_u8_PORTB :TOG_BIT(DIO_PORTB_REG,Copy_u8PinId)   ; break;
 496:	a5 e2       	ldi	r26, 0x25	; 37
 498:	b0 e0       	ldi	r27, 0x00	; 0
 49a:	e5 e2       	ldi	r30, 0x25	; 37
 49c:	f0 e0       	ldi	r31, 0x00	; 0
 49e:	80 81       	ld	r24, Z
 4a0:	48 2f       	mov	r20, r24
 4a2:	8b 81       	ldd	r24, Y+3	; 0x03
 4a4:	28 2f       	mov	r18, r24
 4a6:	30 e0       	ldi	r19, 0x00	; 0
 4a8:	81 e0       	ldi	r24, 0x01	; 1
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	02 2e       	mov	r0, r18
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <DIO_u8TogglePin+0x6a>
 4b0:	88 0f       	add	r24, r24
 4b2:	99 1f       	adc	r25, r25
 4b4:	0a 94       	dec	r0
 4b6:	e2 f7       	brpl	.-8      	; 0x4b0 <DIO_u8TogglePin+0x66>
 4b8:	84 27       	eor	r24, r20
 4ba:	8c 93       	st	X, r24
 4bc:	29 c0       	rjmp	.+82     	; 0x510 <DIO_u8TogglePin+0xc6>
        case DIO_u8_PORTC :TOG_BIT(DIO_PORTC_REG,Copy_u8PinId)   ; break;
 4be:	a8 e2       	ldi	r26, 0x28	; 40
 4c0:	b0 e0       	ldi	r27, 0x00	; 0
 4c2:	e8 e2       	ldi	r30, 0x28	; 40
 4c4:	f0 e0       	ldi	r31, 0x00	; 0
 4c6:	80 81       	ld	r24, Z
 4c8:	48 2f       	mov	r20, r24
 4ca:	8b 81       	ldd	r24, Y+3	; 0x03
 4cc:	28 2f       	mov	r18, r24
 4ce:	30 e0       	ldi	r19, 0x00	; 0
 4d0:	81 e0       	ldi	r24, 0x01	; 1
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	02 2e       	mov	r0, r18
 4d6:	02 c0       	rjmp	.+4      	; 0x4dc <DIO_u8TogglePin+0x92>
 4d8:	88 0f       	add	r24, r24
 4da:	99 1f       	adc	r25, r25
 4dc:	0a 94       	dec	r0
 4de:	e2 f7       	brpl	.-8      	; 0x4d8 <DIO_u8TogglePin+0x8e>
 4e0:	84 27       	eor	r24, r20
 4e2:	8c 93       	st	X, r24
 4e4:	15 c0       	rjmp	.+42     	; 0x510 <DIO_u8TogglePin+0xc6>
        case DIO_u8_PORTD :TOG_BIT(DIO_PORTD_REG,Copy_u8PinId)   ; break;
 4e6:	ab e2       	ldi	r26, 0x2B	; 43
 4e8:	b0 e0       	ldi	r27, 0x00	; 0
 4ea:	eb e2       	ldi	r30, 0x2B	; 43
 4ec:	f0 e0       	ldi	r31, 0x00	; 0
 4ee:	80 81       	ld	r24, Z
 4f0:	48 2f       	mov	r20, r24
 4f2:	8b 81       	ldd	r24, Y+3	; 0x03
 4f4:	28 2f       	mov	r18, r24
 4f6:	30 e0       	ldi	r19, 0x00	; 0
 4f8:	81 e0       	ldi	r24, 0x01	; 1
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	02 2e       	mov	r0, r18
 4fe:	02 c0       	rjmp	.+4      	; 0x504 <DIO_u8TogglePin+0xba>
 500:	88 0f       	add	r24, r24
 502:	99 1f       	adc	r25, r25
 504:	0a 94       	dec	r0
 506:	e2 f7       	brpl	.-8      	; 0x500 <DIO_u8TogglePin+0xb6>
 508:	84 27       	eor	r24, r20
 50a:	8c 93       	st	X, r24
 50c:	01 c0       	rjmp	.+2      	; 0x510 <DIO_u8TogglePin+0xc6>
        }
    }
    else 
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 50e:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 510:	89 81       	ldd	r24, Y+1	; 0x01
}
 512:	0f 90       	pop	r0
 514:	0f 90       	pop	r0
 516:	0f 90       	pop	r0
 518:	0f 90       	pop	r0
 51a:	0f 90       	pop	r0
 51c:	cf 91       	pop	r28
 51e:	df 91       	pop	r29
 520:	08 95       	ret

00000522 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue      (u8 Copy_u8PortId,u8 Copy_u8PinId,u8 *Copy_Pu8PinValue)
{
 522:	df 93       	push	r29
 524:	cf 93       	push	r28
 526:	cd b7       	in	r28, 0x3d	; 61
 528:	de b7       	in	r29, 0x3e	; 62
 52a:	28 97       	sbiw	r28, 0x08	; 8
 52c:	0f b6       	in	r0, 0x3f	; 63
 52e:	f8 94       	cli
 530:	de bf       	out	0x3e, r29	; 62
 532:	0f be       	out	0x3f, r0	; 63
 534:	cd bf       	out	0x3d, r28	; 61
 536:	8b 83       	std	Y+3, r24	; 0x03
 538:	6c 83       	std	Y+4, r22	; 0x04
 53a:	5e 83       	std	Y+6, r21	; 0x06
 53c:	4d 83       	std	Y+5, r20	; 0x05
    u8 Local_u8ReturnState = STD_TYPE_OK;
 53e:	81 e0       	ldi	r24, 0x01	; 1
 540:	8a 83       	std	Y+2, r24	; 0x02
    u8 Local_u8PinValue; // variable to read the pin value
    if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_u8PinId <= DIO_u8_PIN7)&&(Copy_Pu8PinValue!=NULL))
 542:	8b 81       	ldd	r24, Y+3	; 0x03
 544:	83 30       	cpi	r24, 0x03	; 3
 546:	08 f0       	brcs	.+2      	; 0x54a <DIO_u8GetPinValue+0x28>
 548:	76 c0       	rjmp	.+236    	; 0x636 <DIO_u8GetPinValue+0x114>
 54a:	8c 81       	ldd	r24, Y+4	; 0x04
 54c:	88 30       	cpi	r24, 0x08	; 8
 54e:	08 f0       	brcs	.+2      	; 0x552 <DIO_u8GetPinValue+0x30>
 550:	72 c0       	rjmp	.+228    	; 0x636 <DIO_u8GetPinValue+0x114>
 552:	8d 81       	ldd	r24, Y+5	; 0x05
 554:	9e 81       	ldd	r25, Y+6	; 0x06
 556:	00 97       	sbiw	r24, 0x00	; 0
 558:	09 f4       	brne	.+2      	; 0x55c <DIO_u8GetPinValue+0x3a>
 55a:	6d c0       	rjmp	.+218    	; 0x636 <DIO_u8GetPinValue+0x114>
    {
        switch (Copy_u8PortId)
 55c:	8b 81       	ldd	r24, Y+3	; 0x03
 55e:	28 2f       	mov	r18, r24
 560:	30 e0       	ldi	r19, 0x00	; 0
 562:	38 87       	std	Y+8, r19	; 0x08
 564:	2f 83       	std	Y+7, r18	; 0x07
 566:	4f 81       	ldd	r20, Y+7	; 0x07
 568:	58 85       	ldd	r21, Y+8	; 0x08
 56a:	41 30       	cpi	r20, 0x01	; 1
 56c:	51 05       	cpc	r21, r1
 56e:	49 f1       	breq	.+82     	; 0x5c2 <DIO_u8GetPinValue+0xa0>
 570:	8f 81       	ldd	r24, Y+7	; 0x07
 572:	98 85       	ldd	r25, Y+8	; 0x08
 574:	82 30       	cpi	r24, 0x02	; 2
 576:	91 05       	cpc	r25, r1
 578:	09 f4       	brne	.+2      	; 0x57c <DIO_u8GetPinValue+0x5a>
 57a:	40 c0       	rjmp	.+128    	; 0x5fc <DIO_u8GetPinValue+0xda>
 57c:	2f 81       	ldd	r18, Y+7	; 0x07
 57e:	38 85       	ldd	r19, Y+8	; 0x08
 580:	21 15       	cp	r18, r1
 582:	31 05       	cpc	r19, r1
 584:	09 f0       	breq	.+2      	; 0x588 <DIO_u8GetPinValue+0x66>
 586:	58 c0       	rjmp	.+176    	; 0x638 <DIO_u8GetPinValue+0x116>
        {
            case DIO_u8_PORTB :
                Local_u8PinValue = GET_BIT(DIO_PINB_REG,Copy_u8PinId);
 588:	e3 e2       	ldi	r30, 0x23	; 35
 58a:	f0 e0       	ldi	r31, 0x00	; 0
 58c:	80 81       	ld	r24, Z
 58e:	28 2f       	mov	r18, r24
 590:	30 e0       	ldi	r19, 0x00	; 0
 592:	8c 81       	ldd	r24, Y+4	; 0x04
 594:	88 2f       	mov	r24, r24
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	a9 01       	movw	r20, r18
 59a:	02 c0       	rjmp	.+4      	; 0x5a0 <DIO_u8GetPinValue+0x7e>
 59c:	55 95       	asr	r21
 59e:	47 95       	ror	r20
 5a0:	8a 95       	dec	r24
 5a2:	e2 f7       	brpl	.-8      	; 0x59c <DIO_u8GetPinValue+0x7a>
 5a4:	ca 01       	movw	r24, r20
 5a6:	81 70       	andi	r24, 0x01	; 1
 5a8:	89 83       	std	Y+1, r24	; 0x01
                if(DIO_u8_HIGH==Local_u8PinValue)
 5aa:	89 81       	ldd	r24, Y+1	; 0x01
 5ac:	81 30       	cpi	r24, 0x01	; 1
 5ae:	29 f4       	brne	.+10     	; 0x5ba <DIO_u8GetPinValue+0x98>
                	{*Copy_Pu8PinValue = DIO_u8_HIGH;}
 5b0:	ed 81       	ldd	r30, Y+5	; 0x05
 5b2:	fe 81       	ldd	r31, Y+6	; 0x06
 5b4:	81 e0       	ldi	r24, 0x01	; 1
 5b6:	80 83       	st	Z, r24
 5b8:	3f c0       	rjmp	.+126    	; 0x638 <DIO_u8GetPinValue+0x116>
                else
                	{*Copy_Pu8PinValue = DIO_u8_LOW ;}
 5ba:	ed 81       	ldd	r30, Y+5	; 0x05
 5bc:	fe 81       	ldd	r31, Y+6	; 0x06
 5be:	10 82       	st	Z, r1
 5c0:	3b c0       	rjmp	.+118    	; 0x638 <DIO_u8GetPinValue+0x116>
            break;
            case DIO_u8_PORTC :
                Local_u8PinValue = GET_BIT(DIO_PINC_REG,Copy_u8PinId);
 5c2:	e6 e2       	ldi	r30, 0x26	; 38
 5c4:	f0 e0       	ldi	r31, 0x00	; 0
 5c6:	80 81       	ld	r24, Z
 5c8:	28 2f       	mov	r18, r24
 5ca:	30 e0       	ldi	r19, 0x00	; 0
 5cc:	8c 81       	ldd	r24, Y+4	; 0x04
 5ce:	88 2f       	mov	r24, r24
 5d0:	90 e0       	ldi	r25, 0x00	; 0
 5d2:	a9 01       	movw	r20, r18
 5d4:	02 c0       	rjmp	.+4      	; 0x5da <DIO_u8GetPinValue+0xb8>
 5d6:	55 95       	asr	r21
 5d8:	47 95       	ror	r20
 5da:	8a 95       	dec	r24
 5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <DIO_u8GetPinValue+0xb4>
 5de:	ca 01       	movw	r24, r20
 5e0:	81 70       	andi	r24, 0x01	; 1
 5e2:	89 83       	std	Y+1, r24	; 0x01
                if(DIO_u8_HIGH==Local_u8PinValue)
 5e4:	89 81       	ldd	r24, Y+1	; 0x01
 5e6:	81 30       	cpi	r24, 0x01	; 1
 5e8:	29 f4       	brne	.+10     	; 0x5f4 <DIO_u8GetPinValue+0xd2>
					{*Copy_Pu8PinValue = DIO_u8_HIGH;}
 5ea:	ed 81       	ldd	r30, Y+5	; 0x05
 5ec:	fe 81       	ldd	r31, Y+6	; 0x06
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	80 83       	st	Z, r24
 5f2:	22 c0       	rjmp	.+68     	; 0x638 <DIO_u8GetPinValue+0x116>
				else
					{*Copy_Pu8PinValue = DIO_u8_LOW ;}
 5f4:	ed 81       	ldd	r30, Y+5	; 0x05
 5f6:	fe 81       	ldd	r31, Y+6	; 0x06
 5f8:	10 82       	st	Z, r1
 5fa:	1e c0       	rjmp	.+60     	; 0x638 <DIO_u8GetPinValue+0x116>
            break;
            case DIO_u8_PORTD :
                Local_u8PinValue = GET_BIT(DIO_PIND_REG,Copy_u8PinId);
 5fc:	e9 e2       	ldi	r30, 0x29	; 41
 5fe:	f0 e0       	ldi	r31, 0x00	; 0
 600:	80 81       	ld	r24, Z
 602:	28 2f       	mov	r18, r24
 604:	30 e0       	ldi	r19, 0x00	; 0
 606:	8c 81       	ldd	r24, Y+4	; 0x04
 608:	88 2f       	mov	r24, r24
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	a9 01       	movw	r20, r18
 60e:	02 c0       	rjmp	.+4      	; 0x614 <DIO_u8GetPinValue+0xf2>
 610:	55 95       	asr	r21
 612:	47 95       	ror	r20
 614:	8a 95       	dec	r24
 616:	e2 f7       	brpl	.-8      	; 0x610 <DIO_u8GetPinValue+0xee>
 618:	ca 01       	movw	r24, r20
 61a:	81 70       	andi	r24, 0x01	; 1
 61c:	89 83       	std	Y+1, r24	; 0x01
                if(DIO_u8_HIGH==Local_u8PinValue)
 61e:	89 81       	ldd	r24, Y+1	; 0x01
 620:	81 30       	cpi	r24, 0x01	; 1
 622:	29 f4       	brne	.+10     	; 0x62e <DIO_u8GetPinValue+0x10c>
					{*Copy_Pu8PinValue = DIO_u8_HIGH;}
 624:	ed 81       	ldd	r30, Y+5	; 0x05
 626:	fe 81       	ldd	r31, Y+6	; 0x06
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	80 83       	st	Z, r24
 62c:	05 c0       	rjmp	.+10     	; 0x638 <DIO_u8GetPinValue+0x116>
				else
					{*Copy_Pu8PinValue = DIO_u8_LOW ;}
 62e:	ed 81       	ldd	r30, Y+5	; 0x05
 630:	fe 81       	ldd	r31, Y+6	; 0x06
 632:	10 82       	st	Z, r1
 634:	01 c0       	rjmp	.+2      	; 0x638 <DIO_u8GetPinValue+0x116>

        }
    }
    else
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 636:	1a 82       	std	Y+2, r1	; 0x02
    }
    return Local_u8ReturnState;
 638:	8a 81       	ldd	r24, Y+2	; 0x02
}
 63a:	28 96       	adiw	r28, 0x08	; 8
 63c:	0f b6       	in	r0, 0x3f	; 63
 63e:	f8 94       	cli
 640:	de bf       	out	0x3e, r29	; 62
 642:	0f be       	out	0x3f, r0	; 63
 644:	cd bf       	out	0x3d, r28	; 61
 646:	cf 91       	pop	r28
 648:	df 91       	pop	r29
 64a:	08 95       	ret

0000064c <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection (u8 Copy_u8PortId, u8 Copy_u8PortDirection)
{
 64c:	df 93       	push	r29
 64e:	cf 93       	push	r28
 650:	cd b7       	in	r28, 0x3d	; 61
 652:	de b7       	in	r29, 0x3e	; 62
 654:	2b 97       	sbiw	r28, 0x0b	; 11
 656:	0f b6       	in	r0, 0x3f	; 63
 658:	f8 94       	cli
 65a:	de bf       	out	0x3e, r29	; 62
 65c:	0f be       	out	0x3f, r0	; 63
 65e:	cd bf       	out	0x3d, r28	; 61
 660:	8a 83       	std	Y+2, r24	; 0x02
 662:	6b 83       	std	Y+3, r22	; 0x03
    u8 Local_u8ReturnState = STD_TYPE_OK;
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	89 83       	std	Y+1, r24	; 0x01
    if((Copy_u8PortId <= DIO_u8_PORTD)&&((Copy_u8PortDirection == DIO_u8_INPUT)||(Copy_u8PortDirection == DIO_u8_OUTPUT)))
 668:	8a 81       	ldd	r24, Y+2	; 0x02
 66a:	83 30       	cpi	r24, 0x03	; 3
 66c:	08 f0       	brcs	.+2      	; 0x670 <DIO_u8SetPortDirection+0x24>
 66e:	60 c0       	rjmp	.+192    	; 0x730 <DIO_u8SetPortDirection+0xe4>
 670:	8b 81       	ldd	r24, Y+3	; 0x03
 672:	88 23       	and	r24, r24
 674:	21 f0       	breq	.+8      	; 0x67e <DIO_u8SetPortDirection+0x32>
 676:	8b 81       	ldd	r24, Y+3	; 0x03
 678:	81 30       	cpi	r24, 0x01	; 1
 67a:	09 f0       	breq	.+2      	; 0x67e <DIO_u8SetPortDirection+0x32>
 67c:	59 c0       	rjmp	.+178    	; 0x730 <DIO_u8SetPortDirection+0xe4>
    {
        switch (Copy_u8PortId)
 67e:	8a 81       	ldd	r24, Y+2	; 0x02
 680:	28 2f       	mov	r18, r24
 682:	30 e0       	ldi	r19, 0x00	; 0
 684:	3b 87       	std	Y+11, r19	; 0x0b
 686:	2a 87       	std	Y+10, r18	; 0x0a
 688:	8a 85       	ldd	r24, Y+10	; 0x0a
 68a:	9b 85       	ldd	r25, Y+11	; 0x0b
 68c:	81 30       	cpi	r24, 0x01	; 1
 68e:	91 05       	cpc	r25, r1
 690:	09 f1       	breq	.+66     	; 0x6d4 <DIO_u8SetPortDirection+0x88>
 692:	2a 85       	ldd	r18, Y+10	; 0x0a
 694:	3b 85       	ldd	r19, Y+11	; 0x0b
 696:	22 30       	cpi	r18, 0x02	; 2
 698:	31 05       	cpc	r19, r1
 69a:	99 f1       	breq	.+102    	; 0x702 <DIO_u8SetPortDirection+0xb6>
 69c:	8a 85       	ldd	r24, Y+10	; 0x0a
 69e:	9b 85       	ldd	r25, Y+11	; 0x0b
 6a0:	00 97       	sbiw	r24, 0x00	; 0
 6a2:	09 f0       	breq	.+2      	; 0x6a6 <DIO_u8SetPortDirection+0x5a>
 6a4:	46 c0       	rjmp	.+140    	; 0x732 <DIO_u8SetPortDirection+0xe6>
        {
            case DIO_u8_PORTB : 
                switch (Copy_u8PortDirection)
 6a6:	8b 81       	ldd	r24, Y+3	; 0x03
 6a8:	28 2f       	mov	r18, r24
 6aa:	30 e0       	ldi	r19, 0x00	; 0
 6ac:	39 87       	std	Y+9, r19	; 0x09
 6ae:	28 87       	std	Y+8, r18	; 0x08
 6b0:	88 85       	ldd	r24, Y+8	; 0x08
 6b2:	99 85       	ldd	r25, Y+9	; 0x09
 6b4:	00 97       	sbiw	r24, 0x00	; 0
 6b6:	51 f0       	breq	.+20     	; 0x6cc <DIO_u8SetPortDirection+0x80>
 6b8:	28 85       	ldd	r18, Y+8	; 0x08
 6ba:	39 85       	ldd	r19, Y+9	; 0x09
 6bc:	21 30       	cpi	r18, 0x01	; 1
 6be:	31 05       	cpc	r19, r1
 6c0:	c1 f5       	brne	.+112    	; 0x732 <DIO_u8SetPortDirection+0xe6>
                {
                    case DIO_u8_OUTPUT:  DIO_DDRB_REG =0xff; break;
 6c2:	e4 e2       	ldi	r30, 0x24	; 36
 6c4:	f0 e0       	ldi	r31, 0x00	; 0
 6c6:	8f ef       	ldi	r24, 0xFF	; 255
 6c8:	80 83       	st	Z, r24
 6ca:	33 c0       	rjmp	.+102    	; 0x732 <DIO_u8SetPortDirection+0xe6>
                    case DIO_u8_INPUT :  DIO_DDRB_REG =0x00; break;
 6cc:	e4 e2       	ldi	r30, 0x24	; 36
 6ce:	f0 e0       	ldi	r31, 0x00	; 0
 6d0:	10 82       	st	Z, r1
 6d2:	2f c0       	rjmp	.+94     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                }
            break;
            case DIO_u8_PORTC : 
                switch (Copy_u8PortDirection)
 6d4:	8b 81       	ldd	r24, Y+3	; 0x03
 6d6:	28 2f       	mov	r18, r24
 6d8:	30 e0       	ldi	r19, 0x00	; 0
 6da:	3f 83       	std	Y+7, r19	; 0x07
 6dc:	2e 83       	std	Y+6, r18	; 0x06
 6de:	8e 81       	ldd	r24, Y+6	; 0x06
 6e0:	9f 81       	ldd	r25, Y+7	; 0x07
 6e2:	00 97       	sbiw	r24, 0x00	; 0
 6e4:	51 f0       	breq	.+20     	; 0x6fa <DIO_u8SetPortDirection+0xae>
 6e6:	2e 81       	ldd	r18, Y+6	; 0x06
 6e8:	3f 81       	ldd	r19, Y+7	; 0x07
 6ea:	21 30       	cpi	r18, 0x01	; 1
 6ec:	31 05       	cpc	r19, r1
 6ee:	09 f5       	brne	.+66     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                {
                    case DIO_u8_OUTPUT:  DIO_DDRC_REG =0xff; break;
 6f0:	e7 e2       	ldi	r30, 0x27	; 39
 6f2:	f0 e0       	ldi	r31, 0x00	; 0
 6f4:	8f ef       	ldi	r24, 0xFF	; 255
 6f6:	80 83       	st	Z, r24
 6f8:	1c c0       	rjmp	.+56     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                    case DIO_u8_INPUT :  DIO_DDRC_REG =0x00; break;
 6fa:	e7 e2       	ldi	r30, 0x27	; 39
 6fc:	f0 e0       	ldi	r31, 0x00	; 0
 6fe:	10 82       	st	Z, r1
 700:	18 c0       	rjmp	.+48     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                }
            break;
            case DIO_u8_PORTD : 
                switch (Copy_u8PortDirection)
 702:	8b 81       	ldd	r24, Y+3	; 0x03
 704:	28 2f       	mov	r18, r24
 706:	30 e0       	ldi	r19, 0x00	; 0
 708:	3d 83       	std	Y+5, r19	; 0x05
 70a:	2c 83       	std	Y+4, r18	; 0x04
 70c:	8c 81       	ldd	r24, Y+4	; 0x04
 70e:	9d 81       	ldd	r25, Y+5	; 0x05
 710:	00 97       	sbiw	r24, 0x00	; 0
 712:	51 f0       	breq	.+20     	; 0x728 <DIO_u8SetPortDirection+0xdc>
 714:	2c 81       	ldd	r18, Y+4	; 0x04
 716:	3d 81       	ldd	r19, Y+5	; 0x05
 718:	21 30       	cpi	r18, 0x01	; 1
 71a:	31 05       	cpc	r19, r1
 71c:	51 f4       	brne	.+20     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                {
                    case DIO_u8_OUTPUT:  DIO_DDRD_REG =0xff; break;
 71e:	ea e2       	ldi	r30, 0x2A	; 42
 720:	f0 e0       	ldi	r31, 0x00	; 0
 722:	8f ef       	ldi	r24, 0xFF	; 255
 724:	80 83       	st	Z, r24
 726:	05 c0       	rjmp	.+10     	; 0x732 <DIO_u8SetPortDirection+0xe6>
                    case DIO_u8_INPUT :  DIO_DDRD_REG =0x00; break;
 728:	ea e2       	ldi	r30, 0x2A	; 42
 72a:	f0 e0       	ldi	r31, 0x00	; 0
 72c:	10 82       	st	Z, r1
 72e:	01 c0       	rjmp	.+2      	; 0x732 <DIO_u8SetPortDirection+0xe6>
            break;
        }
    }
    else 
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 730:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 732:	89 81       	ldd	r24, Y+1	; 0x01

}
 734:	2b 96       	adiw	r28, 0x0b	; 11
 736:	0f b6       	in	r0, 0x3f	; 63
 738:	f8 94       	cli
 73a:	de bf       	out	0x3e, r29	; 62
 73c:	0f be       	out	0x3f, r0	; 63
 73e:	cd bf       	out	0x3d, r28	; 61
 740:	cf 91       	pop	r28
 742:	df 91       	pop	r29
 744:	08 95       	ret

00000746 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue     (u8 Copy_u8PortId, u8 Copy_u8PortValue)
{
 746:	df 93       	push	r29
 748:	cf 93       	push	r28
 74a:	00 d0       	rcall	.+0      	; 0x74c <DIO_u8SetPortValue+0x6>
 74c:	00 d0       	rcall	.+0      	; 0x74e <DIO_u8SetPortValue+0x8>
 74e:	0f 92       	push	r0
 750:	cd b7       	in	r28, 0x3d	; 61
 752:	de b7       	in	r29, 0x3e	; 62
 754:	8a 83       	std	Y+2, r24	; 0x02
 756:	6b 83       	std	Y+3, r22	; 0x03
    u8 Local_u8ReturnState = STD_TYPE_OK;
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	89 83       	std	Y+1, r24	; 0x01
    switch (Copy_u8PortId)
 75c:	8a 81       	ldd	r24, Y+2	; 0x02
 75e:	28 2f       	mov	r18, r24
 760:	30 e0       	ldi	r19, 0x00	; 0
 762:	3d 83       	std	Y+5, r19	; 0x05
 764:	2c 83       	std	Y+4, r18	; 0x04
 766:	8c 81       	ldd	r24, Y+4	; 0x04
 768:	9d 81       	ldd	r25, Y+5	; 0x05
 76a:	81 30       	cpi	r24, 0x01	; 1
 76c:	91 05       	cpc	r25, r1
 76e:	71 f0       	breq	.+28     	; 0x78c <DIO_u8SetPortValue+0x46>
 770:	2c 81       	ldd	r18, Y+4	; 0x04
 772:	3d 81       	ldd	r19, Y+5	; 0x05
 774:	22 30       	cpi	r18, 0x02	; 2
 776:	31 05       	cpc	r19, r1
 778:	71 f0       	breq	.+28     	; 0x796 <DIO_u8SetPortValue+0x50>
 77a:	8c 81       	ldd	r24, Y+4	; 0x04
 77c:	9d 81       	ldd	r25, Y+5	; 0x05
 77e:	00 97       	sbiw	r24, 0x00	; 0
 780:	79 f4       	brne	.+30     	; 0x7a0 <DIO_u8SetPortValue+0x5a>
    {
        case DIO_u8_PORTB : DIO_PORTB_REG = Copy_u8PortValue; break;
 782:	e5 e2       	ldi	r30, 0x25	; 37
 784:	f0 e0       	ldi	r31, 0x00	; 0
 786:	8b 81       	ldd	r24, Y+3	; 0x03
 788:	80 83       	st	Z, r24
 78a:	0b c0       	rjmp	.+22     	; 0x7a2 <DIO_u8SetPortValue+0x5c>
        case DIO_u8_PORTC : DIO_PORTC_REG = Copy_u8PortValue; break;
 78c:	e8 e2       	ldi	r30, 0x28	; 40
 78e:	f0 e0       	ldi	r31, 0x00	; 0
 790:	8b 81       	ldd	r24, Y+3	; 0x03
 792:	80 83       	st	Z, r24
 794:	06 c0       	rjmp	.+12     	; 0x7a2 <DIO_u8SetPortValue+0x5c>
        case DIO_u8_PORTD : DIO_PORTD_REG = Copy_u8PortValue; break;
 796:	eb e2       	ldi	r30, 0x2B	; 43
 798:	f0 e0       	ldi	r31, 0x00	; 0
 79a:	8b 81       	ldd	r24, Y+3	; 0x03
 79c:	80 83       	st	Z, r24
 79e:	01 c0       	rjmp	.+2      	; 0x7a2 <DIO_u8SetPortValue+0x5c>
        default : Local_u8ReturnState = STD_TYPE_NOK;         break;
 7a0:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 7a2:	89 81       	ldd	r24, Y+1	; 0x01
}
 7a4:	0f 90       	pop	r0
 7a6:	0f 90       	pop	r0
 7a8:	0f 90       	pop	r0
 7aa:	0f 90       	pop	r0
 7ac:	0f 90       	pop	r0
 7ae:	cf 91       	pop	r28
 7b0:	df 91       	pop	r29
 7b2:	08 95       	ret

000007b4 <Dio_u8GetPortValue>:

u8 Dio_u8GetPortValue     (u8 Copy_u8PortId,u8 *Copy_Pu8PortValue)
{
 7b4:	df 93       	push	r29
 7b6:	cf 93       	push	r28
 7b8:	00 d0       	rcall	.+0      	; 0x7ba <Dio_u8GetPortValue+0x6>
 7ba:	00 d0       	rcall	.+0      	; 0x7bc <Dio_u8GetPortValue+0x8>
 7bc:	00 d0       	rcall	.+0      	; 0x7be <Dio_u8GetPortValue+0xa>
 7be:	cd b7       	in	r28, 0x3d	; 61
 7c0:	de b7       	in	r29, 0x3e	; 62
 7c2:	8a 83       	std	Y+2, r24	; 0x02
 7c4:	7c 83       	std	Y+4, r23	; 0x04
 7c6:	6b 83       	std	Y+3, r22	; 0x03
    u8 Local_u8ReturnState = STD_TYPE_OK;
 7c8:	81 e0       	ldi	r24, 0x01	; 1
 7ca:	89 83       	std	Y+1, r24	; 0x01
    if((Copy_u8PortId >= DIO_u8_PORTD)&&(Copy_Pu8PortValue!=NULL))
 7cc:	8a 81       	ldd	r24, Y+2	; 0x02
 7ce:	82 30       	cpi	r24, 0x02	; 2
 7d0:	60 f1       	brcs	.+88     	; 0x82a <Dio_u8GetPortValue+0x76>
 7d2:	8b 81       	ldd	r24, Y+3	; 0x03
 7d4:	9c 81       	ldd	r25, Y+4	; 0x04
 7d6:	00 97       	sbiw	r24, 0x00	; 0
 7d8:	41 f1       	breq	.+80     	; 0x82a <Dio_u8GetPortValue+0x76>
    {
        switch (Copy_u8PortId)
 7da:	8a 81       	ldd	r24, Y+2	; 0x02
 7dc:	28 2f       	mov	r18, r24
 7de:	30 e0       	ldi	r19, 0x00	; 0
 7e0:	3e 83       	std	Y+6, r19	; 0x06
 7e2:	2d 83       	std	Y+5, r18	; 0x05
 7e4:	8d 81       	ldd	r24, Y+5	; 0x05
 7e6:	9e 81       	ldd	r25, Y+6	; 0x06
 7e8:	81 30       	cpi	r24, 0x01	; 1
 7ea:	91 05       	cpc	r25, r1
 7ec:	81 f0       	breq	.+32     	; 0x80e <Dio_u8GetPortValue+0x5a>
 7ee:	2d 81       	ldd	r18, Y+5	; 0x05
 7f0:	3e 81       	ldd	r19, Y+6	; 0x06
 7f2:	22 30       	cpi	r18, 0x02	; 2
 7f4:	31 05       	cpc	r19, r1
 7f6:	91 f0       	breq	.+36     	; 0x81c <Dio_u8GetPortValue+0x68>
 7f8:	8d 81       	ldd	r24, Y+5	; 0x05
 7fa:	9e 81       	ldd	r25, Y+6	; 0x06
 7fc:	00 97       	sbiw	r24, 0x00	; 0
 7fe:	b1 f4       	brne	.+44     	; 0x82c <Dio_u8GetPortValue+0x78>
        {
        case DIO_u8_PORTB :*Copy_Pu8PortValue = DIO_PINB_REG; break;
 800:	e3 e2       	ldi	r30, 0x23	; 35
 802:	f0 e0       	ldi	r31, 0x00	; 0
 804:	80 81       	ld	r24, Z
 806:	eb 81       	ldd	r30, Y+3	; 0x03
 808:	fc 81       	ldd	r31, Y+4	; 0x04
 80a:	80 83       	st	Z, r24
 80c:	0f c0       	rjmp	.+30     	; 0x82c <Dio_u8GetPortValue+0x78>
        case DIO_u8_PORTC :*Copy_Pu8PortValue = DIO_PINC_REG; break;
 80e:	e6 e2       	ldi	r30, 0x26	; 38
 810:	f0 e0       	ldi	r31, 0x00	; 0
 812:	80 81       	ld	r24, Z
 814:	eb 81       	ldd	r30, Y+3	; 0x03
 816:	fc 81       	ldd	r31, Y+4	; 0x04
 818:	80 83       	st	Z, r24
 81a:	08 c0       	rjmp	.+16     	; 0x82c <Dio_u8GetPortValue+0x78>
        case DIO_u8_PORTD :*Copy_Pu8PortValue = DIO_PIND_REG; break;
 81c:	e9 e2       	ldi	r30, 0x29	; 41
 81e:	f0 e0       	ldi	r31, 0x00	; 0
 820:	80 81       	ld	r24, Z
 822:	eb 81       	ldd	r30, Y+3	; 0x03
 824:	fc 81       	ldd	r31, Y+4	; 0x04
 826:	80 83       	st	Z, r24
 828:	01 c0       	rjmp	.+2      	; 0x82c <Dio_u8GetPortValue+0x78>
        }
    }
    else 
    {
        Local_u8ReturnState = STD_TYPE_NOK;
 82a:	19 82       	std	Y+1, r1	; 0x01
    }
    return Local_u8ReturnState;
 82c:	89 81       	ldd	r24, Y+1	; 0x01
}
 82e:	26 96       	adiw	r28, 0x06	; 6
 830:	0f b6       	in	r0, 0x3f	; 63
 832:	f8 94       	cli
 834:	de bf       	out	0x3e, r29	; 62
 836:	0f be       	out	0x3f, r0	; 63
 838:	cd bf       	out	0x3d, r28	; 61
 83a:	cf 91       	pop	r28
 83c:	df 91       	pop	r29
 83e:	08 95       	ret

00000840 <I2C_voidMasterInit>:
#include "I2C_config.h"
#include "I2c_interface.h"


void I2C_voidMasterInit(void)
{
 840:	df 93       	push	r29
 842:	cf 93       	push	r28
 844:	cd b7       	in	r28, 0x3d	; 61
 846:	de b7       	in	r29, 0x3e	; 62
    /*set prescaler : 1 */
    CLR_BIT(I2C_TWSR_REG,1);    CLR_BIT(I2C_TWSR_REG,0);
 848:	a9 eb       	ldi	r26, 0xB9	; 185
 84a:	b0 e0       	ldi	r27, 0x00	; 0
 84c:	e9 eb       	ldi	r30, 0xB9	; 185
 84e:	f0 e0       	ldi	r31, 0x00	; 0
 850:	80 81       	ld	r24, Z
 852:	8d 7f       	andi	r24, 0xFD	; 253
 854:	8c 93       	st	X, r24
 856:	a9 eb       	ldi	r26, 0xB9	; 185
 858:	b0 e0       	ldi	r27, 0x00	; 0
 85a:	e9 eb       	ldi	r30, 0xB9	; 185
 85c:	f0 e0       	ldi	r31, 0x00	; 0
 85e:	80 81       	ld	r24, Z
 860:	8e 7f       	andi	r24, 0xFE	; 254
 862:	8c 93       	st	X, r24
    /*calculate TWBR value : 200KHZ  */
    I2C_TWBR_REG = 32; 
 864:	e8 eb       	ldi	r30, 0xB8	; 184
 866:	f0 e0       	ldi	r31, 0x00	; 0
 868:	80 e2       	ldi	r24, 0x20	; 32
 86a:	80 83       	st	Z, r24
    /*Enable ACK*/
    SET_BIT(I2C_TWCR_REG,6); 
 86c:	ac eb       	ldi	r26, 0xBC	; 188
 86e:	b0 e0       	ldi	r27, 0x00	; 0
 870:	ec eb       	ldi	r30, 0xBC	; 188
 872:	f0 e0       	ldi	r31, 0x00	; 0
 874:	80 81       	ld	r24, Z
 876:	80 64       	ori	r24, 0x40	; 64
 878:	8c 93       	st	X, r24
    /*Enable I2C*/
    SET_BIT(I2C_TWCR_REG,2); 
 87a:	ac eb       	ldi	r26, 0xBC	; 188
 87c:	b0 e0       	ldi	r27, 0x00	; 0
 87e:	ec eb       	ldi	r30, 0xBC	; 188
 880:	f0 e0       	ldi	r31, 0x00	; 0
 882:	80 81       	ld	r24, Z
 884:	84 60       	ori	r24, 0x04	; 4
 886:	8c 93       	st	X, r24
}
 888:	cf 91       	pop	r28
 88a:	df 91       	pop	r29
 88c:	08 95       	ret

0000088e <I2C_enumSlaveInit>:

I2C_ErrorState  I2C_enumSlaveInit(u8 Copy_u8SA)
{
 88e:	df 93       	push	r29
 890:	cf 93       	push	r28
 892:	00 d0       	rcall	.+0      	; 0x894 <I2C_enumSlaveInit+0x6>
 894:	cd b7       	in	r28, 0x3d	; 61
 896:	de b7       	in	r29, 0x3e	; 62
 898:	8a 83       	std	Y+2, r24	; 0x02
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 89a:	81 e0       	ldi	r24, 0x01	; 1
 89c:	89 83       	std	Y+1, r24	; 0x01
    /*0000000 , 1111xxx limitations*/
    /*2^7 = 128 ,, 1111xxx = min 120  */
    if ((Copy_u8SA < 120)&& (Copy_u8SA >0))
 89e:	8a 81       	ldd	r24, Y+2	; 0x02
 8a0:	88 37       	cpi	r24, 0x78	; 120
 8a2:	80 f4       	brcc	.+32     	; 0x8c4 <I2C_enumSlaveInit+0x36>
 8a4:	8a 81       	ldd	r24, Y+2	; 0x02
 8a6:	88 23       	and	r24, r24
 8a8:	69 f0       	breq	.+26     	; 0x8c4 <I2C_enumSlaveInit+0x36>
    {
       /*set slave add Most 7 Bits*/
        I2C_TWAR_REG = Copy_u8SA<<1;
 8aa:	ea eb       	ldi	r30, 0xBA	; 186
 8ac:	f0 e0       	ldi	r31, 0x00	; 0
 8ae:	8a 81       	ldd	r24, Y+2	; 0x02
 8b0:	88 0f       	add	r24, r24
 8b2:	80 83       	st	Z, r24
        /*Enable I2C*/
        SET_BIT(I2C_TWCR_REG,2); 
 8b4:	ac eb       	ldi	r26, 0xBC	; 188
 8b6:	b0 e0       	ldi	r27, 0x00	; 0
 8b8:	ec eb       	ldi	r30, 0xBC	; 188
 8ba:	f0 e0       	ldi	r31, 0x00	; 0
 8bc:	80 81       	ld	r24, Z
 8be:	84 60       	ori	r24, 0x04	; 4
 8c0:	8c 93       	st	X, r24
 8c2:	02 c0       	rjmp	.+4      	; 0x8c8 <I2C_enumSlaveInit+0x3a>
    }
    else 
    {
        Local_enumErrorState = I2C_SLA_OOR_Error;
 8c4:	85 e0       	ldi	r24, 0x05	; 5
 8c6:	89 83       	std	Y+1, r24	; 0x01
    }
    

    return Local_enumErrorState;
 8c8:	89 81       	ldd	r24, Y+1	; 0x01
}
 8ca:	0f 90       	pop	r0
 8cc:	0f 90       	pop	r0
 8ce:	cf 91       	pop	r28
 8d0:	df 91       	pop	r29
 8d2:	08 95       	ret

000008d4 <I2C_enumSendSC>:

I2C_ErrorState I2C_enumSendSC(void)
{
 8d4:	df 93       	push	r29
 8d6:	cf 93       	push	r28
 8d8:	00 d0       	rcall	.+0      	; 0x8da <I2C_enumSendSC+0x6>
 8da:	0f 92       	push	r0
 8dc:	cd b7       	in	r28, 0x3d	; 61
 8de:	de b7       	in	r29, 0x3e	; 62
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 8e0:	81 e0       	ldi	r24, 0x01	; 1
 8e2:	8b 83       	std	Y+3, r24	; 0x03
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 8e4:	1a 82       	std	Y+2, r1	; 0x02
 8e6:	19 82       	std	Y+1, r1	; 0x01
    /*start condition*/
    SET_BIT(I2C_TWCR_REG,5);
 8e8:	ac eb       	ldi	r26, 0xBC	; 188
 8ea:	b0 e0       	ldi	r27, 0x00	; 0
 8ec:	ec eb       	ldi	r30, 0xBC	; 188
 8ee:	f0 e0       	ldi	r31, 0x00	; 0
 8f0:	80 81       	ld	r24, Z
 8f2:	80 62       	ori	r24, 0x20	; 32
 8f4:	8c 93       	st	X, r24
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
 8f6:	ac eb       	ldi	r26, 0xBC	; 188
 8f8:	b0 e0       	ldi	r27, 0x00	; 0
 8fa:	ec eb       	ldi	r30, 0xBC	; 188
 8fc:	f0 e0       	ldi	r31, 0x00	; 0
 8fe:	80 81       	ld	r24, Z
 900:	80 68       	ori	r24, 0x80	; 128
 902:	8c 93       	st	X, r24
 904:	05 c0       	rjmp	.+10     	; 0x910 <__stack+0x11>
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
    {
        Local_u16CNT++;
 906:	89 81       	ldd	r24, Y+1	; 0x01
 908:	9a 81       	ldd	r25, Y+2	; 0x02
 90a:	01 96       	adiw	r24, 0x01	; 1
 90c:	9a 83       	std	Y+2, r25	; 0x02
 90e:	89 83       	std	Y+1, r24	; 0x01
    /*start condition*/
    SET_BIT(I2C_TWCR_REG,5);
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 910:	ec eb       	ldi	r30, 0xBC	; 188
 912:	f0 e0       	ldi	r31, 0x00	; 0
 914:	80 81       	ld	r24, Z
 916:	88 23       	and	r24, r24
 918:	34 f0       	brlt	.+12     	; 0x926 <__stack+0x27>
 91a:	89 81       	ldd	r24, Y+1	; 0x01
 91c:	9a 81       	ldd	r25, Y+2	; 0x02
 91e:	23 e1       	ldi	r18, 0x13	; 19
 920:	88 38       	cpi	r24, 0x88	; 136
 922:	92 07       	cpc	r25, r18
 924:	80 f3       	brcs	.-32     	; 0x906 <__stack+0x7>
    {
        Local_u16CNT++;
    }
    /*check status code : start cond*/
    if((I2C_TWSR_REG&0xF8)!=I2C_SC_STATE)
 926:	e9 eb       	ldi	r30, 0xB9	; 185
 928:	f0 e0       	ldi	r31, 0x00	; 0
 92a:	80 81       	ld	r24, Z
 92c:	88 2f       	mov	r24, r24
 92e:	90 e0       	ldi	r25, 0x00	; 0
 930:	88 7f       	andi	r24, 0xF8	; 248
 932:	90 70       	andi	r25, 0x00	; 0
 934:	88 30       	cpi	r24, 0x08	; 8
 936:	91 05       	cpc	r25, r1
 938:	19 f0       	breq	.+6      	; 0x940 <__stack+0x41>
    {
        Local_enumErrorState = I2C_SC_Error;
 93a:	82 e0       	ldi	r24, 0x02	; 2
 93c:	8b 83       	std	Y+3, r24	; 0x03
 93e:	07 c0       	rjmp	.+14     	; 0x94e <__stack+0x4f>
    }
    else
    {
        /*clear start cond*/
        CLR_BIT(I2C_TWCR_REG,5);
 940:	ac eb       	ldi	r26, 0xBC	; 188
 942:	b0 e0       	ldi	r27, 0x00	; 0
 944:	ec eb       	ldi	r30, 0xBC	; 188
 946:	f0 e0       	ldi	r31, 0x00	; 0
 948:	80 81       	ld	r24, Z
 94a:	8f 7d       	andi	r24, 0xDF	; 223
 94c:	8c 93       	st	X, r24
    }
    
    return Local_enumErrorState;
 94e:	8b 81       	ldd	r24, Y+3	; 0x03
}
 950:	0f 90       	pop	r0
 952:	0f 90       	pop	r0
 954:	0f 90       	pop	r0
 956:	cf 91       	pop	r28
 958:	df 91       	pop	r29
 95a:	08 95       	ret

0000095c <I2C_enumReSendStartC>:

I2C_ErrorState I2C_enumReSendStartC(void)
{
 95c:	df 93       	push	r29
 95e:	cf 93       	push	r28
 960:	00 d0       	rcall	.+0      	; 0x962 <I2C_enumReSendStartC+0x6>
 962:	0f 92       	push	r0
 964:	cd b7       	in	r28, 0x3d	; 61
 966:	de b7       	in	r29, 0x3e	; 62
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 968:	81 e0       	ldi	r24, 0x01	; 1
 96a:	8b 83       	std	Y+3, r24	; 0x03
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 96c:	1a 82       	std	Y+2, r1	; 0x02
 96e:	19 82       	std	Y+1, r1	; 0x01
    /*start condition*/
    SET_BIT(I2C_TWCR_REG,5);
 970:	ac eb       	ldi	r26, 0xBC	; 188
 972:	b0 e0       	ldi	r27, 0x00	; 0
 974:	ec eb       	ldi	r30, 0xBC	; 188
 976:	f0 e0       	ldi	r31, 0x00	; 0
 978:	80 81       	ld	r24, Z
 97a:	80 62       	ori	r24, 0x20	; 32
 97c:	8c 93       	st	X, r24
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
 97e:	ac eb       	ldi	r26, 0xBC	; 188
 980:	b0 e0       	ldi	r27, 0x00	; 0
 982:	ec eb       	ldi	r30, 0xBC	; 188
 984:	f0 e0       	ldi	r31, 0x00	; 0
 986:	80 81       	ld	r24, Z
 988:	80 68       	ori	r24, 0x80	; 128
 98a:	8c 93       	st	X, r24
 98c:	05 c0       	rjmp	.+10     	; 0x998 <I2C_enumReSendStartC+0x3c>
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
    {
        Local_u16CNT++;
 98e:	89 81       	ldd	r24, Y+1	; 0x01
 990:	9a 81       	ldd	r25, Y+2	; 0x02
 992:	01 96       	adiw	r24, 0x01	; 1
 994:	9a 83       	std	Y+2, r25	; 0x02
 996:	89 83       	std	Y+1, r24	; 0x01
    /*start condition*/
    SET_BIT(I2C_TWCR_REG,5);
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 998:	ec eb       	ldi	r30, 0xBC	; 188
 99a:	f0 e0       	ldi	r31, 0x00	; 0
 99c:	80 81       	ld	r24, Z
 99e:	88 23       	and	r24, r24
 9a0:	34 f0       	brlt	.+12     	; 0x9ae <I2C_enumReSendStartC+0x52>
 9a2:	89 81       	ldd	r24, Y+1	; 0x01
 9a4:	9a 81       	ldd	r25, Y+2	; 0x02
 9a6:	23 e1       	ldi	r18, 0x13	; 19
 9a8:	88 38       	cpi	r24, 0x88	; 136
 9aa:	92 07       	cpc	r25, r18
 9ac:	80 f3       	brcs	.-32     	; 0x98e <I2C_enumReSendStartC+0x32>
    {
        Local_u16CNT++;
    }
    /*check status code : R start cond*/
    if((I2C_TWSR_REG&0xF8)!=I2C_RSC_STATE)
 9ae:	e9 eb       	ldi	r30, 0xB9	; 185
 9b0:	f0 e0       	ldi	r31, 0x00	; 0
 9b2:	80 81       	ld	r24, Z
 9b4:	88 2f       	mov	r24, r24
 9b6:	90 e0       	ldi	r25, 0x00	; 0
 9b8:	88 7f       	andi	r24, 0xF8	; 248
 9ba:	90 70       	andi	r25, 0x00	; 0
 9bc:	80 31       	cpi	r24, 0x10	; 16
 9be:	91 05       	cpc	r25, r1
 9c0:	19 f0       	breq	.+6      	; 0x9c8 <I2C_enumReSendStartC+0x6c>
    {
        Local_enumErrorState = I2C_RSC_Error;
 9c2:	83 e0       	ldi	r24, 0x03	; 3
 9c4:	8b 83       	std	Y+3, r24	; 0x03
 9c6:	07 c0       	rjmp	.+14     	; 0x9d6 <I2C_enumReSendStartC+0x7a>
    }
    else
    {
        /*clear start cond*/
        CLR_BIT(I2C_TWCR_REG,5);
 9c8:	ac eb       	ldi	r26, 0xBC	; 188
 9ca:	b0 e0       	ldi	r27, 0x00	; 0
 9cc:	ec eb       	ldi	r30, 0xBC	; 188
 9ce:	f0 e0       	ldi	r31, 0x00	; 0
 9d0:	80 81       	ld	r24, Z
 9d2:	8f 7d       	andi	r24, 0xDF	; 223
 9d4:	8c 93       	st	X, r24
    }
    return Local_enumErrorState;
 9d6:	8b 81       	ldd	r24, Y+3	; 0x03
}
 9d8:	0f 90       	pop	r0
 9da:	0f 90       	pop	r0
 9dc:	0f 90       	pop	r0
 9de:	cf 91       	pop	r28
 9e0:	df 91       	pop	r29
 9e2:	08 95       	ret

000009e4 <I2C_enumSendSAWithWrite>:


I2C_ErrorState I2C_enumSendSAWithWrite(u8 Copy_u8SA)
{
 9e4:	df 93       	push	r29
 9e6:	cf 93       	push	r28
 9e8:	00 d0       	rcall	.+0      	; 0x9ea <I2C_enumSendSAWithWrite+0x6>
 9ea:	00 d0       	rcall	.+0      	; 0x9ec <I2C_enumSendSAWithWrite+0x8>
 9ec:	cd b7       	in	r28, 0x3d	; 61
 9ee:	de b7       	in	r29, 0x3e	; 62
 9f0:	8c 83       	std	Y+4, r24	; 0x04
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 9f2:	1b 82       	std	Y+3, r1	; 0x03
 9f4:	1a 82       	std	Y+2, r1	; 0x02
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 9f6:	81 e0       	ldi	r24, 0x01	; 1
 9f8:	89 83       	std	Y+1, r24	; 0x01
    /*check slave add within range*/
    if ((Copy_u8SA < 120)&& (Copy_u8SA >0))
 9fa:	8c 81       	ldd	r24, Y+4	; 0x04
 9fc:	88 37       	cpi	r24, 0x78	; 120
 9fe:	68 f5       	brcc	.+90     	; 0xa5a <I2C_enumSendSAWithWrite+0x76>
 a00:	8c 81       	ldd	r24, Y+4	; 0x04
 a02:	88 23       	and	r24, r24
 a04:	51 f1       	breq	.+84     	; 0xa5a <I2C_enumSendSAWithWrite+0x76>
    {
       /*set in TWDR = slave add + 0 */
        I2C_TWDR_REG = (Copy_u8SA<<1);
 a06:	eb eb       	ldi	r30, 0xBB	; 187
 a08:	f0 e0       	ldi	r31, 0x00	; 0
 a0a:	8c 81       	ldd	r24, Y+4	; 0x04
 a0c:	88 0f       	add	r24, r24
 a0e:	80 83       	st	Z, r24
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
 a10:	ac eb       	ldi	r26, 0xBC	; 188
 a12:	b0 e0       	ldi	r27, 0x00	; 0
 a14:	ec eb       	ldi	r30, 0xBC	; 188
 a16:	f0 e0       	ldi	r31, 0x00	; 0
 a18:	80 81       	ld	r24, Z
 a1a:	80 68       	ori	r24, 0x80	; 128
 a1c:	8c 93       	st	X, r24
 a1e:	05 c0       	rjmp	.+10     	; 0xa2a <I2C_enumSendSAWithWrite+0x46>
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
        {
            Local_u16CNT++;
 a20:	8a 81       	ldd	r24, Y+2	; 0x02
 a22:	9b 81       	ldd	r25, Y+3	; 0x03
 a24:	01 96       	adiw	r24, 0x01	; 1
 a26:	9b 83       	std	Y+3, r25	; 0x03
 a28:	8a 83       	std	Y+2, r24	; 0x02
       /*set in TWDR = slave add + 0 */
        I2C_TWDR_REG = (Copy_u8SA<<1);
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 a2a:	ec eb       	ldi	r30, 0xBC	; 188
 a2c:	f0 e0       	ldi	r31, 0x00	; 0
 a2e:	80 81       	ld	r24, Z
 a30:	88 23       	and	r24, r24
 a32:	34 f0       	brlt	.+12     	; 0xa40 <I2C_enumSendSAWithWrite+0x5c>
 a34:	8a 81       	ldd	r24, Y+2	; 0x02
 a36:	9b 81       	ldd	r25, Y+3	; 0x03
 a38:	23 e1       	ldi	r18, 0x13	; 19
 a3a:	88 38       	cpi	r24, 0x88	; 136
 a3c:	92 07       	cpc	r25, r18
 a3e:	80 f3       	brcs	.-32     	; 0xa20 <I2C_enumSendSAWithWrite+0x3c>
        {
            Local_u16CNT++;
        }
        /*check status code :SA + W*/
        if((I2C_TWSR_REG&0xF8)!=I2C_SLA_W_TRNS_ACK_STATE)
 a40:	e9 eb       	ldi	r30, 0xB9	; 185
 a42:	f0 e0       	ldi	r31, 0x00	; 0
 a44:	80 81       	ld	r24, Z
 a46:	88 2f       	mov	r24, r24
 a48:	90 e0       	ldi	r25, 0x00	; 0
 a4a:	88 7f       	andi	r24, 0xF8	; 248
 a4c:	90 70       	andi	r25, 0x00	; 0
 a4e:	88 31       	cpi	r24, 0x18	; 24
 a50:	91 05       	cpc	r25, r1
 a52:	29 f0       	breq	.+10     	; 0xa5e <I2C_enumSendSAWithWrite+0x7a>
        {
            Local_enumErrorState = I2C_SLA_W_Error;
 a54:	84 e0       	ldi	r24, 0x04	; 4
 a56:	89 83       	std	Y+1, r24	; 0x01
 a58:	02 c0       	rjmp	.+4      	; 0xa5e <I2C_enumSendSAWithWrite+0x7a>
        } 
    }
    else 
    {
        Local_enumErrorState = I2C_SLA_OOR_Error;
 a5a:	85 e0       	ldi	r24, 0x05	; 5
 a5c:	89 83       	std	Y+1, r24	; 0x01
    }
    return Local_enumErrorState;
 a5e:	89 81       	ldd	r24, Y+1	; 0x01

}
 a60:	0f 90       	pop	r0
 a62:	0f 90       	pop	r0
 a64:	0f 90       	pop	r0
 a66:	0f 90       	pop	r0
 a68:	cf 91       	pop	r28
 a6a:	df 91       	pop	r29
 a6c:	08 95       	ret

00000a6e <I2C_enumSendSAWithRead>:

I2C_ErrorState I2C_enumSendSAWithRead (u8 Copy_u8SA)
{
 a6e:	df 93       	push	r29
 a70:	cf 93       	push	r28
 a72:	00 d0       	rcall	.+0      	; 0xa74 <I2C_enumSendSAWithRead+0x6>
 a74:	00 d0       	rcall	.+0      	; 0xa76 <I2C_enumSendSAWithRead+0x8>
 a76:	cd b7       	in	r28, 0x3d	; 61
 a78:	de b7       	in	r29, 0x3e	; 62
 a7a:	8c 83       	std	Y+4, r24	; 0x04
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 a7c:	1b 82       	std	Y+3, r1	; 0x03
 a7e:	1a 82       	std	Y+2, r1	; 0x02
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 a80:	81 e0       	ldi	r24, 0x01	; 1
 a82:	89 83       	std	Y+1, r24	; 0x01
    /*check slave add within range*/
    if ((Copy_u8SA < 120)&& (Copy_u8SA >0))
 a84:	8c 81       	ldd	r24, Y+4	; 0x04
 a86:	88 37       	cpi	r24, 0x78	; 120
 a88:	a0 f5       	brcc	.+104    	; 0xaf2 <I2C_enumSendSAWithRead+0x84>
 a8a:	8c 81       	ldd	r24, Y+4	; 0x04
 a8c:	88 23       	and	r24, r24
 a8e:	89 f1       	breq	.+98     	; 0xaf2 <I2C_enumSendSAWithRead+0x84>
    {
       /*set in TWDR = slave add + 0 */
        I2C_TWDR_REG = (Copy_u8SA<<1);
 a90:	eb eb       	ldi	r30, 0xBB	; 187
 a92:	f0 e0       	ldi	r31, 0x00	; 0
 a94:	8c 81       	ldd	r24, Y+4	; 0x04
 a96:	88 0f       	add	r24, r24
 a98:	80 83       	st	Z, r24
        SET_BIT(I2C_TWDR_REG,0);
 a9a:	ab eb       	ldi	r26, 0xBB	; 187
 a9c:	b0 e0       	ldi	r27, 0x00	; 0
 a9e:	eb eb       	ldi	r30, 0xBB	; 187
 aa0:	f0 e0       	ldi	r31, 0x00	; 0
 aa2:	80 81       	ld	r24, Z
 aa4:	81 60       	ori	r24, 0x01	; 1
 aa6:	8c 93       	st	X, r24
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
 aa8:	ac eb       	ldi	r26, 0xBC	; 188
 aaa:	b0 e0       	ldi	r27, 0x00	; 0
 aac:	ec eb       	ldi	r30, 0xBC	; 188
 aae:	f0 e0       	ldi	r31, 0x00	; 0
 ab0:	80 81       	ld	r24, Z
 ab2:	80 68       	ori	r24, 0x80	; 128
 ab4:	8c 93       	st	X, r24
 ab6:	05 c0       	rjmp	.+10     	; 0xac2 <I2C_enumSendSAWithRead+0x54>
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
        {
            Local_u16CNT++;
 ab8:	8a 81       	ldd	r24, Y+2	; 0x02
 aba:	9b 81       	ldd	r25, Y+3	; 0x03
 abc:	01 96       	adiw	r24, 0x01	; 1
 abe:	9b 83       	std	Y+3, r25	; 0x03
 ac0:	8a 83       	std	Y+2, r24	; 0x02
        I2C_TWDR_REG = (Copy_u8SA<<1);
        SET_BIT(I2C_TWDR_REG,0);
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 ac2:	ec eb       	ldi	r30, 0xBC	; 188
 ac4:	f0 e0       	ldi	r31, 0x00	; 0
 ac6:	80 81       	ld	r24, Z
 ac8:	88 23       	and	r24, r24
 aca:	34 f0       	brlt	.+12     	; 0xad8 <I2C_enumSendSAWithRead+0x6a>
 acc:	8a 81       	ldd	r24, Y+2	; 0x02
 ace:	9b 81       	ldd	r25, Y+3	; 0x03
 ad0:	23 e1       	ldi	r18, 0x13	; 19
 ad2:	88 38       	cpi	r24, 0x88	; 136
 ad4:	92 07       	cpc	r25, r18
 ad6:	80 f3       	brcs	.-32     	; 0xab8 <I2C_enumSendSAWithRead+0x4a>
        {
            Local_u16CNT++;
        }
        /*check status code :SA + W*/
        if((I2C_TWSR_REG&0xF8)!=I2C_SLA_R_TRNS_ACK_STATE)
 ad8:	e9 eb       	ldi	r30, 0xB9	; 185
 ada:	f0 e0       	ldi	r31, 0x00	; 0
 adc:	80 81       	ld	r24, Z
 ade:	88 2f       	mov	r24, r24
 ae0:	90 e0       	ldi	r25, 0x00	; 0
 ae2:	88 7f       	andi	r24, 0xF8	; 248
 ae4:	90 70       	andi	r25, 0x00	; 0
 ae6:	80 34       	cpi	r24, 0x40	; 64
 ae8:	91 05       	cpc	r25, r1
 aea:	29 f0       	breq	.+10     	; 0xaf6 <I2C_enumSendSAWithRead+0x88>
        {
            Local_enumErrorState = I2C_SLA_R_Error;
 aec:	86 e0       	ldi	r24, 0x06	; 6
 aee:	89 83       	std	Y+1, r24	; 0x01
 af0:	02 c0       	rjmp	.+4      	; 0xaf6 <I2C_enumSendSAWithRead+0x88>
        } 
    }
    else 
    {
        Local_enumErrorState = I2C_SLA_OOR_Error;
 af2:	85 e0       	ldi	r24, 0x05	; 5
 af4:	89 83       	std	Y+1, r24	; 0x01
    }
    return Local_enumErrorState;
 af6:	89 81       	ldd	r24, Y+1	; 0x01

}
 af8:	0f 90       	pop	r0
 afa:	0f 90       	pop	r0
 afc:	0f 90       	pop	r0
 afe:	0f 90       	pop	r0
 b00:	cf 91       	pop	r28
 b02:	df 91       	pop	r29
 b04:	08 95       	ret

00000b06 <I2C_enumSendDByte>:

I2C_ErrorState I2C_enumSendDByte (u8 Copy_u8Data)
{
 b06:	df 93       	push	r29
 b08:	cf 93       	push	r28
 b0a:	00 d0       	rcall	.+0      	; 0xb0c <I2C_enumSendDByte+0x6>
 b0c:	00 d0       	rcall	.+0      	; 0xb0e <I2C_enumSendDByte+0x8>
 b0e:	cd b7       	in	r28, 0x3d	; 61
 b10:	de b7       	in	r29, 0x3e	; 62
 b12:	8c 83       	std	Y+4, r24	; 0x04
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 b14:	1b 82       	std	Y+3, r1	; 0x03
 b16:	1a 82       	std	Y+2, r1	; 0x02
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 b18:	81 e0       	ldi	r24, 0x01	; 1
 b1a:	89 83       	std	Y+1, r24	; 0x01
    /*set in TWDR = Data */
    I2C_TWDR_REG = (Copy_u8Data<<1);
 b1c:	eb eb       	ldi	r30, 0xBB	; 187
 b1e:	f0 e0       	ldi	r31, 0x00	; 0
 b20:	8c 81       	ldd	r24, Y+4	; 0x04
 b22:	88 0f       	add	r24, r24
 b24:	80 83       	st	Z, r24
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
 b26:	ac eb       	ldi	r26, 0xBC	; 188
 b28:	b0 e0       	ldi	r27, 0x00	; 0
 b2a:	ec eb       	ldi	r30, 0xBC	; 188
 b2c:	f0 e0       	ldi	r31, 0x00	; 0
 b2e:	80 81       	ld	r24, Z
 b30:	80 68       	ori	r24, 0x80	; 128
 b32:	8c 93       	st	X, r24
 b34:	05 c0       	rjmp	.+10     	; 0xb40 <I2C_enumSendDByte+0x3a>
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
    {
        Local_u16CNT++;
 b36:	8a 81       	ldd	r24, Y+2	; 0x02
 b38:	9b 81       	ldd	r25, Y+3	; 0x03
 b3a:	01 96       	adiw	r24, 0x01	; 1
 b3c:	9b 83       	std	Y+3, r25	; 0x03
 b3e:	8a 83       	std	Y+2, r24	; 0x02
    /*set in TWDR = Data */
    I2C_TWDR_REG = (Copy_u8Data<<1);
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
    /*wait for the flag*/
    while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 b40:	ec eb       	ldi	r30, 0xBC	; 188
 b42:	f0 e0       	ldi	r31, 0x00	; 0
 b44:	80 81       	ld	r24, Z
 b46:	88 23       	and	r24, r24
 b48:	34 f0       	brlt	.+12     	; 0xb56 <I2C_enumSendDByte+0x50>
 b4a:	8a 81       	ldd	r24, Y+2	; 0x02
 b4c:	9b 81       	ldd	r25, Y+3	; 0x03
 b4e:	23 e1       	ldi	r18, 0x13	; 19
 b50:	88 38       	cpi	r24, 0x88	; 136
 b52:	92 07       	cpc	r25, r18
 b54:	80 f3       	brcs	.-32     	; 0xb36 <I2C_enumSendDByte+0x30>
    {
        Local_u16CNT++;
    }
    /*check status code :SA + W*/
    if((I2C_TWSR_REG&0xF8)!= I2C_D_SENT_ACK_STATE)
 b56:	e9 eb       	ldi	r30, 0xB9	; 185
 b58:	f0 e0       	ldi	r31, 0x00	; 0
 b5a:	80 81       	ld	r24, Z
 b5c:	88 2f       	mov	r24, r24
 b5e:	90 e0       	ldi	r25, 0x00	; 0
 b60:	88 7f       	andi	r24, 0xF8	; 248
 b62:	90 70       	andi	r25, 0x00	; 0
 b64:	88 32       	cpi	r24, 0x28	; 40
 b66:	91 05       	cpc	r25, r1
 b68:	11 f0       	breq	.+4      	; 0xb6e <I2C_enumSendDByte+0x68>
    {
        Local_enumErrorState = I2C_D_SENT_Error;
 b6a:	87 e0       	ldi	r24, 0x07	; 7
 b6c:	89 83       	std	Y+1, r24	; 0x01
    } 
    return Local_enumErrorState;
 b6e:	89 81       	ldd	r24, Y+1	; 0x01
}
 b70:	0f 90       	pop	r0
 b72:	0f 90       	pop	r0
 b74:	0f 90       	pop	r0
 b76:	0f 90       	pop	r0
 b78:	cf 91       	pop	r28
 b7a:	df 91       	pop	r29
 b7c:	08 95       	ret

00000b7e <I2C_u8ReadDByte>:


u8 I2C_u8ReadDByte (u8 *Copy_u8Data)
{
 b7e:	df 93       	push	r29
 b80:	cf 93       	push	r28
 b82:	00 d0       	rcall	.+0      	; 0xb84 <I2C_u8ReadDByte+0x6>
 b84:	00 d0       	rcall	.+0      	; 0xb86 <I2C_u8ReadDByte+0x8>
 b86:	0f 92       	push	r0
 b88:	cd b7       	in	r28, 0x3d	; 61
 b8a:	de b7       	in	r29, 0x3e	; 62
 b8c:	9d 83       	std	Y+5, r25	; 0x05
 b8e:	8c 83       	std	Y+4, r24	; 0x04
    u16 Local_u16CNT = 0;/*counter for non blocking*/
 b90:	1b 82       	std	Y+3, r1	; 0x03
 b92:	1a 82       	std	Y+2, r1	; 0x02
    I2C_ErrorState Local_enumErrorState = I2C_ok;
 b94:	81 e0       	ldi	r24, 0x01	; 1
 b96:	89 83       	std	Y+1, r24	; 0x01
    /*check pointer*/
    if (Copy_u8Data == NULL)
 b98:	8c 81       	ldd	r24, Y+4	; 0x04
 b9a:	9d 81       	ldd	r25, Y+5	; 0x05
 b9c:	00 97       	sbiw	r24, 0x00	; 0
 b9e:	61 f5       	brne	.+88     	; 0xbf8 <I2C_u8ReadDByte+0x7a>
    {
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
 ba0:	ac eb       	ldi	r26, 0xBC	; 188
 ba2:	b0 e0       	ldi	r27, 0x00	; 0
 ba4:	ec eb       	ldi	r30, 0xBC	; 188
 ba6:	f0 e0       	ldi	r31, 0x00	; 0
 ba8:	80 81       	ld	r24, Z
 baa:	80 68       	ori	r24, 0x80	; 128
 bac:	8c 93       	st	X, r24
 bae:	05 c0       	rjmp	.+10     	; 0xbba <I2C_u8ReadDByte+0x3c>
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
        {
            Local_u16CNT++;
 bb0:	8a 81       	ldd	r24, Y+2	; 0x02
 bb2:	9b 81       	ldd	r25, Y+3	; 0x03
 bb4:	01 96       	adiw	r24, 0x01	; 1
 bb6:	9b 83       	std	Y+3, r25	; 0x03
 bb8:	8a 83       	std	Y+2, r24	; 0x02
    if (Copy_u8Data == NULL)
    {
        /*clear flag */
        SET_BIT(I2C_TWCR_REG,7);
        /*wait for the flag*/
        while(!(GET_BIT(I2C_TWCR_REG,7))&&(Local_u16CNT <5000))
 bba:	ec eb       	ldi	r30, 0xBC	; 188
 bbc:	f0 e0       	ldi	r31, 0x00	; 0
 bbe:	80 81       	ld	r24, Z
 bc0:	88 23       	and	r24, r24
 bc2:	34 f0       	brlt	.+12     	; 0xbd0 <I2C_u8ReadDByte+0x52>
 bc4:	8a 81       	ldd	r24, Y+2	; 0x02
 bc6:	9b 81       	ldd	r25, Y+3	; 0x03
 bc8:	23 e1       	ldi	r18, 0x13	; 19
 bca:	88 38       	cpi	r24, 0x88	; 136
 bcc:	92 07       	cpc	r25, r18
 bce:	80 f3       	brcs	.-32     	; 0xbb0 <I2C_u8ReadDByte+0x32>
        {
            Local_u16CNT++;
        }
        /* check Status code => Data  RECEIVE */
        if((I2C_TWSR_REG&0xF8)!= I2C_D_RECIVE_ACK_STATE)
 bd0:	e9 eb       	ldi	r30, 0xB9	; 185
 bd2:	f0 e0       	ldi	r31, 0x00	; 0
 bd4:	80 81       	ld	r24, Z
 bd6:	88 2f       	mov	r24, r24
 bd8:	90 e0       	ldi	r25, 0x00	; 0
 bda:	88 7f       	andi	r24, 0xF8	; 248
 bdc:	90 70       	andi	r25, 0x00	; 0
 bde:	80 35       	cpi	r24, 0x50	; 80
 be0:	91 05       	cpc	r25, r1
 be2:	19 f0       	breq	.+6      	; 0xbea <I2C_u8ReadDByte+0x6c>
        {
            Local_enumErrorState = I2C_D_RECEIVE_Error;
 be4:	88 e0       	ldi	r24, 0x08	; 8
 be6:	89 83       	std	Y+1, r24	; 0x01
 be8:	09 c0       	rjmp	.+18     	; 0xbfc <I2C_u8ReadDByte+0x7e>
        } 
        else
        {
            /*read data from TWDR*/
            *Copy_u8Data = I2C_TWDR_REG;
 bea:	eb eb       	ldi	r30, 0xBB	; 187
 bec:	f0 e0       	ldi	r31, 0x00	; 0
 bee:	80 81       	ld	r24, Z
 bf0:	ec 81       	ldd	r30, Y+4	; 0x04
 bf2:	fd 81       	ldd	r31, Y+5	; 0x05
 bf4:	80 83       	st	Z, r24
 bf6:	02 c0       	rjmp	.+4      	; 0xbfc <I2C_u8ReadDByte+0x7e>
        }
    
    }
    else
    {
        Local_enumErrorState = I2C_NULL_PTR_Error;
 bf8:	89 e0       	ldi	r24, 0x09	; 9
 bfa:	89 83       	std	Y+1, r24	; 0x01
    }
    return Local_enumErrorState;
 bfc:	89 81       	ldd	r24, Y+1	; 0x01
}
 bfe:	0f 90       	pop	r0
 c00:	0f 90       	pop	r0
 c02:	0f 90       	pop	r0
 c04:	0f 90       	pop	r0
 c06:	0f 90       	pop	r0
 c08:	cf 91       	pop	r28
 c0a:	df 91       	pop	r29
 c0c:	08 95       	ret

00000c0e <I2C_voidReSendStopC>:

void I2C_voidReSendStopC(void)
{
 c0e:	df 93       	push	r29
 c10:	cf 93       	push	r28
 c12:	cd b7       	in	r28, 0x3d	; 61
 c14:	de b7       	in	r29, 0x3e	; 62
    /*send stop condition*/
    SET_BIT(I2C_TWCR_REG,4);
 c16:	ac eb       	ldi	r26, 0xBC	; 188
 c18:	b0 e0       	ldi	r27, 0x00	; 0
 c1a:	ec eb       	ldi	r30, 0xBC	; 188
 c1c:	f0 e0       	ldi	r31, 0x00	; 0
 c1e:	80 81       	ld	r24, Z
 c20:	80 61       	ori	r24, 0x10	; 16
 c22:	8c 93       	st	X, r24
    /*clear flag */
    SET_BIT(I2C_TWCR_REG,7);
 c24:	ac eb       	ldi	r26, 0xBC	; 188
 c26:	b0 e0       	ldi	r27, 0x00	; 0
 c28:	ec eb       	ldi	r30, 0xBC	; 188
 c2a:	f0 e0       	ldi	r31, 0x00	; 0
 c2c:	80 81       	ld	r24, Z
 c2e:	80 68       	ori	r24, 0x80	; 128
 c30:	8c 93       	st	X, r24
 c32:	cf 91       	pop	r28
 c34:	df 91       	pop	r29
 c36:	08 95       	ret

00000c38 <main>:
#define LED_PORT		DIO_u8_PORTD



int main(void)
{
 c38:	df 93       	push	r29
 c3a:	cf 93       	push	r28
 c3c:	cd b7       	in	r28, 0x3d	; 61
 c3e:	de b7       	in	r29, 0x3e	; 62

	DIO_voidInit();
 c40:	0e 94 40 00 	call	0x80	; 0x80 <DIO_voidInit>
	I2C_voidMasterInit();
 c44:	0e 94 20 04 	call	0x840	; 0x840 <I2C_voidMasterInit>
 c48:	ff cf       	rjmp	.-2      	; 0xc48 <main+0x10>

00000c4a <_exit>:
 c4a:	f8 94       	cli

00000c4c <__stop_program>:
 c4c:	ff cf       	rjmp	.-2      	; 0xc4c <__stop_program>
