
RTOSapp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006638  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000076  00800060  00006638  000066cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000051c  008000d6  008000d6  00006742  2**0
                  ALLOC
  3 .stab         00008a0c  00000000  00000000  00006744  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000045b0  00000000  00000000  0000f150  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00013700  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00013860  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  000139ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00015a34  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00016b35  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00017ab8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00017c38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  00017efa  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00018788  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a6 12 	jmp	0x254c	; 0x254c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f6 e6       	ldi	r31, 0x66	; 102
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3d       	cpi	r26, 0xD6	; 214
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a6 ed       	ldi	r26, 0xD6	; 214
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 3f       	cpi	r26, 0xF2	; 242
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <main>
      8a:	0c 94 1a 33 	jmp	0x6634	; 0x6634 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 39 30 	jmp	0x6072	; 0x6072 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a2 ec       	ldi	r26, 0xC2	; 194
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 55 30 	jmp	0x60aa	; 0x60aa <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 45 30 	jmp	0x608a	; 0x608a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 61 30 	jmp	0x60c2	; 0x60c2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 45 30 	jmp	0x608a	; 0x608a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 61 30 	jmp	0x60c2	; 0x60c2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 39 30 	jmp	0x6072	; 0x6072 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	82 ec       	ldi	r24, 0xC2	; 194
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 55 30 	jmp	0x60aa	; 0x60aa <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 41 30 	jmp	0x6082	; 0x6082 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	62 ec       	ldi	r22, 0xC2	; 194
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 5d 30 	jmp	0x60ba	; 0x60ba <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 45 30 	jmp	0x608a	; 0x608a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 61 30 	jmp	0x60c2	; 0x60c2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 45 30 	jmp	0x608a	; 0x608a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 61 30 	jmp	0x60c2	; 0x60c2 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 45 30 	jmp	0x608a	; 0x608a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 61 30 	jmp	0x60c2	; 0x60c2 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 49 30 	jmp	0x6092	; 0x6092 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 65 30 	jmp	0x60ca	; 0x60ca <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     c9e:	af 92       	push	r10
     ca0:	bf 92       	push	r11
     ca2:	cf 92       	push	r12
     ca4:	df 92       	push	r13
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
     cac:	df 93       	push	r29
     cae:	cf 93       	push	r28
     cb0:	0f 92       	push	r0
     cb2:	cd b7       	in	r28, 0x3d	; 61
     cb4:	de b7       	in	r29, 0x3e	; 62
     cb6:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     cb8:	8a e0       	ldi	r24, 0x0A	; 10
     cba:	62 e0       	ldi	r22, 0x02	; 2
     cbc:	40 e0       	ldi	r20, 0x00	; 0
     cbe:	0e 94 2f 13 	call	0x265e	; 0x265e <xQueueGenericCreate>
     cc2:	90 93 d9 00 	sts	0x00D9, r25
     cc6:	80 93 d8 00 	sts	0x00D8, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     cca:	83 ed       	ldi	r24, 0xD3	; 211
     ccc:	96 e0       	ldi	r25, 0x06	; 6
     cce:	20 e6       	ldi	r18, 0x60	; 96
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	e8 ed       	ldi	r30, 0xD8	; 216
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	b9 01       	movw	r22, r18
     cd8:	45 e5       	ldi	r20, 0x55	; 85
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	9f 01       	movw	r18, r30
     cde:	09 81       	ldd	r16, Y+1	; 0x01
     ce0:	ee 24       	eor	r14, r14
     ce2:	ff 24       	eor	r15, r15
     ce4:	cc 24       	eor	r12, r12
     ce6:	dd 24       	eor	r13, r13
     ce8:	aa 24       	eor	r10, r10
     cea:	bb 24       	eor	r11, r11
     cec:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     cf0:	86 e9       	ldi	r24, 0x96	; 150
     cf2:	96 e0       	ldi	r25, 0x06	; 6
     cf4:	28 e6       	ldi	r18, 0x68	; 104
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	e8 ed       	ldi	r30, 0xD8	; 216
     cfa:	f0 e0       	ldi	r31, 0x00	; 0
     cfc:	b9 01       	movw	r22, r18
     cfe:	45 e5       	ldi	r20, 0x55	; 85
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	9f 01       	movw	r18, r30
     d04:	09 81       	ldd	r16, Y+1	; 0x01
     d06:	ee 24       	eor	r14, r14
     d08:	ff 24       	eor	r15, r15
     d0a:	cc 24       	eor	r12, r12
     d0c:	dd 24       	eor	r13, r13
     d0e:	aa 24       	eor	r10, r10
     d10:	bb 24       	eor	r11, r11
     d12:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>
}
     d16:	0f 90       	pop	r0
     d18:	cf 91       	pop	r28
     d1a:	df 91       	pop	r29
     d1c:	0f 91       	pop	r16
     d1e:	ff 90       	pop	r15
     d20:	ef 90       	pop	r14
     d22:	df 90       	pop	r13
     d24:	cf 90       	pop	r12
     d26:	bf 90       	pop	r11
     d28:	af 90       	pop	r10
     d2a:	08 95       	ret

00000d2c <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     d2c:	df 93       	push	r29
     d2e:	cf 93       	push	r28
     d30:	00 d0       	rcall	.+0      	; 0xd32 <vPolledQueueProducer+0x6>
     d32:	00 d0       	rcall	.+0      	; 0xd34 <vPolledQueueProducer+0x8>
     d34:	00 d0       	rcall	.+0      	; 0xd36 <vPolledQueueProducer+0xa>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	9e 83       	std	Y+6, r25	; 0x06
     d3c:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     d3e:	1c 82       	std	Y+4, r1	; 0x04
     d40:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     d42:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     d44:	19 82       	std	Y+1, r1	; 0x01
     d46:	27 c0       	rjmp	.+78     	; 0xd96 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     d48:	ed 81       	ldd	r30, Y+5	; 0x05
     d4a:	fe 81       	ldd	r31, Y+6	; 0x06
     d4c:	80 81       	ld	r24, Z
     d4e:	91 81       	ldd	r25, Z+1	; 0x01
     d50:	9e 01       	movw	r18, r28
     d52:	2d 5f       	subi	r18, 0xFD	; 253
     d54:	3f 4f       	sbci	r19, 0xFF	; 255
     d56:	b9 01       	movw	r22, r18
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	50 e0       	ldi	r21, 0x00	; 0
     d5c:	20 e0       	ldi	r18, 0x00	; 0
     d5e:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <xQueueGenericSend>
     d62:	81 30       	cpi	r24, 0x01	; 1
     d64:	19 f0       	breq	.+6      	; 0xd6c <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	8a 83       	std	Y+2, r24	; 0x02
     d6a:	12 c0       	rjmp	.+36     	; 0xd90 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     d6c:	8a 81       	ldd	r24, Y+2	; 0x02
     d6e:	88 23       	and	r24, r24
     d70:	51 f4       	brne	.+20     	; 0xd86 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	f8 94       	cli
     d76:	0f 92       	push	r0
						xPollingProducerCount++;
     d78:	80 91 d7 00 	lds	r24, 0x00D7
     d7c:	8f 5f       	subi	r24, 0xFF	; 255
     d7e:	80 93 d7 00 	sts	0x00D7, r24
					portEXIT_CRITICAL();
     d82:	0f 90       	pop	r0
     d84:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     d86:	8b 81       	ldd	r24, Y+3	; 0x03
     d88:	9c 81       	ldd	r25, Y+4	; 0x04
     d8a:	01 96       	adiw	r24, 0x01	; 1
     d8c:	9c 83       	std	Y+4, r25	; 0x04
     d8e:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     d90:	89 81       	ldd	r24, Y+1	; 0x01
     d92:	8f 5f       	subi	r24, 0xFF	; 255
     d94:	89 83       	std	Y+1, r24	; 0x01
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	83 30       	cpi	r24, 0x03	; 3
     d9a:	b4 f2       	brlt	.-84     	; 0xd48 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     d9c:	88 ec       	ldi	r24, 0xC8	; 200
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	0e 94 0f 1c 	call	0x381e	; 0x381e <vTaskDelay>
     da4:	cf cf       	rjmp	.-98     	; 0xd44 <vPolledQueueProducer+0x18>

00000da6 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     da6:	df 93       	push	r29
     da8:	cf 93       	push	r28
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	27 97       	sbiw	r28, 0x07	; 7
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	de bf       	out	0x3e, r29	; 62
     db6:	0f be       	out	0x3f, r0	; 63
     db8:	cd bf       	out	0x3d, r28	; 61
     dba:	9f 83       	std	Y+7, r25	; 0x07
     dbc:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     dbe:	1b 82       	std	Y+3, r1	; 0x03
     dc0:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     dc2:	19 82       	std	Y+1, r1	; 0x01
     dc4:	2f c0       	rjmp	.+94     	; 0xe24 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     dc6:	ee 81       	ldd	r30, Y+6	; 0x06
     dc8:	ff 81       	ldd	r31, Y+7	; 0x07
     dca:	80 81       	ld	r24, Z
     dcc:	91 81       	ldd	r25, Z+1	; 0x01
     dce:	9e 01       	movw	r18, r28
     dd0:	2c 5f       	subi	r18, 0xFC	; 252
     dd2:	3f 4f       	sbci	r19, 0xFF	; 255
     dd4:	b9 01       	movw	r22, r18
     dd6:	40 e0       	ldi	r20, 0x00	; 0
     dd8:	50 e0       	ldi	r21, 0x00	; 0
     dda:	20 e0       	ldi	r18, 0x00	; 0
     ddc:	0e 94 08 15 	call	0x2a10	; 0x2a10 <xQueueGenericReceive>
     de0:	81 30       	cpi	r24, 0x01	; 1
     de2:	01 f5       	brne	.+64     	; 0xe24 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     de4:	2c 81       	ldd	r18, Y+4	; 0x04
     de6:	3d 81       	ldd	r19, Y+5	; 0x05
     de8:	8a 81       	ldd	r24, Y+2	; 0x02
     dea:	9b 81       	ldd	r25, Y+3	; 0x03
     dec:	28 17       	cp	r18, r24
     dee:	39 07       	cpc	r19, r25
     df0:	39 f0       	breq	.+14     	; 0xe00 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     df2:	81 e0       	ldi	r24, 0x01	; 1
     df4:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     df6:	8c 81       	ldd	r24, Y+4	; 0x04
     df8:	9d 81       	ldd	r25, Y+5	; 0x05
     dfa:	9b 83       	std	Y+3, r25	; 0x03
     dfc:	8a 83       	std	Y+2, r24	; 0x02
     dfe:	0d c0       	rjmp	.+26     	; 0xe1a <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     e00:	89 81       	ldd	r24, Y+1	; 0x01
     e02:	88 23       	and	r24, r24
     e04:	51 f4       	brne	.+20     	; 0xe1a <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     e06:	0f b6       	in	r0, 0x3f	; 63
     e08:	f8 94       	cli
     e0a:	0f 92       	push	r0
							xPollingConsumerCount++;
     e0c:	80 91 d6 00 	lds	r24, 0x00D6
     e10:	8f 5f       	subi	r24, 0xFF	; 255
     e12:	80 93 d6 00 	sts	0x00D6, r24
						portEXIT_CRITICAL();
     e16:	0f 90       	pop	r0
     e18:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     e1a:	8a 81       	ldd	r24, Y+2	; 0x02
     e1c:	9b 81       	ldd	r25, Y+3	; 0x03
     e1e:	01 96       	adiw	r24, 0x01	; 1
     e20:	9b 83       	std	Y+3, r25	; 0x03
     e22:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     e24:	ee 81       	ldd	r30, Y+6	; 0x06
     e26:	ff 81       	ldd	r31, Y+7	; 0x07
     e28:	80 81       	ld	r24, Z
     e2a:	91 81       	ldd	r25, Z+1	; 0x01
     e2c:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <uxQueueMessagesWaiting>
     e30:	88 23       	and	r24, r24
     e32:	49 f6       	brne	.-110    	; 0xdc6 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     e34:	84 eb       	ldi	r24, 0xB4	; 180
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 0f 1c 	call	0x381e	; 0x381e <vTaskDelay>
     e3c:	f3 cf       	rjmp	.-26     	; 0xe24 <vPolledQueueConsumer+0x7e>

00000e3e <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     e3e:	df 93       	push	r29
     e40:	cf 93       	push	r28
     e42:	0f 92       	push	r0
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     e48:	80 91 d6 00 	lds	r24, 0x00D6
     e4c:	88 23       	and	r24, r24
     e4e:	21 f0       	breq	.+8      	; 0xe58 <xArePollingQueuesStillRunning+0x1a>
     e50:	80 91 d7 00 	lds	r24, 0x00D7
     e54:	88 23       	and	r24, r24
     e56:	11 f4       	brne	.+4      	; 0xe5c <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     e58:	19 82       	std	Y+1, r1	; 0x01
     e5a:	02 c0       	rjmp	.+4      	; 0xe60 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     e60:	10 92 d6 00 	sts	0x00D6, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     e64:	10 92 d7 00 	sts	0x00D7, r1

	return xReturn;
     e68:	89 81       	ldd	r24, Y+1	; 0x01
}
     e6a:	0f 90       	pop	r0
     e6c:	cf 91       	pop	r28
     e6e:	df 91       	pop	r29
     e70:	08 95       	ret

00000e72 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     e72:	df 93       	push	r29
     e74:	cf 93       	push	r28
     e76:	cd b7       	in	r28, 0x3d	; 61
     e78:	de b7       	in	r29, 0x3e	; 62
     e7a:	27 97       	sbiw	r28, 0x07	; 7
     e7c:	0f b6       	in	r0, 0x3f	; 63
     e7e:	f8 94       	cli
     e80:	de bf       	out	0x3e, r29	; 62
     e82:	0f be       	out	0x3f, r0	; 63
     e84:	cd bf       	out	0x3d, r28	; 61
     e86:	9d 83       	std	Y+5, r25	; 0x05
     e88:	8c 83       	std	Y+4, r24	; 0x04
     e8a:	6e 83       	std	Y+6, r22	; 0x06
     e8c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     e8e:	8a e1       	ldi	r24, 0x1A	; 26
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
     e96:	9a 83       	std	Y+2, r25	; 0x02
     e98:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     e9a:	89 81       	ldd	r24, Y+1	; 0x01
     e9c:	9a 81       	ldd	r25, Y+2	; 0x02
     e9e:	00 97       	sbiw	r24, 0x00	; 0
     ea0:	09 f4       	brne	.+2      	; 0xea4 <xCoRoutineCreate+0x32>
     ea2:	6f c0       	rjmp	.+222    	; 0xf82 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     ea4:	80 91 da 00 	lds	r24, 0x00DA
     ea8:	90 91 db 00 	lds	r25, 0x00DB
     eac:	00 97       	sbiw	r24, 0x00	; 0
     eae:	41 f4       	brne	.+16     	; 0xec0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
     eb2:	9a 81       	ldd	r25, Y+2	; 0x02
     eb4:	90 93 db 00 	sts	0x00DB, r25
     eb8:	80 93 da 00 	sts	0x00DA, r24
			prvInitialiseCoRoutineLists();
     ebc:	0e 94 a0 09 	call	0x1340	; 0x1340 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     ec0:	8e 81       	ldd	r24, Y+6	; 0x06
     ec2:	82 30       	cpi	r24, 0x02	; 2
     ec4:	10 f0       	brcs	.+4      	; 0xeca <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	11 8e       	std	Z+25, r1	; 0x19
     ed0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     ed2:	e9 81       	ldd	r30, Y+1	; 0x01
     ed4:	fa 81       	ldd	r31, Y+2	; 0x02
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     eda:	e9 81       	ldd	r30, Y+1	; 0x01
     edc:	fa 81       	ldd	r31, Y+2	; 0x02
     ede:	8f 81       	ldd	r24, Y+7	; 0x07
     ee0:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     ee2:	e9 81       	ldd	r30, Y+1	; 0x01
     ee4:	fa 81       	ldd	r31, Y+2	; 0x02
     ee6:	8c 81       	ldd	r24, Y+4	; 0x04
     ee8:	9d 81       	ldd	r25, Y+5	; 0x05
     eea:	91 83       	std	Z+1, r25	; 0x01
     eec:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     eee:	89 81       	ldd	r24, Y+1	; 0x01
     ef0:	9a 81       	ldd	r25, Y+2	; 0x02
     ef2:	02 96       	adiw	r24, 0x02	; 2
     ef4:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	9a 81       	ldd	r25, Y+2	; 0x02
     efc:	0c 96       	adiw	r24, 0x0c	; 12
     efe:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f02:	e9 81       	ldd	r30, Y+1	; 0x01
     f04:	fa 81       	ldd	r31, Y+2	; 0x02
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	9a 81       	ldd	r25, Y+2	; 0x02
     f0a:	91 87       	std	Z+9, r25	; 0x09
     f0c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f0e:	e9 81       	ldd	r30, Y+1	; 0x01
     f10:	fa 81       	ldd	r31, Y+2	; 0x02
     f12:	89 81       	ldd	r24, Y+1	; 0x01
     f14:	9a 81       	ldd	r25, Y+2	; 0x02
     f16:	93 8b       	std	Z+19, r25	; 0x13
     f18:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     f1a:	8e 81       	ldd	r24, Y+6	; 0x06
     f1c:	28 2f       	mov	r18, r24
     f1e:	30 e0       	ldi	r19, 0x00	; 0
     f20:	82 e0       	ldi	r24, 0x02	; 2
     f22:	90 e0       	ldi	r25, 0x00	; 0
     f24:	82 1b       	sub	r24, r18
     f26:	93 0b       	sbc	r25, r19
     f28:	e9 81       	ldd	r30, Y+1	; 0x01
     f2a:	fa 81       	ldd	r31, Y+2	; 0x02
     f2c:	95 87       	std	Z+13, r25	; 0x0d
     f2e:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f30:	e9 81       	ldd	r30, Y+1	; 0x01
     f32:	fa 81       	ldd	r31, Y+2	; 0x02
     f34:	96 89       	ldd	r25, Z+22	; 0x16
     f36:	80 91 dc 00 	lds	r24, 0x00DC
     f3a:	89 17       	cp	r24, r25
     f3c:	28 f4       	brcc	.+10     	; 0xf48 <xCoRoutineCreate+0xd6>
     f3e:	e9 81       	ldd	r30, Y+1	; 0x01
     f40:	fa 81       	ldd	r31, Y+2	; 0x02
     f42:	86 89       	ldd	r24, Z+22	; 0x16
     f44:	80 93 dc 00 	sts	0x00DC, r24
     f48:	e9 81       	ldd	r30, Y+1	; 0x01
     f4a:	fa 81       	ldd	r31, Y+2	; 0x02
     f4c:	86 89       	ldd	r24, Z+22	; 0x16
     f4e:	28 2f       	mov	r18, r24
     f50:	30 e0       	ldi	r19, 0x00	; 0
     f52:	c9 01       	movw	r24, r18
     f54:	88 0f       	add	r24, r24
     f56:	99 1f       	adc	r25, r25
     f58:	88 0f       	add	r24, r24
     f5a:	99 1f       	adc	r25, r25
     f5c:	88 0f       	add	r24, r24
     f5e:	99 1f       	adc	r25, r25
     f60:	82 0f       	add	r24, r18
     f62:	93 1f       	adc	r25, r19
     f64:	ac 01       	movw	r20, r24
     f66:	4d 51       	subi	r20, 0x1D	; 29
     f68:	5f 4f       	sbci	r21, 0xFF	; 255
     f6a:	89 81       	ldd	r24, Y+1	; 0x01
     f6c:	9a 81       	ldd	r25, Y+2	; 0x02
     f6e:	9c 01       	movw	r18, r24
     f70:	2e 5f       	subi	r18, 0xFE	; 254
     f72:	3f 4f       	sbci	r19, 0xFF	; 255
     f74:	ca 01       	movw	r24, r20
     f76:	b9 01       	movw	r22, r18
     f78:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

		xReturn = pdPASS;
     f7c:	81 e0       	ldi	r24, 0x01	; 1
     f7e:	8b 83       	std	Y+3, r24	; 0x03
     f80:	02 c0       	rjmp	.+4      	; 0xf86 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f82:	8f ef       	ldi	r24, 0xFF	; 255
     f84:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     f86:	8b 81       	ldd	r24, Y+3	; 0x03
}
     f88:	27 96       	adiw	r28, 0x07	; 7
     f8a:	0f b6       	in	r0, 0x3f	; 63
     f8c:	f8 94       	cli
     f8e:	de bf       	out	0x3e, r29	; 62
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	cd bf       	out	0x3d, r28	; 61
     f94:	cf 91       	pop	r28
     f96:	df 91       	pop	r29
     f98:	08 95       	ret

00000f9a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     f9a:	df 93       	push	r29
     f9c:	cf 93       	push	r28
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <vCoRoutineAddToDelayedList+0x6>
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <vCoRoutineAddToDelayedList+0x8>
     fa2:	00 d0       	rcall	.+0      	; 0xfa4 <vCoRoutineAddToDelayedList+0xa>
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	7e 83       	std	Y+6, r23	; 0x06
     fae:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     fb0:	20 91 dd 00 	lds	r18, 0x00DD
     fb4:	30 91 de 00 	lds	r19, 0x00DE
     fb8:	8b 81       	ldd	r24, Y+3	; 0x03
     fba:	9c 81       	ldd	r25, Y+4	; 0x04
     fbc:	82 0f       	add	r24, r18
     fbe:	93 1f       	adc	r25, r19
     fc0:	9a 83       	std	Y+2, r25	; 0x02
     fc2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fc4:	80 91 da 00 	lds	r24, 0x00DA
     fc8:	90 91 db 00 	lds	r25, 0x00DB
     fcc:	02 96       	adiw	r24, 0x02	; 2
     fce:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     fd2:	e0 91 da 00 	lds	r30, 0x00DA
     fd6:	f0 91 db 00 	lds	r31, 0x00DB
     fda:	89 81       	ldd	r24, Y+1	; 0x01
     fdc:	9a 81       	ldd	r25, Y+2	; 0x02
     fde:	93 83       	std	Z+3, r25	; 0x03
     fe0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     fe2:	20 91 dd 00 	lds	r18, 0x00DD
     fe6:	30 91 de 00 	lds	r19, 0x00DE
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	9a 81       	ldd	r25, Y+2	; 0x02
     fee:	82 17       	cp	r24, r18
     ff0:	93 07       	cpc	r25, r19
     ff2:	70 f4       	brcc	.+28     	; 0x1010 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ff4:	80 91 09 01 	lds	r24, 0x0109
     ff8:	90 91 0a 01 	lds	r25, 0x010A
     ffc:	20 91 da 00 	lds	r18, 0x00DA
    1000:	30 91 db 00 	lds	r19, 0x00DB
    1004:	2e 5f       	subi	r18, 0xFE	; 254
    1006:	3f 4f       	sbci	r19, 0xFF	; 255
    1008:	b9 01       	movw	r22, r18
    100a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>
    100e:	0d c0       	rjmp	.+26     	; 0x102a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1010:	80 91 07 01 	lds	r24, 0x0107
    1014:	90 91 08 01 	lds	r25, 0x0108
    1018:	20 91 da 00 	lds	r18, 0x00DA
    101c:	30 91 db 00 	lds	r19, 0x00DB
    1020:	2e 5f       	subi	r18, 0xFE	; 254
    1022:	3f 4f       	sbci	r19, 0xFF	; 255
    1024:	b9 01       	movw	r22, r18
    1026:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>
	}

	if( pxEventList )
    102a:	8d 81       	ldd	r24, Y+5	; 0x05
    102c:	9e 81       	ldd	r25, Y+6	; 0x06
    102e:	00 97       	sbiw	r24, 0x00	; 0
    1030:	61 f0       	breq	.+24     	; 0x104a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1032:	80 91 da 00 	lds	r24, 0x00DA
    1036:	90 91 db 00 	lds	r25, 0x00DB
    103a:	9c 01       	movw	r18, r24
    103c:	24 5f       	subi	r18, 0xF4	; 244
    103e:	3f 4f       	sbci	r19, 0xFF	; 255
    1040:	8d 81       	ldd	r24, Y+5	; 0x05
    1042:	9e 81       	ldd	r25, Y+6	; 0x06
    1044:	b9 01       	movw	r22, r18
    1046:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>
	}
}
    104a:	26 96       	adiw	r28, 0x06	; 6
    104c:	0f b6       	in	r0, 0x3f	; 63
    104e:	f8 94       	cli
    1050:	de bf       	out	0x3e, r29	; 62
    1052:	0f be       	out	0x3f, r0	; 63
    1054:	cd bf       	out	0x3d, r28	; 61
    1056:	cf 91       	pop	r28
    1058:	df 91       	pop	r29
    105a:	08 95       	ret

0000105c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    105c:	df 93       	push	r29
    105e:	cf 93       	push	r28
    1060:	00 d0       	rcall	.+0      	; 0x1062 <prvCheckPendingReadyList+0x6>
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
    1066:	3a c0       	rjmp	.+116    	; 0x10dc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1068:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    106a:	e0 91 10 01 	lds	r30, 0x0110
    106e:	f0 91 11 01 	lds	r31, 0x0111
    1072:	86 81       	ldd	r24, Z+6	; 0x06
    1074:	97 81       	ldd	r25, Z+7	; 0x07
    1076:	9a 83       	std	Y+2, r25	; 0x02
    1078:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    107a:	89 81       	ldd	r24, Y+1	; 0x01
    107c:	9a 81       	ldd	r25, Y+2	; 0x02
    107e:	0c 96       	adiw	r24, 0x0c	; 12
    1080:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1084:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	9a 81       	ldd	r25, Y+2	; 0x02
    108a:	02 96       	adiw	r24, 0x02	; 2
    108c:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	96 89       	ldd	r25, Z+22	; 0x16
    1096:	80 91 dc 00 	lds	r24, 0x00DC
    109a:	89 17       	cp	r24, r25
    109c:	28 f4       	brcc	.+10     	; 0x10a8 <prvCheckPendingReadyList+0x4c>
    109e:	e9 81       	ldd	r30, Y+1	; 0x01
    10a0:	fa 81       	ldd	r31, Y+2	; 0x02
    10a2:	86 89       	ldd	r24, Z+22	; 0x16
    10a4:	80 93 dc 00 	sts	0x00DC, r24
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	86 89       	ldd	r24, Z+22	; 0x16
    10ae:	28 2f       	mov	r18, r24
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	c9 01       	movw	r24, r18
    10b4:	88 0f       	add	r24, r24
    10b6:	99 1f       	adc	r25, r25
    10b8:	88 0f       	add	r24, r24
    10ba:	99 1f       	adc	r25, r25
    10bc:	88 0f       	add	r24, r24
    10be:	99 1f       	adc	r25, r25
    10c0:	82 0f       	add	r24, r18
    10c2:	93 1f       	adc	r25, r19
    10c4:	ac 01       	movw	r20, r24
    10c6:	4d 51       	subi	r20, 0x1D	; 29
    10c8:	5f 4f       	sbci	r21, 0xFF	; 255
    10ca:	89 81       	ldd	r24, Y+1	; 0x01
    10cc:	9a 81       	ldd	r25, Y+2	; 0x02
    10ce:	9c 01       	movw	r18, r24
    10d0:	2e 5f       	subi	r18, 0xFE	; 254
    10d2:	3f 4f       	sbci	r19, 0xFF	; 255
    10d4:	ca 01       	movw	r24, r20
    10d6:	b9 01       	movw	r22, r18
    10d8:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    10dc:	80 91 0b 01 	lds	r24, 0x010B
    10e0:	88 23       	and	r24, r24
    10e2:	09 f0       	breq	.+2      	; 0x10e6 <prvCheckPendingReadyList+0x8a>
    10e4:	c1 cf       	rjmp	.-126    	; 0x1068 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	cf 91       	pop	r28
    10ec:	df 91       	pop	r29
    10ee:	08 95       	ret

000010f0 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    10f0:	df 93       	push	r29
    10f2:	cf 93       	push	r28
    10f4:	00 d0       	rcall	.+0      	; 0x10f6 <prvCheckDelayedList+0x6>
    10f6:	00 d0       	rcall	.+0      	; 0x10f8 <prvCheckDelayedList+0x8>
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    10fc:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <xTaskGetTickCount>
    1100:	20 91 df 00 	lds	r18, 0x00DF
    1104:	30 91 e0 00 	lds	r19, 0x00E0
    1108:	82 1b       	sub	r24, r18
    110a:	93 0b       	sbc	r25, r19
    110c:	90 93 e2 00 	sts	0x00E2, r25
    1110:	80 93 e1 00 	sts	0x00E1, r24
    1114:	85 c0       	rjmp	.+266    	; 0x1220 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1116:	80 91 dd 00 	lds	r24, 0x00DD
    111a:	90 91 de 00 	lds	r25, 0x00DE
    111e:	01 96       	adiw	r24, 0x01	; 1
    1120:	90 93 de 00 	sts	0x00DE, r25
    1124:	80 93 dd 00 	sts	0x00DD, r24
		xPassedTicks--;
    1128:	80 91 e1 00 	lds	r24, 0x00E1
    112c:	90 91 e2 00 	lds	r25, 0x00E2
    1130:	01 97       	sbiw	r24, 0x01	; 1
    1132:	90 93 e2 00 	sts	0x00E2, r25
    1136:	80 93 e1 00 	sts	0x00E1, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    113a:	80 91 dd 00 	lds	r24, 0x00DD
    113e:	90 91 de 00 	lds	r25, 0x00DE
    1142:	00 97       	sbiw	r24, 0x00	; 0
    1144:	09 f0       	breq	.+2      	; 0x1148 <prvCheckDelayedList+0x58>
    1146:	64 c0       	rjmp	.+200    	; 0x1210 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1148:	80 91 07 01 	lds	r24, 0x0107
    114c:	90 91 08 01 	lds	r25, 0x0108
    1150:	9a 83       	std	Y+2, r25	; 0x02
    1152:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1154:	80 91 09 01 	lds	r24, 0x0109
    1158:	90 91 0a 01 	lds	r25, 0x010A
    115c:	90 93 08 01 	sts	0x0108, r25
    1160:	80 93 07 01 	sts	0x0107, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1164:	89 81       	ldd	r24, Y+1	; 0x01
    1166:	9a 81       	ldd	r25, Y+2	; 0x02
    1168:	90 93 0a 01 	sts	0x010A, r25
    116c:	80 93 09 01 	sts	0x0109, r24
    1170:	4f c0       	rjmp	.+158    	; 0x1210 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1172:	e0 91 07 01 	lds	r30, 0x0107
    1176:	f0 91 08 01 	lds	r31, 0x0108
    117a:	05 80       	ldd	r0, Z+5	; 0x05
    117c:	f6 81       	ldd	r31, Z+6	; 0x06
    117e:	e0 2d       	mov	r30, r0
    1180:	86 81       	ldd	r24, Z+6	; 0x06
    1182:	97 81       	ldd	r25, Z+7	; 0x07
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1188:	eb 81       	ldd	r30, Y+3	; 0x03
    118a:	fc 81       	ldd	r31, Y+4	; 0x04
    118c:	22 81       	ldd	r18, Z+2	; 0x02
    118e:	33 81       	ldd	r19, Z+3	; 0x03
    1190:	80 91 dd 00 	lds	r24, 0x00DD
    1194:	90 91 de 00 	lds	r25, 0x00DE
    1198:	82 17       	cp	r24, r18
    119a:	93 07       	cpc	r25, r19
    119c:	08 f4       	brcc	.+2      	; 0x11a0 <prvCheckDelayedList+0xb0>
    119e:	40 c0       	rjmp	.+128    	; 0x1220 <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    11a0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    11a2:	8b 81       	ldd	r24, Y+3	; 0x03
    11a4:	9c 81       	ldd	r25, Y+4	; 0x04
    11a6:	02 96       	adiw	r24, 0x02	; 2
    11a8:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    11ac:	eb 81       	ldd	r30, Y+3	; 0x03
    11ae:	fc 81       	ldd	r31, Y+4	; 0x04
    11b0:	84 89       	ldd	r24, Z+20	; 0x14
    11b2:	95 89       	ldd	r25, Z+21	; 0x15
    11b4:	00 97       	sbiw	r24, 0x00	; 0
    11b6:	29 f0       	breq	.+10     	; 0x11c2 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    11b8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ba:	9c 81       	ldd	r25, Y+4	; 0x04
    11bc:	0c 96       	adiw	r24, 0x0c	; 12
    11be:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    11c2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    11c4:	eb 81       	ldd	r30, Y+3	; 0x03
    11c6:	fc 81       	ldd	r31, Y+4	; 0x04
    11c8:	96 89       	ldd	r25, Z+22	; 0x16
    11ca:	80 91 dc 00 	lds	r24, 0x00DC
    11ce:	89 17       	cp	r24, r25
    11d0:	28 f4       	brcc	.+10     	; 0x11dc <prvCheckDelayedList+0xec>
    11d2:	eb 81       	ldd	r30, Y+3	; 0x03
    11d4:	fc 81       	ldd	r31, Y+4	; 0x04
    11d6:	86 89       	ldd	r24, Z+22	; 0x16
    11d8:	80 93 dc 00 	sts	0x00DC, r24
    11dc:	eb 81       	ldd	r30, Y+3	; 0x03
    11de:	fc 81       	ldd	r31, Y+4	; 0x04
    11e0:	86 89       	ldd	r24, Z+22	; 0x16
    11e2:	28 2f       	mov	r18, r24
    11e4:	30 e0       	ldi	r19, 0x00	; 0
    11e6:	c9 01       	movw	r24, r18
    11e8:	88 0f       	add	r24, r24
    11ea:	99 1f       	adc	r25, r25
    11ec:	88 0f       	add	r24, r24
    11ee:	99 1f       	adc	r25, r25
    11f0:	88 0f       	add	r24, r24
    11f2:	99 1f       	adc	r25, r25
    11f4:	82 0f       	add	r24, r18
    11f6:	93 1f       	adc	r25, r19
    11f8:	ac 01       	movw	r20, r24
    11fa:	4d 51       	subi	r20, 0x1D	; 29
    11fc:	5f 4f       	sbci	r21, 0xFF	; 255
    11fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1200:	9c 81       	ldd	r25, Y+4	; 0x04
    1202:	9c 01       	movw	r18, r24
    1204:	2e 5f       	subi	r18, 0xFE	; 254
    1206:	3f 4f       	sbci	r19, 0xFF	; 255
    1208:	ca 01       	movw	r24, r20
    120a:	b9 01       	movw	r22, r18
    120c:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1210:	e0 91 07 01 	lds	r30, 0x0107
    1214:	f0 91 08 01 	lds	r31, 0x0108
    1218:	80 81       	ld	r24, Z
    121a:	88 23       	and	r24, r24
    121c:	09 f0       	breq	.+2      	; 0x1220 <prvCheckDelayedList+0x130>
    121e:	a9 cf       	rjmp	.-174    	; 0x1172 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1220:	80 91 e1 00 	lds	r24, 0x00E1
    1224:	90 91 e2 00 	lds	r25, 0x00E2
    1228:	00 97       	sbiw	r24, 0x00	; 0
    122a:	09 f0       	breq	.+2      	; 0x122e <prvCheckDelayedList+0x13e>
    122c:	74 cf       	rjmp	.-280    	; 0x1116 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    122e:	80 91 dd 00 	lds	r24, 0x00DD
    1232:	90 91 de 00 	lds	r25, 0x00DE
    1236:	90 93 e0 00 	sts	0x00E0, r25
    123a:	80 93 df 00 	sts	0x00DF, r24
}
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	cf 91       	pop	r28
    1248:	df 91       	pop	r29
    124a:	08 95       	ret

0000124c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    124c:	df 93       	push	r29
    124e:	cf 93       	push	r28
    1250:	00 d0       	rcall	.+0      	; 0x1252 <vCoRoutineSchedule+0x6>
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1256:	0e 94 2e 08 	call	0x105c	; 0x105c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    125a:	0e 94 78 08 	call	0x10f0	; 0x10f0 <prvCheckDelayedList>
    125e:	0a c0       	rjmp	.+20     	; 0x1274 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1260:	80 91 dc 00 	lds	r24, 0x00DC
    1264:	88 23       	and	r24, r24
    1266:	09 f4       	brne	.+2      	; 0x126a <vCoRoutineSchedule+0x1e>
    1268:	66 c0       	rjmp	.+204    	; 0x1336 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    126a:	80 91 dc 00 	lds	r24, 0x00DC
    126e:	81 50       	subi	r24, 0x01	; 1
    1270:	80 93 dc 00 	sts	0x00DC, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1274:	80 91 dc 00 	lds	r24, 0x00DC
    1278:	28 2f       	mov	r18, r24
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	c9 01       	movw	r24, r18
    127e:	88 0f       	add	r24, r24
    1280:	99 1f       	adc	r25, r25
    1282:	88 0f       	add	r24, r24
    1284:	99 1f       	adc	r25, r25
    1286:	88 0f       	add	r24, r24
    1288:	99 1f       	adc	r25, r25
    128a:	82 0f       	add	r24, r18
    128c:	93 1f       	adc	r25, r19
    128e:	fc 01       	movw	r30, r24
    1290:	ed 51       	subi	r30, 0x1D	; 29
    1292:	ff 4f       	sbci	r31, 0xFF	; 255
    1294:	80 81       	ld	r24, Z
    1296:	88 23       	and	r24, r24
    1298:	19 f3       	breq	.-58     	; 0x1260 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    129a:	80 91 dc 00 	lds	r24, 0x00DC
    129e:	28 2f       	mov	r18, r24
    12a0:	30 e0       	ldi	r19, 0x00	; 0
    12a2:	c9 01       	movw	r24, r18
    12a4:	88 0f       	add	r24, r24
    12a6:	99 1f       	adc	r25, r25
    12a8:	88 0f       	add	r24, r24
    12aa:	99 1f       	adc	r25, r25
    12ac:	88 0f       	add	r24, r24
    12ae:	99 1f       	adc	r25, r25
    12b0:	82 0f       	add	r24, r18
    12b2:	93 1f       	adc	r25, r19
    12b4:	8d 51       	subi	r24, 0x1D	; 29
    12b6:	9f 4f       	sbci	r25, 0xFF	; 255
    12b8:	9a 83       	std	Y+2, r25	; 0x02
    12ba:	89 83       	std	Y+1, r24	; 0x01
    12bc:	e9 81       	ldd	r30, Y+1	; 0x01
    12be:	fa 81       	ldd	r31, Y+2	; 0x02
    12c0:	01 80       	ldd	r0, Z+1	; 0x01
    12c2:	f2 81       	ldd	r31, Z+2	; 0x02
    12c4:	e0 2d       	mov	r30, r0
    12c6:	82 81       	ldd	r24, Z+2	; 0x02
    12c8:	93 81       	ldd	r25, Z+3	; 0x03
    12ca:	e9 81       	ldd	r30, Y+1	; 0x01
    12cc:	fa 81       	ldd	r31, Y+2	; 0x02
    12ce:	92 83       	std	Z+2, r25	; 0x02
    12d0:	81 83       	std	Z+1, r24	; 0x01
    12d2:	e9 81       	ldd	r30, Y+1	; 0x01
    12d4:	fa 81       	ldd	r31, Y+2	; 0x02
    12d6:	21 81       	ldd	r18, Z+1	; 0x01
    12d8:	32 81       	ldd	r19, Z+2	; 0x02
    12da:	89 81       	ldd	r24, Y+1	; 0x01
    12dc:	9a 81       	ldd	r25, Y+2	; 0x02
    12de:	03 96       	adiw	r24, 0x03	; 3
    12e0:	28 17       	cp	r18, r24
    12e2:	39 07       	cpc	r19, r25
    12e4:	59 f4       	brne	.+22     	; 0x12fc <vCoRoutineSchedule+0xb0>
    12e6:	e9 81       	ldd	r30, Y+1	; 0x01
    12e8:	fa 81       	ldd	r31, Y+2	; 0x02
    12ea:	01 80       	ldd	r0, Z+1	; 0x01
    12ec:	f2 81       	ldd	r31, Z+2	; 0x02
    12ee:	e0 2d       	mov	r30, r0
    12f0:	82 81       	ldd	r24, Z+2	; 0x02
    12f2:	93 81       	ldd	r25, Z+3	; 0x03
    12f4:	e9 81       	ldd	r30, Y+1	; 0x01
    12f6:	fa 81       	ldd	r31, Y+2	; 0x02
    12f8:	92 83       	std	Z+2, r25	; 0x02
    12fa:	81 83       	std	Z+1, r24	; 0x01
    12fc:	e9 81       	ldd	r30, Y+1	; 0x01
    12fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1300:	01 80       	ldd	r0, Z+1	; 0x01
    1302:	f2 81       	ldd	r31, Z+2	; 0x02
    1304:	e0 2d       	mov	r30, r0
    1306:	86 81       	ldd	r24, Z+6	; 0x06
    1308:	97 81       	ldd	r25, Z+7	; 0x07
    130a:	90 93 db 00 	sts	0x00DB, r25
    130e:	80 93 da 00 	sts	0x00DA, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1312:	e0 91 da 00 	lds	r30, 0x00DA
    1316:	f0 91 db 00 	lds	r31, 0x00DB
    131a:	40 81       	ld	r20, Z
    131c:	51 81       	ldd	r21, Z+1	; 0x01
    131e:	80 91 da 00 	lds	r24, 0x00DA
    1322:	90 91 db 00 	lds	r25, 0x00DB
    1326:	e0 91 da 00 	lds	r30, 0x00DA
    132a:	f0 91 db 00 	lds	r31, 0x00DB
    132e:	27 89       	ldd	r18, Z+23	; 0x17
    1330:	62 2f       	mov	r22, r18
    1332:	fa 01       	movw	r30, r20
    1334:	09 95       	icall

	return;
}
    1336:	0f 90       	pop	r0
    1338:	0f 90       	pop	r0
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	08 95       	ret

00001340 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1340:	df 93       	push	r29
    1342:	cf 93       	push	r28
    1344:	0f 92       	push	r0
    1346:	cd b7       	in	r28, 0x3d	; 61
    1348:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    134a:	19 82       	std	Y+1, r1	; 0x01
    134c:	13 c0       	rjmp	.+38     	; 0x1374 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	28 2f       	mov	r18, r24
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	c9 01       	movw	r24, r18
    1356:	88 0f       	add	r24, r24
    1358:	99 1f       	adc	r25, r25
    135a:	88 0f       	add	r24, r24
    135c:	99 1f       	adc	r25, r25
    135e:	88 0f       	add	r24, r24
    1360:	99 1f       	adc	r25, r25
    1362:	82 0f       	add	r24, r18
    1364:	93 1f       	adc	r25, r19
    1366:	8d 51       	subi	r24, 0x1D	; 29
    1368:	9f 4f       	sbci	r25, 0xFF	; 255
    136a:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    136e:	89 81       	ldd	r24, Y+1	; 0x01
    1370:	8f 5f       	subi	r24, 0xFF	; 255
    1372:	89 83       	std	Y+1, r24	; 0x01
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	82 30       	cpi	r24, 0x02	; 2
    1378:	50 f3       	brcs	.-44     	; 0x134e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    137a:	85 ef       	ldi	r24, 0xF5	; 245
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1382:	8e ef       	ldi	r24, 0xFE	; 254
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    138a:	8b e0       	ldi	r24, 0x0B	; 11
    138c:	91 e0       	ldi	r25, 0x01	; 1
    138e:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1392:	85 ef       	ldi	r24, 0xF5	; 245
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	90 93 08 01 	sts	0x0108, r25
    139a:	80 93 07 01 	sts	0x0107, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    139e:	8e ef       	ldi	r24, 0xFE	; 254
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	90 93 0a 01 	sts	0x010A, r25
    13a6:	80 93 09 01 	sts	0x0109, r24
}
    13aa:	0f 90       	pop	r0
    13ac:	cf 91       	pop	r28
    13ae:	df 91       	pop	r29
    13b0:	08 95       	ret

000013b2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    13b2:	df 93       	push	r29
    13b4:	cf 93       	push	r28
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <xCoRoutineRemoveFromEventList+0x6>
    13b8:	00 d0       	rcall	.+0      	; 0x13ba <xCoRoutineRemoveFromEventList+0x8>
    13ba:	0f 92       	push	r0
    13bc:	cd b7       	in	r28, 0x3d	; 61
    13be:	de b7       	in	r29, 0x3e	; 62
    13c0:	9d 83       	std	Y+5, r25	; 0x05
    13c2:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    13c4:	ec 81       	ldd	r30, Y+4	; 0x04
    13c6:	fd 81       	ldd	r31, Y+5	; 0x05
    13c8:	05 80       	ldd	r0, Z+5	; 0x05
    13ca:	f6 81       	ldd	r31, Z+6	; 0x06
    13cc:	e0 2d       	mov	r30, r0
    13ce:	86 81       	ldd	r24, Z+6	; 0x06
    13d0:	97 81       	ldd	r25, Z+7	; 0x07
    13d2:	9b 83       	std	Y+3, r25	; 0x03
    13d4:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    13d6:	8a 81       	ldd	r24, Y+2	; 0x02
    13d8:	9b 81       	ldd	r25, Y+3	; 0x03
    13da:	0c 96       	adiw	r24, 0x0c	; 12
    13dc:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    13e0:	8a 81       	ldd	r24, Y+2	; 0x02
    13e2:	9b 81       	ldd	r25, Y+3	; 0x03
    13e4:	9c 01       	movw	r18, r24
    13e6:	24 5f       	subi	r18, 0xF4	; 244
    13e8:	3f 4f       	sbci	r19, 0xFF	; 255
    13ea:	8b e0       	ldi	r24, 0x0B	; 11
    13ec:	91 e0       	ldi	r25, 0x01	; 1
    13ee:	b9 01       	movw	r22, r18
    13f0:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    13f4:	ea 81       	ldd	r30, Y+2	; 0x02
    13f6:	fb 81       	ldd	r31, Y+3	; 0x03
    13f8:	96 89       	ldd	r25, Z+22	; 0x16
    13fa:	e0 91 da 00 	lds	r30, 0x00DA
    13fe:	f0 91 db 00 	lds	r31, 0x00DB
    1402:	86 89       	ldd	r24, Z+22	; 0x16
    1404:	98 17       	cp	r25, r24
    1406:	18 f0       	brcs	.+6      	; 0x140e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    1408:	81 e0       	ldi	r24, 0x01	; 1
    140a:	89 83       	std	Y+1, r24	; 0x01
    140c:	01 c0       	rjmp	.+2      	; 0x1410 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    140e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1410:	89 81       	ldd	r24, Y+1	; 0x01
}
    1412:	0f 90       	pop	r0
    1414:	0f 90       	pop	r0
    1416:	0f 90       	pop	r0
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	cf 91       	pop	r28
    141e:	df 91       	pop	r29
    1420:	08 95       	ret

00001422 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    1422:	df 93       	push	r29
    1424:	cf 93       	push	r28
    1426:	00 d0       	rcall	.+0      	; 0x1428 <xEventGroupCreate+0x6>
    1428:	cd b7       	in	r28, 0x3d	; 61
    142a:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    142c:	8b e0       	ldi	r24, 0x0B	; 11
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    1434:	9a 83       	std	Y+2, r25	; 0x02
    1436:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    1438:	89 81       	ldd	r24, Y+1	; 0x01
    143a:	9a 81       	ldd	r25, Y+2	; 0x02
    143c:	00 97       	sbiw	r24, 0x00	; 0
    143e:	49 f0       	breq	.+18     	; 0x1452 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    1440:	e9 81       	ldd	r30, Y+1	; 0x01
    1442:	fa 81       	ldd	r31, Y+2	; 0x02
    1444:	11 82       	std	Z+1, r1	; 0x01
    1446:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	9a 81       	ldd	r25, Y+2	; 0x02
    144c:	02 96       	adiw	r24, 0x02	; 2
    144e:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    1452:	89 81       	ldd	r24, Y+1	; 0x01
    1454:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	cf 91       	pop	r28
    145c:	df 91       	pop	r29
    145e:	08 95       	ret

00001460 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1460:	df 93       	push	r29
    1462:	cf 93       	push	r28
    1464:	cd b7       	in	r28, 0x3d	; 61
    1466:	de b7       	in	r29, 0x3e	; 62
    1468:	60 97       	sbiw	r28, 0x10	; 16
    146a:	0f b6       	in	r0, 0x3f	; 63
    146c:	f8 94       	cli
    146e:	de bf       	out	0x3e, r29	; 62
    1470:	0f be       	out	0x3f, r0	; 63
    1472:	cd bf       	out	0x3d, r28	; 61
    1474:	9a 87       	std	Y+10, r25	; 0x0a
    1476:	89 87       	std	Y+9, r24	; 0x09
    1478:	7c 87       	std	Y+12, r23	; 0x0c
    147a:	6b 87       	std	Y+11, r22	; 0x0b
    147c:	5e 87       	std	Y+14, r21	; 0x0e
    147e:	4d 87       	std	Y+13, r20	; 0x0d
    1480:	38 8b       	std	Y+16, r19	; 0x10
    1482:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1484:	89 85       	ldd	r24, Y+9	; 0x09
    1486:	9a 85       	ldd	r25, Y+10	; 0x0a
    1488:	9c 83       	std	Y+4, r25	; 0x04
    148a:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    148c:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    148e:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1492:	eb 81       	ldd	r30, Y+3	; 0x03
    1494:	fc 81       	ldd	r31, Y+4	; 0x04
    1496:	80 81       	ld	r24, Z
    1498:	91 81       	ldd	r25, Z+1	; 0x01
    149a:	98 87       	std	Y+8, r25	; 0x08
    149c:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    149e:	89 85       	ldd	r24, Y+9	; 0x09
    14a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    14a2:	2b 85       	ldd	r18, Y+11	; 0x0b
    14a4:	3c 85       	ldd	r19, Y+12	; 0x0c
    14a6:	b9 01       	movw	r22, r18
    14a8:	0e 94 02 0c 	call	0x1804	; 0x1804 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14ac:	2f 81       	ldd	r18, Y+7	; 0x07
    14ae:	38 85       	ldd	r19, Y+8	; 0x08
    14b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    14b2:	9c 85       	ldd	r25, Y+12	; 0x0c
    14b4:	28 2b       	or	r18, r24
    14b6:	39 2b       	or	r19, r25
    14b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    14bc:	28 23       	and	r18, r24
    14be:	39 23       	and	r19, r25
    14c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    14c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    14c4:	28 17       	cp	r18, r24
    14c6:	39 07       	cpc	r19, r25
    14c8:	c9 f4       	brne	.+50     	; 0x14fc <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    14ca:	2f 81       	ldd	r18, Y+7	; 0x07
    14cc:	38 85       	ldd	r19, Y+8	; 0x08
    14ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    14d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    14d2:	82 2b       	or	r24, r18
    14d4:	93 2b       	or	r25, r19
    14d6:	9e 83       	std	Y+6, r25	; 0x06
    14d8:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14da:	eb 81       	ldd	r30, Y+3	; 0x03
    14dc:	fc 81       	ldd	r31, Y+4	; 0x04
    14de:	20 81       	ld	r18, Z
    14e0:	31 81       	ldd	r19, Z+1	; 0x01
    14e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    14e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    14e6:	80 95       	com	r24
    14e8:	90 95       	com	r25
    14ea:	82 23       	and	r24, r18
    14ec:	93 23       	and	r25, r19
    14ee:	eb 81       	ldd	r30, Y+3	; 0x03
    14f0:	fc 81       	ldd	r31, Y+4	; 0x04
    14f2:	91 83       	std	Z+1, r25	; 0x01
    14f4:	80 83       	st	Z, r24

			xTicksToWait = 0;
    14f6:	18 8a       	std	Y+16, r1	; 0x10
    14f8:	1f 86       	std	Y+15, r1	; 0x0f
    14fa:	1c c0       	rjmp	.+56     	; 0x1534 <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    14fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    14fe:	98 89       	ldd	r25, Y+16	; 0x10
    1500:	00 97       	sbiw	r24, 0x00	; 0
    1502:	91 f0       	breq	.+36     	; 0x1528 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1504:	8b 81       	ldd	r24, Y+3	; 0x03
    1506:	9c 81       	ldd	r25, Y+4	; 0x04
    1508:	bc 01       	movw	r22, r24
    150a:	6e 5f       	subi	r22, 0xFE	; 254
    150c:	7f 4f       	sbci	r23, 0xFF	; 255
    150e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1510:	9e 85       	ldd	r25, Y+14	; 0x0e
    1512:	9c 01       	movw	r18, r24
    1514:	35 60       	ori	r19, 0x05	; 5
    1516:	4f 85       	ldd	r20, Y+15	; 0x0f
    1518:	58 89       	ldd	r21, Y+16	; 0x10
    151a:	cb 01       	movw	r24, r22
    151c:	b9 01       	movw	r22, r18
    151e:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1522:	1e 82       	std	Y+6, r1	; 0x06
    1524:	1d 82       	std	Y+5, r1	; 0x05
    1526:	06 c0       	rjmp	.+12     	; 0x1534 <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1528:	eb 81       	ldd	r30, Y+3	; 0x03
    152a:	fc 81       	ldd	r31, Y+4	; 0x04
    152c:	80 81       	ld	r24, Z
    152e:	91 81       	ldd	r25, Z+1	; 0x01
    1530:	9e 83       	std	Y+6, r25	; 0x06
    1532:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1534:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    1538:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    153a:	8f 85       	ldd	r24, Y+15	; 0x0f
    153c:	98 89       	ldd	r25, Y+16	; 0x10
    153e:	00 97       	sbiw	r24, 0x00	; 0
    1540:	09 f4       	brne	.+2      	; 0x1544 <xEventGroupSync+0xe4>
    1542:	3a c0       	rjmp	.+116    	; 0x15b8 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    1544:	8a 81       	ldd	r24, Y+2	; 0x02
    1546:	88 23       	and	r24, r24
    1548:	11 f4       	brne	.+4      	; 0x154e <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    154a:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    154e:	0e 94 4f 24 	call	0x489e	; 0x489e <uxTaskResetEventItemValue>
    1552:	9e 83       	std	Y+6, r25	; 0x06
    1554:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1556:	8d 81       	ldd	r24, Y+5	; 0x05
    1558:	9e 81       	ldd	r25, Y+6	; 0x06
    155a:	80 70       	andi	r24, 0x00	; 0
    155c:	92 70       	andi	r25, 0x02	; 2
    155e:	00 97       	sbiw	r24, 0x00	; 0
    1560:	31 f5       	brne	.+76     	; 0x15ae <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1562:	0f b6       	in	r0, 0x3f	; 63
    1564:	f8 94       	cli
    1566:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1568:	eb 81       	ldd	r30, Y+3	; 0x03
    156a:	fc 81       	ldd	r31, Y+4	; 0x04
    156c:	80 81       	ld	r24, Z
    156e:	91 81       	ldd	r25, Z+1	; 0x01
    1570:	9e 83       	std	Y+6, r25	; 0x06
    1572:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1574:	2d 81       	ldd	r18, Y+5	; 0x05
    1576:	3e 81       	ldd	r19, Y+6	; 0x06
    1578:	8d 85       	ldd	r24, Y+13	; 0x0d
    157a:	9e 85       	ldd	r25, Y+14	; 0x0e
    157c:	28 23       	and	r18, r24
    157e:	39 23       	and	r19, r25
    1580:	8d 85       	ldd	r24, Y+13	; 0x0d
    1582:	9e 85       	ldd	r25, Y+14	; 0x0e
    1584:	28 17       	cp	r18, r24
    1586:	39 07       	cpc	r19, r25
    1588:	71 f4       	brne	.+28     	; 0x15a6 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	20 81       	ld	r18, Z
    1590:	31 81       	ldd	r19, Z+1	; 0x01
    1592:	8d 85       	ldd	r24, Y+13	; 0x0d
    1594:	9e 85       	ldd	r25, Y+14	; 0x0e
    1596:	80 95       	com	r24
    1598:	90 95       	com	r25
    159a:	82 23       	and	r24, r18
    159c:	93 23       	and	r25, r19
    159e:	eb 81       	ldd	r30, Y+3	; 0x03
    15a0:	fc 81       	ldd	r31, Y+4	; 0x04
    15a2:	91 83       	std	Z+1, r25	; 0x01
    15a4:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    15a6:	0f 90       	pop	r0
    15a8:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15ae:	8d 81       	ldd	r24, Y+5	; 0x05
    15b0:	9e 81       	ldd	r25, Y+6	; 0x06
    15b2:	90 70       	andi	r25, 0x00	; 0
    15b4:	9e 83       	std	Y+6, r25	; 0x06
    15b6:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    15b8:	8d 81       	ldd	r24, Y+5	; 0x05
    15ba:	9e 81       	ldd	r25, Y+6	; 0x06
}
    15bc:	60 96       	adiw	r28, 0x10	; 16
    15be:	0f b6       	in	r0, 0x3f	; 63
    15c0:	f8 94       	cli
    15c2:	de bf       	out	0x3e, r29	; 62
    15c4:	0f be       	out	0x3f, r0	; 63
    15c6:	cd bf       	out	0x3d, r28	; 61
    15c8:	cf 91       	pop	r28
    15ca:	df 91       	pop	r29
    15cc:	08 95       	ret

000015ce <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    15ce:	0f 93       	push	r16
    15d0:	1f 93       	push	r17
    15d2:	df 93       	push	r29
    15d4:	cf 93       	push	r28
    15d6:	cd b7       	in	r28, 0x3d	; 61
    15d8:	de b7       	in	r29, 0x3e	; 62
    15da:	63 97       	sbiw	r28, 0x13	; 19
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	de bf       	out	0x3e, r29	; 62
    15e2:	0f be       	out	0x3f, r0	; 63
    15e4:	cd bf       	out	0x3d, r28	; 61
    15e6:	9d 87       	std	Y+13, r25	; 0x0d
    15e8:	8c 87       	std	Y+12, r24	; 0x0c
    15ea:	7f 87       	std	Y+15, r23	; 0x0f
    15ec:	6e 87       	std	Y+14, r22	; 0x0e
    15ee:	48 8b       	std	Y+16, r20	; 0x10
    15f0:	29 8b       	std	Y+17, r18	; 0x11
    15f2:	1b 8b       	std	Y+19, r17	; 0x13
    15f4:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    15f6:	8c 85       	ldd	r24, Y+12	; 0x0c
    15f8:	9d 85       	ldd	r25, Y+13	; 0x0d
    15fa:	9b 87       	std	Y+11, r25	; 0x0b
    15fc:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    15fe:	1f 82       	std	Y+7, r1	; 0x07
    1600:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1602:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1604:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1608:	ea 85       	ldd	r30, Y+10	; 0x0a
    160a:	fb 85       	ldd	r31, Y+11	; 0x0b
    160c:	80 81       	ld	r24, Z
    160e:	91 81       	ldd	r25, Z+1	; 0x01
    1610:	9a 83       	std	Y+2, r25	; 0x02
    1612:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1614:	89 81       	ldd	r24, Y+1	; 0x01
    1616:	9a 81       	ldd	r25, Y+2	; 0x02
    1618:	2e 85       	ldd	r18, Y+14	; 0x0e
    161a:	3f 85       	ldd	r19, Y+15	; 0x0f
    161c:	b9 01       	movw	r22, r18
    161e:	49 89       	ldd	r20, Y+17	; 0x11
    1620:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvTestWaitCondition>
    1624:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1626:	8d 81       	ldd	r24, Y+5	; 0x05
    1628:	88 23       	and	r24, r24
    162a:	c1 f0       	breq	.+48     	; 0x165c <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    162c:	89 81       	ldd	r24, Y+1	; 0x01
    162e:	9a 81       	ldd	r25, Y+2	; 0x02
    1630:	99 87       	std	Y+9, r25	; 0x09
    1632:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1634:	1b 8a       	std	Y+19, r1	; 0x13
    1636:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1638:	88 89       	ldd	r24, Y+16	; 0x10
    163a:	88 23       	and	r24, r24
    163c:	d9 f1       	breq	.+118    	; 0x16b4 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    163e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1640:	fb 85       	ldd	r31, Y+11	; 0x0b
    1642:	20 81       	ld	r18, Z
    1644:	31 81       	ldd	r19, Z+1	; 0x01
    1646:	8e 85       	ldd	r24, Y+14	; 0x0e
    1648:	9f 85       	ldd	r25, Y+15	; 0x0f
    164a:	80 95       	com	r24
    164c:	90 95       	com	r25
    164e:	82 23       	and	r24, r18
    1650:	93 23       	and	r25, r19
    1652:	ea 85       	ldd	r30, Y+10	; 0x0a
    1654:	fb 85       	ldd	r31, Y+11	; 0x0b
    1656:	91 83       	std	Z+1, r25	; 0x01
    1658:	80 83       	st	Z, r24
    165a:	2c c0       	rjmp	.+88     	; 0x16b4 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    165c:	8a 89       	ldd	r24, Y+18	; 0x12
    165e:	9b 89       	ldd	r25, Y+19	; 0x13
    1660:	00 97       	sbiw	r24, 0x00	; 0
    1662:	29 f4       	brne	.+10     	; 0x166e <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	9a 81       	ldd	r25, Y+2	; 0x02
    1668:	99 87       	std	Y+9, r25	; 0x09
    166a:	88 87       	std	Y+8, r24	; 0x08
    166c:	23 c0       	rjmp	.+70     	; 0x16b4 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    166e:	88 89       	ldd	r24, Y+16	; 0x10
    1670:	88 23       	and	r24, r24
    1672:	29 f0       	breq	.+10     	; 0x167e <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1674:	8e 81       	ldd	r24, Y+6	; 0x06
    1676:	9f 81       	ldd	r25, Y+7	; 0x07
    1678:	91 60       	ori	r25, 0x01	; 1
    167a:	9f 83       	std	Y+7, r25	; 0x07
    167c:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    167e:	89 89       	ldd	r24, Y+17	; 0x11
    1680:	88 23       	and	r24, r24
    1682:	29 f0       	breq	.+10     	; 0x168e <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1684:	8e 81       	ldd	r24, Y+6	; 0x06
    1686:	9f 81       	ldd	r25, Y+7	; 0x07
    1688:	94 60       	ori	r25, 0x04	; 4
    168a:	9f 83       	std	Y+7, r25	; 0x07
    168c:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    168e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1690:	9b 85       	ldd	r25, Y+11	; 0x0b
    1692:	bc 01       	movw	r22, r24
    1694:	6e 5f       	subi	r22, 0xFE	; 254
    1696:	7f 4f       	sbci	r23, 0xFF	; 255
    1698:	2e 85       	ldd	r18, Y+14	; 0x0e
    169a:	3f 85       	ldd	r19, Y+15	; 0x0f
    169c:	8e 81       	ldd	r24, Y+6	; 0x06
    169e:	9f 81       	ldd	r25, Y+7	; 0x07
    16a0:	28 2b       	or	r18, r24
    16a2:	39 2b       	or	r19, r25
    16a4:	4a 89       	ldd	r20, Y+18	; 0x12
    16a6:	5b 89       	ldd	r21, Y+19	; 0x13
    16a8:	cb 01       	movw	r24, r22
    16aa:	b9 01       	movw	r22, r18
    16ac:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    16b0:	19 86       	std	Y+9, r1	; 0x09
    16b2:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    16b4:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    16b8:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    16ba:	8a 89       	ldd	r24, Y+18	; 0x12
    16bc:	9b 89       	ldd	r25, Y+19	; 0x13
    16be:	00 97       	sbiw	r24, 0x00	; 0
    16c0:	09 f4       	brne	.+2      	; 0x16c4 <xEventGroupWaitBits+0xf6>
    16c2:	3b c0       	rjmp	.+118    	; 0x173a <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    16c4:	8c 81       	ldd	r24, Y+4	; 0x04
    16c6:	88 23       	and	r24, r24
    16c8:	11 f4       	brne	.+4      	; 0x16ce <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    16ca:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    16ce:	0e 94 4f 24 	call	0x489e	; 0x489e <uxTaskResetEventItemValue>
    16d2:	99 87       	std	Y+9, r25	; 0x09
    16d4:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    16d6:	88 85       	ldd	r24, Y+8	; 0x08
    16d8:	99 85       	ldd	r25, Y+9	; 0x09
    16da:	80 70       	andi	r24, 0x00	; 0
    16dc:	92 70       	andi	r25, 0x02	; 2
    16de:	00 97       	sbiw	r24, 0x00	; 0
    16e0:	39 f5       	brne	.+78     	; 0x1730 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    16e2:	0f b6       	in	r0, 0x3f	; 63
    16e4:	f8 94       	cli
    16e6:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    16e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    16ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    16ec:	80 81       	ld	r24, Z
    16ee:	91 81       	ldd	r25, Z+1	; 0x01
    16f0:	99 87       	std	Y+9, r25	; 0x09
    16f2:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    16f4:	88 85       	ldd	r24, Y+8	; 0x08
    16f6:	99 85       	ldd	r25, Y+9	; 0x09
    16f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    16fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    16fc:	b9 01       	movw	r22, r18
    16fe:	49 89       	ldd	r20, Y+17	; 0x11
    1700:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvTestWaitCondition>
    1704:	88 23       	and	r24, r24
    1706:	89 f0       	breq	.+34     	; 0x172a <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    1708:	88 89       	ldd	r24, Y+16	; 0x10
    170a:	88 23       	and	r24, r24
    170c:	71 f0       	breq	.+28     	; 0x172a <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    170e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1710:	fb 85       	ldd	r31, Y+11	; 0x0b
    1712:	20 81       	ld	r18, Z
    1714:	31 81       	ldd	r19, Z+1	; 0x01
    1716:	8e 85       	ldd	r24, Y+14	; 0x0e
    1718:	9f 85       	ldd	r25, Y+15	; 0x0f
    171a:	80 95       	com	r24
    171c:	90 95       	com	r25
    171e:	82 23       	and	r24, r18
    1720:	93 23       	and	r25, r19
    1722:	ea 85       	ldd	r30, Y+10	; 0x0a
    1724:	fb 85       	ldd	r31, Y+11	; 0x0b
    1726:	91 83       	std	Z+1, r25	; 0x01
    1728:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    172e:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1730:	88 85       	ldd	r24, Y+8	; 0x08
    1732:	99 85       	ldd	r25, Y+9	; 0x09
    1734:	90 70       	andi	r25, 0x00	; 0
    1736:	99 87       	std	Y+9, r25	; 0x09
    1738:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    173a:	88 85       	ldd	r24, Y+8	; 0x08
    173c:	99 85       	ldd	r25, Y+9	; 0x09
}
    173e:	63 96       	adiw	r28, 0x13	; 19
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	cd bf       	out	0x3d, r28	; 61
    174a:	cf 91       	pop	r28
    174c:	df 91       	pop	r29
    174e:	1f 91       	pop	r17
    1750:	0f 91       	pop	r16
    1752:	08 95       	ret

00001754 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1754:	df 93       	push	r29
    1756:	cf 93       	push	r28
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
    175c:	28 97       	sbiw	r28, 0x08	; 8
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	9e 83       	std	Y+6, r25	; 0x06
    176a:	8d 83       	std	Y+5, r24	; 0x05
    176c:	78 87       	std	Y+8, r23	; 0x08
    176e:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1770:	8d 81       	ldd	r24, Y+5	; 0x05
    1772:	9e 81       	ldd	r25, Y+6	; 0x06
    1774:	9c 83       	std	Y+4, r25	; 0x04
    1776:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1778:	0f b6       	in	r0, 0x3f	; 63
    177a:	f8 94       	cli
    177c:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    177e:	eb 81       	ldd	r30, Y+3	; 0x03
    1780:	fc 81       	ldd	r31, Y+4	; 0x04
    1782:	80 81       	ld	r24, Z
    1784:	91 81       	ldd	r25, Z+1	; 0x01
    1786:	9a 83       	std	Y+2, r25	; 0x02
    1788:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    178a:	eb 81       	ldd	r30, Y+3	; 0x03
    178c:	fc 81       	ldd	r31, Y+4	; 0x04
    178e:	20 81       	ld	r18, Z
    1790:	31 81       	ldd	r19, Z+1	; 0x01
    1792:	8f 81       	ldd	r24, Y+7	; 0x07
    1794:	98 85       	ldd	r25, Y+8	; 0x08
    1796:	80 95       	com	r24
    1798:	90 95       	com	r25
    179a:	82 23       	and	r24, r18
    179c:	93 23       	and	r25, r19
    179e:	eb 81       	ldd	r30, Y+3	; 0x03
    17a0:	fc 81       	ldd	r31, Y+4	; 0x04
    17a2:	91 83       	std	Z+1, r25	; 0x01
    17a4:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    17a6:	0f 90       	pop	r0
    17a8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17ae:	28 96       	adiw	r28, 0x08	; 8
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	0f be       	out	0x3f, r0	; 63
    17b8:	cd bf       	out	0x3d, r28	; 61
    17ba:	cf 91       	pop	r28
    17bc:	df 91       	pop	r29
    17be:	08 95       	ret

000017c0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    17c0:	df 93       	push	r29
    17c2:	cf 93       	push	r28
    17c4:	cd b7       	in	r28, 0x3d	; 61
    17c6:	de b7       	in	r29, 0x3e	; 62
    17c8:	27 97       	sbiw	r28, 0x07	; 7
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	f8 94       	cli
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	0f be       	out	0x3f, r0	; 63
    17d2:	cd bf       	out	0x3d, r28	; 61
    17d4:	9f 83       	std	Y+7, r25	; 0x07
    17d6:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    17d8:	8e 81       	ldd	r24, Y+6	; 0x06
    17da:	9f 81       	ldd	r25, Y+7	; 0x07
    17dc:	9c 83       	std	Y+4, r25	; 0x04
    17de:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    17e0:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    17e2:	eb 81       	ldd	r30, Y+3	; 0x03
    17e4:	fc 81       	ldd	r31, Y+4	; 0x04
    17e6:	80 81       	ld	r24, Z
    17e8:	91 81       	ldd	r25, Z+1	; 0x01
    17ea:	9a 83       	std	Y+2, r25	; 0x02
    17ec:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    17ee:	89 81       	ldd	r24, Y+1	; 0x01
    17f0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17f2:	27 96       	adiw	r28, 0x07	; 7
    17f4:	0f b6       	in	r0, 0x3f	; 63
    17f6:	f8 94       	cli
    17f8:	de bf       	out	0x3e, r29	; 62
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	cd bf       	out	0x3d, r28	; 61
    17fe:	cf 91       	pop	r28
    1800:	df 91       	pop	r29
    1802:	08 95       	ret

00001804 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1804:	df 93       	push	r29
    1806:	cf 93       	push	r28
    1808:	cd b7       	in	r28, 0x3d	; 61
    180a:	de b7       	in	r29, 0x3e	; 62
    180c:	65 97       	sbiw	r28, 0x15	; 21
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	de bf       	out	0x3e, r29	; 62
    1814:	0f be       	out	0x3f, r0	; 63
    1816:	cd bf       	out	0x3d, r28	; 61
    1818:	9b 8b       	std	Y+19, r25	; 0x13
    181a:	8a 8b       	std	Y+18, r24	; 0x12
    181c:	7d 8b       	std	Y+21, r23	; 0x15
    181e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1820:	19 86       	std	Y+9, r1	; 0x09
    1822:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1824:	8a 89       	ldd	r24, Y+18	; 0x12
    1826:	9b 89       	ldd	r25, Y+19	; 0x13
    1828:	9b 83       	std	Y+3, r25	; 0x03
    182a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    182c:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    182e:	8a 81       	ldd	r24, Y+2	; 0x02
    1830:	9b 81       	ldd	r25, Y+3	; 0x03
    1832:	02 96       	adiw	r24, 0x02	; 2
    1834:	9b 87       	std	Y+11, r25	; 0x0b
    1836:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1838:	8a 85       	ldd	r24, Y+10	; 0x0a
    183a:	9b 85       	ldd	r25, Y+11	; 0x0b
    183c:	03 96       	adiw	r24, 0x03	; 3
    183e:	9d 87       	std	Y+13, r25	; 0x0d
    1840:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1842:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1846:	ea 85       	ldd	r30, Y+10	; 0x0a
    1848:	fb 85       	ldd	r31, Y+11	; 0x0b
    184a:	85 81       	ldd	r24, Z+5	; 0x05
    184c:	96 81       	ldd	r25, Z+6	; 0x06
    184e:	99 8b       	std	Y+17, r25	; 0x11
    1850:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1852:	ea 81       	ldd	r30, Y+2	; 0x02
    1854:	fb 81       	ldd	r31, Y+3	; 0x03
    1856:	20 81       	ld	r18, Z
    1858:	31 81       	ldd	r19, Z+1	; 0x01
    185a:	8c 89       	ldd	r24, Y+20	; 0x14
    185c:	9d 89       	ldd	r25, Y+21	; 0x15
    185e:	82 2b       	or	r24, r18
    1860:	93 2b       	or	r25, r19
    1862:	ea 81       	ldd	r30, Y+2	; 0x02
    1864:	fb 81       	ldd	r31, Y+3	; 0x03
    1866:	91 83       	std	Z+1, r25	; 0x01
    1868:	80 83       	st	Z, r24
    186a:	59 c0       	rjmp	.+178    	; 0x191e <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    186c:	e8 89       	ldd	r30, Y+16	; 0x10
    186e:	f9 89       	ldd	r31, Y+17	; 0x11
    1870:	82 81       	ldd	r24, Z+2	; 0x02
    1872:	93 81       	ldd	r25, Z+3	; 0x03
    1874:	9f 87       	std	Y+15, r25	; 0x0f
    1876:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1878:	e8 89       	ldd	r30, Y+16	; 0x10
    187a:	f9 89       	ldd	r31, Y+17	; 0x11
    187c:	80 81       	ld	r24, Z
    187e:	91 81       	ldd	r25, Z+1	; 0x01
    1880:	9f 83       	std	Y+7, r25	; 0x07
    1882:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1884:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1886:	8e 81       	ldd	r24, Y+6	; 0x06
    1888:	9f 81       	ldd	r25, Y+7	; 0x07
    188a:	80 70       	andi	r24, 0x00	; 0
    188c:	9d 83       	std	Y+5, r25	; 0x05
    188e:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1890:	8e 81       	ldd	r24, Y+6	; 0x06
    1892:	9f 81       	ldd	r25, Y+7	; 0x07
    1894:	90 70       	andi	r25, 0x00	; 0
    1896:	9f 83       	std	Y+7, r25	; 0x07
    1898:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    189a:	8c 81       	ldd	r24, Y+4	; 0x04
    189c:	9d 81       	ldd	r25, Y+5	; 0x05
    189e:	80 70       	andi	r24, 0x00	; 0
    18a0:	94 70       	andi	r25, 0x04	; 4
    18a2:	00 97       	sbiw	r24, 0x00	; 0
    18a4:	69 f4       	brne	.+26     	; 0x18c0 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    18a6:	ea 81       	ldd	r30, Y+2	; 0x02
    18a8:	fb 81       	ldd	r31, Y+3	; 0x03
    18aa:	20 81       	ld	r18, Z
    18ac:	31 81       	ldd	r19, Z+1	; 0x01
    18ae:	8e 81       	ldd	r24, Y+6	; 0x06
    18b0:	9f 81       	ldd	r25, Y+7	; 0x07
    18b2:	82 23       	and	r24, r18
    18b4:	93 23       	and	r25, r19
    18b6:	00 97       	sbiw	r24, 0x00	; 0
    18b8:	91 f0       	breq	.+36     	; 0x18de <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    18ba:	81 e0       	ldi	r24, 0x01	; 1
    18bc:	89 83       	std	Y+1, r24	; 0x01
    18be:	0f c0       	rjmp	.+30     	; 0x18de <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    18c0:	ea 81       	ldd	r30, Y+2	; 0x02
    18c2:	fb 81       	ldd	r31, Y+3	; 0x03
    18c4:	20 81       	ld	r18, Z
    18c6:	31 81       	ldd	r19, Z+1	; 0x01
    18c8:	8e 81       	ldd	r24, Y+6	; 0x06
    18ca:	9f 81       	ldd	r25, Y+7	; 0x07
    18cc:	28 23       	and	r18, r24
    18ce:	39 23       	and	r19, r25
    18d0:	8e 81       	ldd	r24, Y+6	; 0x06
    18d2:	9f 81       	ldd	r25, Y+7	; 0x07
    18d4:	28 17       	cp	r18, r24
    18d6:	39 07       	cpc	r19, r25
    18d8:	11 f4       	brne	.+4      	; 0x18de <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    18da:	81 e0       	ldi	r24, 0x01	; 1
    18dc:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    18de:	89 81       	ldd	r24, Y+1	; 0x01
    18e0:	88 23       	and	r24, r24
    18e2:	c9 f0       	breq	.+50     	; 0x1916 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    18e4:	8c 81       	ldd	r24, Y+4	; 0x04
    18e6:	9d 81       	ldd	r25, Y+5	; 0x05
    18e8:	80 70       	andi	r24, 0x00	; 0
    18ea:	91 70       	andi	r25, 0x01	; 1
    18ec:	00 97       	sbiw	r24, 0x00	; 0
    18ee:	41 f0       	breq	.+16     	; 0x1900 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    18f0:	88 85       	ldd	r24, Y+8	; 0x08
    18f2:	99 85       	ldd	r25, Y+9	; 0x09
    18f4:	2e 81       	ldd	r18, Y+6	; 0x06
    18f6:	3f 81       	ldd	r19, Y+7	; 0x07
    18f8:	82 2b       	or	r24, r18
    18fa:	93 2b       	or	r25, r19
    18fc:	99 87       	std	Y+9, r25	; 0x09
    18fe:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1900:	ea 81       	ldd	r30, Y+2	; 0x02
    1902:	fb 81       	ldd	r31, Y+3	; 0x03
    1904:	80 81       	ld	r24, Z
    1906:	91 81       	ldd	r25, Z+1	; 0x01
    1908:	9c 01       	movw	r18, r24
    190a:	32 60       	ori	r19, 0x02	; 2
    190c:	88 89       	ldd	r24, Y+16	; 0x10
    190e:	99 89       	ldd	r25, Y+17	; 0x11
    1910:	b9 01       	movw	r22, r18
    1912:	0e 94 81 20 	call	0x4102	; 0x4102 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1916:	8e 85       	ldd	r24, Y+14	; 0x0e
    1918:	9f 85       	ldd	r25, Y+15	; 0x0f
    191a:	99 8b       	std	Y+17, r25	; 0x11
    191c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    191e:	28 89       	ldd	r18, Y+16	; 0x10
    1920:	39 89       	ldd	r19, Y+17	; 0x11
    1922:	8c 85       	ldd	r24, Y+12	; 0x0c
    1924:	9d 85       	ldd	r25, Y+13	; 0x0d
    1926:	28 17       	cp	r18, r24
    1928:	39 07       	cpc	r19, r25
    192a:	09 f0       	breq	.+2      	; 0x192e <xEventGroupSetBits+0x12a>
    192c:	9f cf       	rjmp	.-194    	; 0x186c <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    192e:	ea 81       	ldd	r30, Y+2	; 0x02
    1930:	fb 81       	ldd	r31, Y+3	; 0x03
    1932:	20 81       	ld	r18, Z
    1934:	31 81       	ldd	r19, Z+1	; 0x01
    1936:	88 85       	ldd	r24, Y+8	; 0x08
    1938:	99 85       	ldd	r25, Y+9	; 0x09
    193a:	80 95       	com	r24
    193c:	90 95       	com	r25
    193e:	82 23       	and	r24, r18
    1940:	93 23       	and	r25, r19
    1942:	ea 81       	ldd	r30, Y+2	; 0x02
    1944:	fb 81       	ldd	r31, Y+3	; 0x03
    1946:	91 83       	std	Z+1, r25	; 0x01
    1948:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    194a:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    194e:	ea 81       	ldd	r30, Y+2	; 0x02
    1950:	fb 81       	ldd	r31, Y+3	; 0x03
    1952:	80 81       	ld	r24, Z
    1954:	91 81       	ldd	r25, Z+1	; 0x01
}
    1956:	65 96       	adiw	r28, 0x15	; 21
    1958:	0f b6       	in	r0, 0x3f	; 63
    195a:	f8 94       	cli
    195c:	de bf       	out	0x3e, r29	; 62
    195e:	0f be       	out	0x3f, r0	; 63
    1960:	cd bf       	out	0x3d, r28	; 61
    1962:	cf 91       	pop	r28
    1964:	df 91       	pop	r29
    1966:	08 95       	ret

00001968 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1968:	df 93       	push	r29
    196a:	cf 93       	push	r28
    196c:	00 d0       	rcall	.+0      	; 0x196e <vEventGroupDelete+0x6>
    196e:	00 d0       	rcall	.+0      	; 0x1970 <vEventGroupDelete+0x8>
    1970:	00 d0       	rcall	.+0      	; 0x1972 <vEventGroupDelete+0xa>
    1972:	cd b7       	in	r28, 0x3d	; 61
    1974:	de b7       	in	r29, 0x3e	; 62
    1976:	9e 83       	std	Y+6, r25	; 0x06
    1978:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    197a:	8d 81       	ldd	r24, Y+5	; 0x05
    197c:	9e 81       	ldd	r25, Y+6	; 0x06
    197e:	9c 83       	std	Y+4, r25	; 0x04
    1980:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	9c 81       	ldd	r25, Y+4	; 0x04
    1986:	02 96       	adiw	r24, 0x02	; 2
    1988:	9a 83       	std	Y+2, r25	; 0x02
    198a:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    198c:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
    1990:	08 c0       	rjmp	.+16     	; 0x19a2 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1992:	e9 81       	ldd	r30, Y+1	; 0x01
    1994:	fa 81       	ldd	r31, Y+2	; 0x02
    1996:	85 81       	ldd	r24, Z+5	; 0x05
    1998:	96 81       	ldd	r25, Z+6	; 0x06
    199a:	60 e0       	ldi	r22, 0x00	; 0
    199c:	72 e0       	ldi	r23, 0x02	; 2
    199e:	0e 94 81 20 	call	0x4102	; 0x4102 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    19a2:	e9 81       	ldd	r30, Y+1	; 0x01
    19a4:	fa 81       	ldd	r31, Y+2	; 0x02
    19a6:	80 81       	ld	r24, Z
    19a8:	88 23       	and	r24, r24
    19aa:	99 f7       	brne	.-26     	; 0x1992 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	9c 81       	ldd	r25, Y+4	; 0x04
    19b0:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
	}
	( void ) xTaskResumeAll();
    19b4:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
}
    19b8:	26 96       	adiw	r28, 0x06	; 6
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	de bf       	out	0x3e, r29	; 62
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	cd bf       	out	0x3d, r28	; 61
    19c4:	cf 91       	pop	r28
    19c6:	df 91       	pop	r29
    19c8:	08 95       	ret

000019ca <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    19ca:	df 93       	push	r29
    19cc:	cf 93       	push	r28
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <vEventGroupSetBitsCallback+0x6>
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <vEventGroupSetBitsCallback+0x8>
    19d2:	00 d0       	rcall	.+0      	; 0x19d4 <vEventGroupSetBitsCallback+0xa>
    19d4:	cd b7       	in	r28, 0x3d	; 61
    19d6:	de b7       	in	r29, 0x3e	; 62
    19d8:	9a 83       	std	Y+2, r25	; 0x02
    19da:	89 83       	std	Y+1, r24	; 0x01
    19dc:	4b 83       	std	Y+3, r20	; 0x03
    19de:	5c 83       	std	Y+4, r21	; 0x04
    19e0:	6d 83       	std	Y+5, r22	; 0x05
    19e2:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    19e4:	2b 81       	ldd	r18, Y+3	; 0x03
    19e6:	3c 81       	ldd	r19, Y+4	; 0x04
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	9a 81       	ldd	r25, Y+2	; 0x02
    19ec:	b9 01       	movw	r22, r18
    19ee:	0e 94 02 0c 	call	0x1804	; 0x1804 <xEventGroupSetBits>
}
    19f2:	26 96       	adiw	r28, 0x06	; 6
    19f4:	0f b6       	in	r0, 0x3f	; 63
    19f6:	f8 94       	cli
    19f8:	de bf       	out	0x3e, r29	; 62
    19fa:	0f be       	out	0x3f, r0	; 63
    19fc:	cd bf       	out	0x3d, r28	; 61
    19fe:	cf 91       	pop	r28
    1a00:	df 91       	pop	r29
    1a02:	08 95       	ret

00001a04 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1a04:	df 93       	push	r29
    1a06:	cf 93       	push	r28
    1a08:	00 d0       	rcall	.+0      	; 0x1a0a <vEventGroupClearBitsCallback+0x6>
    1a0a:	00 d0       	rcall	.+0      	; 0x1a0c <vEventGroupClearBitsCallback+0x8>
    1a0c:	00 d0       	rcall	.+0      	; 0x1a0e <vEventGroupClearBitsCallback+0xa>
    1a0e:	cd b7       	in	r28, 0x3d	; 61
    1a10:	de b7       	in	r29, 0x3e	; 62
    1a12:	9a 83       	std	Y+2, r25	; 0x02
    1a14:	89 83       	std	Y+1, r24	; 0x01
    1a16:	4b 83       	std	Y+3, r20	; 0x03
    1a18:	5c 83       	std	Y+4, r21	; 0x04
    1a1a:	6d 83       	std	Y+5, r22	; 0x05
    1a1c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    1a1e:	2b 81       	ldd	r18, Y+3	; 0x03
    1a20:	3c 81       	ldd	r19, Y+4	; 0x04
    1a22:	89 81       	ldd	r24, Y+1	; 0x01
    1a24:	9a 81       	ldd	r25, Y+2	; 0x02
    1a26:	b9 01       	movw	r22, r18
    1a28:	0e 94 aa 0b 	call	0x1754	; 0x1754 <xEventGroupClearBits>
}
    1a2c:	26 96       	adiw	r28, 0x06	; 6
    1a2e:	0f b6       	in	r0, 0x3f	; 63
    1a30:	f8 94       	cli
    1a32:	de bf       	out	0x3e, r29	; 62
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	cd bf       	out	0x3d, r28	; 61
    1a38:	cf 91       	pop	r28
    1a3a:	df 91       	pop	r29
    1a3c:	08 95       	ret

00001a3e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1a3e:	df 93       	push	r29
    1a40:	cf 93       	push	r28
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <prvTestWaitCondition+0x6>
    1a44:	00 d0       	rcall	.+0      	; 0x1a46 <prvTestWaitCondition+0x8>
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <prvTestWaitCondition+0xa>
    1a48:	cd b7       	in	r28, 0x3d	; 61
    1a4a:	de b7       	in	r29, 0x3e	; 62
    1a4c:	9b 83       	std	Y+3, r25	; 0x03
    1a4e:	8a 83       	std	Y+2, r24	; 0x02
    1a50:	7d 83       	std	Y+5, r23	; 0x05
    1a52:	6c 83       	std	Y+4, r22	; 0x04
    1a54:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1a56:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1a58:	8e 81       	ldd	r24, Y+6	; 0x06
    1a5a:	88 23       	and	r24, r24
    1a5c:	59 f4       	brne	.+22     	; 0x1a74 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a60:	9b 81       	ldd	r25, Y+3	; 0x03
    1a62:	2c 81       	ldd	r18, Y+4	; 0x04
    1a64:	3d 81       	ldd	r19, Y+5	; 0x05
    1a66:	82 23       	and	r24, r18
    1a68:	93 23       	and	r25, r19
    1a6a:	00 97       	sbiw	r24, 0x00	; 0
    1a6c:	81 f0       	breq	.+32     	; 0x1a8e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a6e:	81 e0       	ldi	r24, 0x01	; 1
    1a70:	89 83       	std	Y+1, r24	; 0x01
    1a72:	0d c0       	rjmp	.+26     	; 0x1a8e <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1a74:	2a 81       	ldd	r18, Y+2	; 0x02
    1a76:	3b 81       	ldd	r19, Y+3	; 0x03
    1a78:	8c 81       	ldd	r24, Y+4	; 0x04
    1a7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a7c:	28 23       	and	r18, r24
    1a7e:	39 23       	and	r19, r25
    1a80:	8c 81       	ldd	r24, Y+4	; 0x04
    1a82:	9d 81       	ldd	r25, Y+5	; 0x05
    1a84:	28 17       	cp	r18, r24
    1a86:	39 07       	cpc	r19, r25
    1a88:	11 f4       	brne	.+4      	; 0x1a8e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a8a:	81 e0       	ldi	r24, 0x01	; 1
    1a8c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a90:	26 96       	adiw	r28, 0x06	; 6
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	de bf       	out	0x3e, r29	; 62
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	cd bf       	out	0x3d, r28	; 61
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	08 95       	ret

00001aa2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1aa2:	df 93       	push	r29
    1aa4:	cf 93       	push	r28
    1aa6:	00 d0       	rcall	.+0      	; 0x1aa8 <pvPortMalloc+0x6>
    1aa8:	00 d0       	rcall	.+0      	; 0x1aaa <pvPortMalloc+0x8>
    1aaa:	cd b7       	in	r28, 0x3d	; 61
    1aac:	de b7       	in	r29, 0x3e	; 62
    1aae:	9c 83       	std	Y+4, r25	; 0x04
    1ab0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1ab2:	1a 82       	std	Y+2, r1	; 0x02
    1ab4:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1ab6:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1aba:	80 91 16 01 	lds	r24, 0x0116
    1abe:	90 91 17 01 	lds	r25, 0x0117
    1ac2:	00 97       	sbiw	r24, 0x00	; 0
    1ac4:	31 f4       	brne	.+12     	; 0x1ad2 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1ac6:	89 e1       	ldi	r24, 0x19	; 25
    1ac8:	91 e0       	ldi	r25, 0x01	; 1
    1aca:	90 93 17 01 	sts	0x0117, r25
    1ace:	80 93 16 01 	sts	0x0116, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1ad2:	80 91 14 01 	lds	r24, 0x0114
    1ad6:	90 91 15 01 	lds	r25, 0x0115
    1ada:	2b 81       	ldd	r18, Y+3	; 0x03
    1adc:	3c 81       	ldd	r19, Y+4	; 0x04
    1ade:	82 0f       	add	r24, r18
    1ae0:	93 1f       	adc	r25, r19
    1ae2:	24 e0       	ldi	r18, 0x04	; 4
    1ae4:	8d 37       	cpi	r24, 0x7D	; 125
    1ae6:	92 07       	cpc	r25, r18
    1ae8:	38 f5       	brcc	.+78     	; 0x1b38 <pvPortMalloc+0x96>
    1aea:	20 91 14 01 	lds	r18, 0x0114
    1aee:	30 91 15 01 	lds	r19, 0x0115
    1af2:	8b 81       	ldd	r24, Y+3	; 0x03
    1af4:	9c 81       	ldd	r25, Y+4	; 0x04
    1af6:	28 0f       	add	r18, r24
    1af8:	39 1f       	adc	r19, r25
    1afa:	80 91 14 01 	lds	r24, 0x0114
    1afe:	90 91 15 01 	lds	r25, 0x0115
    1b02:	82 17       	cp	r24, r18
    1b04:	93 07       	cpc	r25, r19
    1b06:	c0 f4       	brcc	.+48     	; 0x1b38 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1b08:	20 91 16 01 	lds	r18, 0x0116
    1b0c:	30 91 17 01 	lds	r19, 0x0117
    1b10:	80 91 14 01 	lds	r24, 0x0114
    1b14:	90 91 15 01 	lds	r25, 0x0115
    1b18:	82 0f       	add	r24, r18
    1b1a:	93 1f       	adc	r25, r19
    1b1c:	9a 83       	std	Y+2, r25	; 0x02
    1b1e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1b20:	20 91 14 01 	lds	r18, 0x0114
    1b24:	30 91 15 01 	lds	r19, 0x0115
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	82 0f       	add	r24, r18
    1b2e:	93 1f       	adc	r25, r19
    1b30:	90 93 15 01 	sts	0x0115, r25
    1b34:	80 93 14 01 	sts	0x0114, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b38:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1b3c:	89 81       	ldd	r24, Y+1	; 0x01
    1b3e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b40:	0f 90       	pop	r0
    1b42:	0f 90       	pop	r0
    1b44:	0f 90       	pop	r0
    1b46:	0f 90       	pop	r0
    1b48:	cf 91       	pop	r28
    1b4a:	df 91       	pop	r29
    1b4c:	08 95       	ret

00001b4e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b4e:	df 93       	push	r29
    1b50:	cf 93       	push	r28
    1b52:	00 d0       	rcall	.+0      	; 0x1b54 <vPortFree+0x6>
    1b54:	cd b7       	in	r28, 0x3d	; 61
    1b56:	de b7       	in	r29, 0x3e	; 62
    1b58:	9a 83       	std	Y+2, r25	; 0x02
    1b5a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	cf 91       	pop	r28
    1b62:	df 91       	pop	r29
    1b64:	08 95       	ret

00001b66 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1b66:	df 93       	push	r29
    1b68:	cf 93       	push	r28
    1b6a:	cd b7       	in	r28, 0x3d	; 61
    1b6c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1b6e:	10 92 15 01 	sts	0x0115, r1
    1b72:	10 92 14 01 	sts	0x0114, r1
}
    1b76:	cf 91       	pop	r28
    1b78:	df 91       	pop	r29
    1b7a:	08 95       	ret

00001b7c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1b7c:	df 93       	push	r29
    1b7e:	cf 93       	push	r28
    1b80:	cd b7       	in	r28, 0x3d	; 61
    1b82:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1b84:	20 91 14 01 	lds	r18, 0x0114
    1b88:	30 91 15 01 	lds	r19, 0x0115
    1b8c:	8d e7       	ldi	r24, 0x7D	; 125
    1b8e:	94 e0       	ldi	r25, 0x04	; 4
    1b90:	82 1b       	sub	r24, r18
    1b92:	93 0b       	sbc	r25, r19
}
    1b94:	cf 91       	pop	r28
    1b96:	df 91       	pop	r29
    1b98:	08 95       	ret

00001b9a <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    1b9a:	af 92       	push	r10
    1b9c:	bf 92       	push	r11
    1b9e:	cf 92       	push	r12
    1ba0:	df 92       	push	r13
    1ba2:	ef 92       	push	r14
    1ba4:	ff 92       	push	r15
    1ba6:	0f 93       	push	r16
    1ba8:	df 93       	push	r29
    1baa:	cf 93       	push	r28
    1bac:	00 d0       	rcall	.+0      	; 0x1bae <vStartIntegerMathTasks+0x14>
    1bae:	0f 92       	push	r0
    1bb0:	cd b7       	in	r28, 0x3d	; 61
    1bb2:	de b7       	in	r29, 0x3e	; 62
    1bb4:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1bb6:	1a 82       	std	Y+2, r1	; 0x02
    1bb8:	19 82       	std	Y+1, r1	; 0x01
    1bba:	1b c0       	rjmp	.+54     	; 0x1bf2 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	ea 56       	subi	r30, 0x6A	; 106
    1bc4:	fa 4f       	sbci	r31, 0xFA	; 250
    1bc6:	8b e0       	ldi	r24, 0x0B	; 11
    1bc8:	9e e0       	ldi	r25, 0x0E	; 14
    1bca:	20 e7       	ldi	r18, 0x70	; 112
    1bcc:	30 e0       	ldi	r19, 0x00	; 0
    1bce:	b9 01       	movw	r22, r18
    1bd0:	45 e5       	ldi	r20, 0x55	; 85
    1bd2:	50 e0       	ldi	r21, 0x00	; 0
    1bd4:	9f 01       	movw	r18, r30
    1bd6:	0b 81       	ldd	r16, Y+3	; 0x03
    1bd8:	ee 24       	eor	r14, r14
    1bda:	ff 24       	eor	r15, r15
    1bdc:	cc 24       	eor	r12, r12
    1bde:	dd 24       	eor	r13, r13
    1be0:	aa 24       	eor	r10, r10
    1be2:	bb 24       	eor	r11, r11
    1be4:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1be8:	89 81       	ldd	r24, Y+1	; 0x01
    1bea:	9a 81       	ldd	r25, Y+2	; 0x02
    1bec:	01 96       	adiw	r24, 0x01	; 1
    1bee:	9a 83       	std	Y+2, r25	; 0x02
    1bf0:	89 83       	std	Y+1, r24	; 0x01
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf6:	18 16       	cp	r1, r24
    1bf8:	19 06       	cpc	r1, r25
    1bfa:	04 f7       	brge	.-64     	; 0x1bbc <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    1bfc:	0f 90       	pop	r0
    1bfe:	0f 90       	pop	r0
    1c00:	0f 90       	pop	r0
    1c02:	cf 91       	pop	r28
    1c04:	df 91       	pop	r29
    1c06:	0f 91       	pop	r16
    1c08:	ff 90       	pop	r15
    1c0a:	ef 90       	pop	r14
    1c0c:	df 90       	pop	r13
    1c0e:	cf 90       	pop	r12
    1c10:	bf 90       	pop	r11
    1c12:	af 90       	pop	r10
    1c14:	08 95       	ret

00001c16 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1c16:	df 93       	push	r29
    1c18:	cf 93       	push	r28
    1c1a:	cd b7       	in	r28, 0x3d	; 61
    1c1c:	de b7       	in	r29, 0x3e	; 62
    1c1e:	2a 97       	sbiw	r28, 0x0a	; 10
    1c20:	0f b6       	in	r0, 0x3f	; 63
    1c22:	f8 94       	cli
    1c24:	de bf       	out	0x3e, r29	; 62
    1c26:	0f be       	out	0x3f, r0	; 63
    1c28:	cd bf       	out	0x3d, r28	; 61
    1c2a:	9a 87       	std	Y+10, r25	; 0x0a
    1c2c:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1c2e:	1c 82       	std	Y+4, r1	; 0x04
    1c30:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1c32:	89 85       	ldd	r24, Y+9	; 0x09
    1c34:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c36:	9a 83       	std	Y+2, r25	; 0x02
    1c38:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1c3a:	8b e7       	ldi	r24, 0x7B	; 123
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	a0 e0       	ldi	r26, 0x00	; 0
    1c40:	b0 e0       	ldi	r27, 0x00	; 0
    1c42:	8d 83       	std	Y+5, r24	; 0x05
    1c44:	9e 83       	std	Y+6, r25	; 0x06
    1c46:	af 83       	std	Y+7, r26	; 0x07
    1c48:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    1c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c4e:	af 81       	ldd	r26, Y+7	; 0x07
    1c50:	b8 85       	ldd	r27, Y+8	; 0x08
    1c52:	89 5b       	subi	r24, 0xB9	; 185
    1c54:	9b 46       	sbci	r25, 0x6B	; 107
    1c56:	ac 4f       	sbci	r26, 0xFC	; 252
    1c58:	bf 4f       	sbci	r27, 0xFF	; 255
    1c5a:	8d 83       	std	Y+5, r24	; 0x05
    1c5c:	9e 83       	std	Y+6, r25	; 0x06
    1c5e:	af 83       	std	Y+7, r26	; 0x07
    1c60:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1c62:	8d 81       	ldd	r24, Y+5	; 0x05
    1c64:	9e 81       	ldd	r25, Y+6	; 0x06
    1c66:	af 81       	ldd	r26, Y+7	; 0x07
    1c68:	b8 85       	ldd	r27, Y+8	; 0x08
    1c6a:	2d ef       	ldi	r18, 0xFD	; 253
    1c6c:	3f ef       	ldi	r19, 0xFF	; 255
    1c6e:	4f ef       	ldi	r20, 0xFF	; 255
    1c70:	5f ef       	ldi	r21, 0xFF	; 255
    1c72:	bc 01       	movw	r22, r24
    1c74:	cd 01       	movw	r24, r26
    1c76:	0e 94 dd 2f 	call	0x5fba	; 0x5fba <__mulsi3>
    1c7a:	dc 01       	movw	r26, r24
    1c7c:	cb 01       	movw	r24, r22
    1c7e:	8d 83       	std	Y+5, r24	; 0x05
    1c80:	9e 83       	std	Y+6, r25	; 0x06
    1c82:	af 83       	std	Y+7, r26	; 0x07
    1c84:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    1c86:	8d 81       	ldd	r24, Y+5	; 0x05
    1c88:	9e 81       	ldd	r25, Y+6	; 0x06
    1c8a:	af 81       	ldd	r26, Y+7	; 0x07
    1c8c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c8e:	27 e0       	ldi	r18, 0x07	; 7
    1c90:	30 e0       	ldi	r19, 0x00	; 0
    1c92:	40 e0       	ldi	r20, 0x00	; 0
    1c94:	50 e0       	ldi	r21, 0x00	; 0
    1c96:	bc 01       	movw	r22, r24
    1c98:	cd 01       	movw	r24, r26
    1c9a:	0e 94 1e 30 	call	0x603c	; 0x603c <__divmodsi4>
    1c9e:	da 01       	movw	r26, r20
    1ca0:	c9 01       	movw	r24, r18
    1ca2:	8d 83       	std	Y+5, r24	; 0x05
    1ca4:	9e 83       	std	Y+6, r25	; 0x06
    1ca6:	af 83       	std	Y+7, r26	; 0x07
    1ca8:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    1caa:	8d 81       	ldd	r24, Y+5	; 0x05
    1cac:	9e 81       	ldd	r25, Y+6	; 0x06
    1cae:	af 81       	ldd	r26, Y+7	; 0x07
    1cb0:	b8 85       	ldd	r27, Y+8	; 0x08
    1cb2:	8b 31       	cpi	r24, 0x1B	; 27
    1cb4:	27 e7       	ldi	r18, 0x77	; 119
    1cb6:	92 07       	cpc	r25, r18
    1cb8:	2e ef       	ldi	r18, 0xFE	; 254
    1cba:	a2 07       	cpc	r26, r18
    1cbc:	2f ef       	ldi	r18, 0xFF	; 255
    1cbe:	b2 07       	cpc	r27, r18
    1cc0:	21 f0       	breq	.+8      	; 0x1cca <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	9c 83       	std	Y+4, r25	; 0x04
    1cc8:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    1cca:	8b 81       	ldd	r24, Y+3	; 0x03
    1ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cce:	00 97       	sbiw	r24, 0x00	; 0
    1cd0:	09 f0       	breq	.+2      	; 0x1cd4 <vCompeteingIntMathTask+0xbe>
    1cd2:	b3 cf       	rjmp	.-154    	; 0x1c3a <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	a9 cf       	rjmp	.-174    	; 0x1c3a <vCompeteingIntMathTask+0x24>

00001ce8 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    1ce8:	df 93       	push	r29
    1cea:	cf 93       	push	r28
    1cec:	00 d0       	rcall	.+0      	; 0x1cee <xAreIntegerMathsTaskStillRunning+0x6>
    1cee:	0f 92       	push	r0
    1cf0:	cd b7       	in	r28, 0x3d	; 61
    1cf2:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1cf8:	1a 82       	std	Y+2, r1	; 0x02
    1cfa:	19 82       	std	Y+1, r1	; 0x01
    1cfc:	14 c0       	rjmp	.+40     	; 0x1d26 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    1cfe:	89 81       	ldd	r24, Y+1	; 0x01
    1d00:	9a 81       	ldd	r25, Y+2	; 0x02
    1d02:	fc 01       	movw	r30, r24
    1d04:	ea 56       	subi	r30, 0x6A	; 106
    1d06:	fa 4f       	sbci	r31, 0xFA	; 250
    1d08:	80 81       	ld	r24, Z
    1d0a:	88 23       	and	r24, r24
    1d0c:	09 f4       	brne	.+2      	; 0x1d10 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1d0e:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	9a 81       	ldd	r25, Y+2	; 0x02
    1d14:	fc 01       	movw	r30, r24
    1d16:	ea 56       	subi	r30, 0x6A	; 106
    1d18:	fa 4f       	sbci	r31, 0xFA	; 250
    1d1a:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d20:	01 96       	adiw	r24, 0x01	; 1
    1d22:	9a 83       	std	Y+2, r25	; 0x02
    1d24:	89 83       	std	Y+1, r24	; 0x01
    1d26:	89 81       	ldd	r24, Y+1	; 0x01
    1d28:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2a:	18 16       	cp	r1, r24
    1d2c:	19 06       	cpc	r1, r25
    1d2e:	3c f7       	brge	.-50     	; 0x1cfe <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1d30:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1d32:	0f 90       	pop	r0
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	cf 91       	pop	r28
    1d3a:	df 91       	pop	r29
    1d3c:	08 95       	ret

00001d3e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1d3e:	df 93       	push	r29
    1d40:	cf 93       	push	r28
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <vListInitialise+0x6>
    1d44:	cd b7       	in	r28, 0x3d	; 61
    1d46:	de b7       	in	r29, 0x3e	; 62
    1d48:	9a 83       	std	Y+2, r25	; 0x02
    1d4a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d50:	03 96       	adiw	r24, 0x03	; 3
    1d52:	e9 81       	ldd	r30, Y+1	; 0x01
    1d54:	fa 81       	ldd	r31, Y+2	; 0x02
    1d56:	92 83       	std	Z+2, r25	; 0x02
    1d58:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5e:	8f ef       	ldi	r24, 0xFF	; 255
    1d60:	9f ef       	ldi	r25, 0xFF	; 255
    1d62:	94 83       	std	Z+4, r25	; 0x04
    1d64:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d66:	89 81       	ldd	r24, Y+1	; 0x01
    1d68:	9a 81       	ldd	r25, Y+2	; 0x02
    1d6a:	03 96       	adiw	r24, 0x03	; 3
    1d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d70:	96 83       	std	Z+6, r25	; 0x06
    1d72:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d74:	89 81       	ldd	r24, Y+1	; 0x01
    1d76:	9a 81       	ldd	r25, Y+2	; 0x02
    1d78:	03 96       	adiw	r24, 0x03	; 3
    1d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7e:	90 87       	std	Z+8, r25	; 0x08
    1d80:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1d82:	e9 81       	ldd	r30, Y+1	; 0x01
    1d84:	fa 81       	ldd	r31, Y+2	; 0x02
    1d86:	10 82       	st	Z, r1
}
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	cf 91       	pop	r28
    1d8e:	df 91       	pop	r29
    1d90:	08 95       	ret

00001d92 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1d92:	df 93       	push	r29
    1d94:	cf 93       	push	r28
    1d96:	00 d0       	rcall	.+0      	; 0x1d98 <vListInitialiseItem+0x6>
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
    1d9c:	9a 83       	std	Y+2, r25	; 0x02
    1d9e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1da0:	e9 81       	ldd	r30, Y+1	; 0x01
    1da2:	fa 81       	ldd	r31, Y+2	; 0x02
    1da4:	11 86       	std	Z+9, r1	; 0x09
    1da6:	10 86       	std	Z+8, r1	; 0x08
}
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	cf 91       	pop	r28
    1dae:	df 91       	pop	r29
    1db0:	08 95       	ret

00001db2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1db2:	df 93       	push	r29
    1db4:	cf 93       	push	r28
    1db6:	00 d0       	rcall	.+0      	; 0x1db8 <vListInsertEnd+0x6>
    1db8:	00 d0       	rcall	.+0      	; 0x1dba <vListInsertEnd+0x8>
    1dba:	00 d0       	rcall	.+0      	; 0x1dbc <vListInsertEnd+0xa>
    1dbc:	cd b7       	in	r28, 0x3d	; 61
    1dbe:	de b7       	in	r29, 0x3e	; 62
    1dc0:	9c 83       	std	Y+4, r25	; 0x04
    1dc2:	8b 83       	std	Y+3, r24	; 0x03
    1dc4:	7e 83       	std	Y+6, r23	; 0x06
    1dc6:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1dc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dca:	fc 81       	ldd	r31, Y+4	; 0x04
    1dcc:	81 81       	ldd	r24, Z+1	; 0x01
    1dce:	92 81       	ldd	r25, Z+2	; 0x02
    1dd0:	9a 83       	std	Y+2, r25	; 0x02
    1dd2:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1dd4:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd6:	fe 81       	ldd	r31, Y+6	; 0x06
    1dd8:	89 81       	ldd	r24, Y+1	; 0x01
    1dda:	9a 81       	ldd	r25, Y+2	; 0x02
    1ddc:	93 83       	std	Z+3, r25	; 0x03
    1dde:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1de0:	e9 81       	ldd	r30, Y+1	; 0x01
    1de2:	fa 81       	ldd	r31, Y+2	; 0x02
    1de4:	84 81       	ldd	r24, Z+4	; 0x04
    1de6:	95 81       	ldd	r25, Z+5	; 0x05
    1de8:	ed 81       	ldd	r30, Y+5	; 0x05
    1dea:	fe 81       	ldd	r31, Y+6	; 0x06
    1dec:	95 83       	std	Z+5, r25	; 0x05
    1dee:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1df0:	e9 81       	ldd	r30, Y+1	; 0x01
    1df2:	fa 81       	ldd	r31, Y+2	; 0x02
    1df4:	04 80       	ldd	r0, Z+4	; 0x04
    1df6:	f5 81       	ldd	r31, Z+5	; 0x05
    1df8:	e0 2d       	mov	r30, r0
    1dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    1dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    1dfe:	93 83       	std	Z+3, r25	; 0x03
    1e00:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1e02:	e9 81       	ldd	r30, Y+1	; 0x01
    1e04:	fa 81       	ldd	r31, Y+2	; 0x02
    1e06:	8d 81       	ldd	r24, Y+5	; 0x05
    1e08:	9e 81       	ldd	r25, Y+6	; 0x06
    1e0a:	95 83       	std	Z+5, r25	; 0x05
    1e0c:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1e10:	fe 81       	ldd	r31, Y+6	; 0x06
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	9c 81       	ldd	r25, Y+4	; 0x04
    1e16:	91 87       	std	Z+9, r25	; 0x09
    1e18:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1e:	80 81       	ld	r24, Z
    1e20:	8f 5f       	subi	r24, 0xFF	; 255
    1e22:	eb 81       	ldd	r30, Y+3	; 0x03
    1e24:	fc 81       	ldd	r31, Y+4	; 0x04
    1e26:	80 83       	st	Z, r24
}
    1e28:	26 96       	adiw	r28, 0x06	; 6
    1e2a:	0f b6       	in	r0, 0x3f	; 63
    1e2c:	f8 94       	cli
    1e2e:	de bf       	out	0x3e, r29	; 62
    1e30:	0f be       	out	0x3f, r0	; 63
    1e32:	cd bf       	out	0x3d, r28	; 61
    1e34:	cf 91       	pop	r28
    1e36:	df 91       	pop	r29
    1e38:	08 95       	ret

00001e3a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1e3a:	df 93       	push	r29
    1e3c:	cf 93       	push	r28
    1e3e:	cd b7       	in	r28, 0x3d	; 61
    1e40:	de b7       	in	r29, 0x3e	; 62
    1e42:	28 97       	sbiw	r28, 0x08	; 8
    1e44:	0f b6       	in	r0, 0x3f	; 63
    1e46:	f8 94       	cli
    1e48:	de bf       	out	0x3e, r29	; 62
    1e4a:	0f be       	out	0x3f, r0	; 63
    1e4c:	cd bf       	out	0x3d, r28	; 61
    1e4e:	9e 83       	std	Y+6, r25	; 0x06
    1e50:	8d 83       	std	Y+5, r24	; 0x05
    1e52:	78 87       	std	Y+8, r23	; 0x08
    1e54:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1e56:	ef 81       	ldd	r30, Y+7	; 0x07
    1e58:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5a:	80 81       	ld	r24, Z
    1e5c:	91 81       	ldd	r25, Z+1	; 0x01
    1e5e:	9a 83       	std	Y+2, r25	; 0x02
    1e60:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1e62:	89 81       	ldd	r24, Y+1	; 0x01
    1e64:	9a 81       	ldd	r25, Y+2	; 0x02
    1e66:	2f ef       	ldi	r18, 0xFF	; 255
    1e68:	8f 3f       	cpi	r24, 0xFF	; 255
    1e6a:	92 07       	cpc	r25, r18
    1e6c:	39 f4       	brne	.+14     	; 0x1e7c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1e6e:	ed 81       	ldd	r30, Y+5	; 0x05
    1e70:	fe 81       	ldd	r31, Y+6	; 0x06
    1e72:	87 81       	ldd	r24, Z+7	; 0x07
    1e74:	90 85       	ldd	r25, Z+8	; 0x08
    1e76:	9c 83       	std	Y+4, r25	; 0x04
    1e78:	8b 83       	std	Y+3, r24	; 0x03
    1e7a:	18 c0       	rjmp	.+48     	; 0x1eac <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e80:	03 96       	adiw	r24, 0x03	; 3
    1e82:	9c 83       	std	Y+4, r25	; 0x04
    1e84:	8b 83       	std	Y+3, r24	; 0x03
    1e86:	06 c0       	rjmp	.+12     	; 0x1e94 <vListInsert+0x5a>
    1e88:	eb 81       	ldd	r30, Y+3	; 0x03
    1e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e8c:	82 81       	ldd	r24, Z+2	; 0x02
    1e8e:	93 81       	ldd	r25, Z+3	; 0x03
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
    1e94:	eb 81       	ldd	r30, Y+3	; 0x03
    1e96:	fc 81       	ldd	r31, Y+4	; 0x04
    1e98:	02 80       	ldd	r0, Z+2	; 0x02
    1e9a:	f3 81       	ldd	r31, Z+3	; 0x03
    1e9c:	e0 2d       	mov	r30, r0
    1e9e:	20 81       	ld	r18, Z
    1ea0:	31 81       	ldd	r19, Z+1	; 0x01
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea6:	82 17       	cp	r24, r18
    1ea8:	93 07       	cpc	r25, r19
    1eaa:	70 f7       	brcc	.-36     	; 0x1e88 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1eac:	eb 81       	ldd	r30, Y+3	; 0x03
    1eae:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb0:	82 81       	ldd	r24, Z+2	; 0x02
    1eb2:	93 81       	ldd	r25, Z+3	; 0x03
    1eb4:	ef 81       	ldd	r30, Y+7	; 0x07
    1eb6:	f8 85       	ldd	r31, Y+8	; 0x08
    1eb8:	93 83       	std	Z+3, r25	; 0x03
    1eba:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1ebc:	ef 81       	ldd	r30, Y+7	; 0x07
    1ebe:	f8 85       	ldd	r31, Y+8	; 0x08
    1ec0:	02 80       	ldd	r0, Z+2	; 0x02
    1ec2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ec4:	e0 2d       	mov	r30, r0
    1ec6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ec8:	98 85       	ldd	r25, Y+8	; 0x08
    1eca:	95 83       	std	Z+5, r25	; 0x05
    1ecc:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1ece:	ef 81       	ldd	r30, Y+7	; 0x07
    1ed0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed6:	95 83       	std	Z+5, r25	; 0x05
    1ed8:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1eda:	eb 81       	ldd	r30, Y+3	; 0x03
    1edc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ede:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee0:	98 85       	ldd	r25, Y+8	; 0x08
    1ee2:	93 83       	std	Z+3, r25	; 0x03
    1ee4:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ee6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eea:	8d 81       	ldd	r24, Y+5	; 0x05
    1eec:	9e 81       	ldd	r25, Y+6	; 0x06
    1eee:	91 87       	std	Z+9, r25	; 0x09
    1ef0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1ef2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ef4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ef6:	80 81       	ld	r24, Z
    1ef8:	8f 5f       	subi	r24, 0xFF	; 255
    1efa:	ed 81       	ldd	r30, Y+5	; 0x05
    1efc:	fe 81       	ldd	r31, Y+6	; 0x06
    1efe:	80 83       	st	Z, r24
}
    1f00:	28 96       	adiw	r28, 0x08	; 8
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	f8 94       	cli
    1f06:	de bf       	out	0x3e, r29	; 62
    1f08:	0f be       	out	0x3f, r0	; 63
    1f0a:	cd bf       	out	0x3d, r28	; 61
    1f0c:	cf 91       	pop	r28
    1f0e:	df 91       	pop	r29
    1f10:	08 95       	ret

00001f12 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1f12:	df 93       	push	r29
    1f14:	cf 93       	push	r28
    1f16:	00 d0       	rcall	.+0      	; 0x1f18 <uxListRemove+0x6>
    1f18:	00 d0       	rcall	.+0      	; 0x1f1a <uxListRemove+0x8>
    1f1a:	cd b7       	in	r28, 0x3d	; 61
    1f1c:	de b7       	in	r29, 0x3e	; 62
    1f1e:	9c 83       	std	Y+4, r25	; 0x04
    1f20:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1f22:	eb 81       	ldd	r30, Y+3	; 0x03
    1f24:	fc 81       	ldd	r31, Y+4	; 0x04
    1f26:	80 85       	ldd	r24, Z+8	; 0x08
    1f28:	91 85       	ldd	r25, Z+9	; 0x09
    1f2a:	9a 83       	std	Y+2, r25	; 0x02
    1f2c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f30:	fc 81       	ldd	r31, Y+4	; 0x04
    1f32:	a2 81       	ldd	r26, Z+2	; 0x02
    1f34:	b3 81       	ldd	r27, Z+3	; 0x03
    1f36:	eb 81       	ldd	r30, Y+3	; 0x03
    1f38:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3a:	84 81       	ldd	r24, Z+4	; 0x04
    1f3c:	95 81       	ldd	r25, Z+5	; 0x05
    1f3e:	15 96       	adiw	r26, 0x05	; 5
    1f40:	9c 93       	st	X, r25
    1f42:	8e 93       	st	-X, r24
    1f44:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f46:	eb 81       	ldd	r30, Y+3	; 0x03
    1f48:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4a:	a4 81       	ldd	r26, Z+4	; 0x04
    1f4c:	b5 81       	ldd	r27, Z+5	; 0x05
    1f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f50:	fc 81       	ldd	r31, Y+4	; 0x04
    1f52:	82 81       	ldd	r24, Z+2	; 0x02
    1f54:	93 81       	ldd	r25, Z+3	; 0x03
    1f56:	13 96       	adiw	r26, 0x03	; 3
    1f58:	9c 93       	st	X, r25
    1f5a:	8e 93       	st	-X, r24
    1f5c:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f60:	fa 81       	ldd	r31, Y+2	; 0x02
    1f62:	21 81       	ldd	r18, Z+1	; 0x01
    1f64:	32 81       	ldd	r19, Z+2	; 0x02
    1f66:	8b 81       	ldd	r24, Y+3	; 0x03
    1f68:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6a:	28 17       	cp	r18, r24
    1f6c:	39 07       	cpc	r19, r25
    1f6e:	41 f4       	brne	.+16     	; 0x1f80 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f70:	eb 81       	ldd	r30, Y+3	; 0x03
    1f72:	fc 81       	ldd	r31, Y+4	; 0x04
    1f74:	84 81       	ldd	r24, Z+4	; 0x04
    1f76:	95 81       	ldd	r25, Z+5	; 0x05
    1f78:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f7c:	92 83       	std	Z+2, r25	; 0x02
    1f7e:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1f80:	eb 81       	ldd	r30, Y+3	; 0x03
    1f82:	fc 81       	ldd	r31, Y+4	; 0x04
    1f84:	11 86       	std	Z+9, r1	; 0x09
    1f86:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1f88:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8c:	80 81       	ld	r24, Z
    1f8e:	81 50       	subi	r24, 0x01	; 1
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1f96:	e9 81       	ldd	r30, Y+1	; 0x01
    1f98:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9a:	80 81       	ld	r24, Z
}
    1f9c:	0f 90       	pop	r0
    1f9e:	0f 90       	pop	r0
    1fa0:	0f 90       	pop	r0
    1fa2:	0f 90       	pop	r0
    1fa4:	cf 91       	pop	r28
    1fa6:	df 91       	pop	r29
    1fa8:	08 95       	ret

00001faa <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1faa:	df 93       	push	r29
    1fac:	cf 93       	push	r28
    1fae:	cd b7       	in	r28, 0x3d	; 61
    1fb0:	de b7       	in	r29, 0x3e	; 62
    1fb2:	28 97       	sbiw	r28, 0x08	; 8
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	de bf       	out	0x3e, r29	; 62
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	cd bf       	out	0x3d, r28	; 61
    1fbe:	9c 83       	std	Y+4, r25	; 0x04
    1fc0:	8b 83       	std	Y+3, r24	; 0x03
    1fc2:	7e 83       	std	Y+6, r23	; 0x06
    1fc4:	6d 83       	std	Y+5, r22	; 0x05
    1fc6:	58 87       	std	Y+8, r21	; 0x08
    1fc8:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1fca:	eb 81       	ldd	r30, Y+3	; 0x03
    1fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fce:	81 e1       	ldi	r24, 0x11	; 17
    1fd0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	01 97       	sbiw	r24, 0x01	; 1
    1fd8:	9c 83       	std	Y+4, r25	; 0x04
    1fda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1fdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fde:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe0:	82 e2       	ldi	r24, 0x22	; 34
    1fe2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe8:	01 97       	sbiw	r24, 0x01	; 1
    1fea:	9c 83       	std	Y+4, r25	; 0x04
    1fec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1fee:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff2:	83 e3       	ldi	r24, 0x33	; 51
    1ff4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffa:	01 97       	sbiw	r24, 0x01	; 1
    1ffc:	9c 83       	std	Y+4, r25	; 0x04
    1ffe:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2000:	8d 81       	ldd	r24, Y+5	; 0x05
    2002:	9e 81       	ldd	r25, Y+6	; 0x06
    2004:	9a 83       	std	Y+2, r25	; 0x02
    2006:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2008:	89 81       	ldd	r24, Y+1	; 0x01
    200a:	eb 81       	ldd	r30, Y+3	; 0x03
    200c:	fc 81       	ldd	r31, Y+4	; 0x04
    200e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2010:	8b 81       	ldd	r24, Y+3	; 0x03
    2012:	9c 81       	ldd	r25, Y+4	; 0x04
    2014:	01 97       	sbiw	r24, 0x01	; 1
    2016:	9c 83       	std	Y+4, r25	; 0x04
    2018:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	9a 81       	ldd	r25, Y+2	; 0x02
    201e:	89 2f       	mov	r24, r25
    2020:	99 27       	eor	r25, r25
    2022:	9a 83       	std	Y+2, r25	; 0x02
    2024:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2026:	89 81       	ldd	r24, Y+1	; 0x01
    2028:	eb 81       	ldd	r30, Y+3	; 0x03
    202a:	fc 81       	ldd	r31, Y+4	; 0x04
    202c:	80 83       	st	Z, r24
	pxTopOfStack--;
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	9c 81       	ldd	r25, Y+4	; 0x04
    2032:	01 97       	sbiw	r24, 0x01	; 1
    2034:	9c 83       	std	Y+4, r25	; 0x04
    2036:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2038:	eb 81       	ldd	r30, Y+3	; 0x03
    203a:	fc 81       	ldd	r31, Y+4	; 0x04
    203c:	10 82       	st	Z, r1
	pxTopOfStack--;
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	9c 81       	ldd	r25, Y+4	; 0x04
    2042:	01 97       	sbiw	r24, 0x01	; 1
    2044:	9c 83       	std	Y+4, r25	; 0x04
    2046:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2048:	eb 81       	ldd	r30, Y+3	; 0x03
    204a:	fc 81       	ldd	r31, Y+4	; 0x04
    204c:	80 e8       	ldi	r24, 0x80	; 128
    204e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
    2052:	9c 81       	ldd	r25, Y+4	; 0x04
    2054:	01 97       	sbiw	r24, 0x01	; 1
    2056:	9c 83       	std	Y+4, r25	; 0x04
    2058:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    205a:	eb 81       	ldd	r30, Y+3	; 0x03
    205c:	fc 81       	ldd	r31, Y+4	; 0x04
    205e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2060:	8b 81       	ldd	r24, Y+3	; 0x03
    2062:	9c 81       	ldd	r25, Y+4	; 0x04
    2064:	01 97       	sbiw	r24, 0x01	; 1
    2066:	9c 83       	std	Y+4, r25	; 0x04
    2068:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    206a:	eb 81       	ldd	r30, Y+3	; 0x03
    206c:	fc 81       	ldd	r31, Y+4	; 0x04
    206e:	82 e0       	ldi	r24, 0x02	; 2
    2070:	80 83       	st	Z, r24
	pxTopOfStack--;
    2072:	8b 81       	ldd	r24, Y+3	; 0x03
    2074:	9c 81       	ldd	r25, Y+4	; 0x04
    2076:	01 97       	sbiw	r24, 0x01	; 1
    2078:	9c 83       	std	Y+4, r25	; 0x04
    207a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    207c:	eb 81       	ldd	r30, Y+3	; 0x03
    207e:	fc 81       	ldd	r31, Y+4	; 0x04
    2080:	83 e0       	ldi	r24, 0x03	; 3
    2082:	80 83       	st	Z, r24
	pxTopOfStack--;
    2084:	8b 81       	ldd	r24, Y+3	; 0x03
    2086:	9c 81       	ldd	r25, Y+4	; 0x04
    2088:	01 97       	sbiw	r24, 0x01	; 1
    208a:	9c 83       	std	Y+4, r25	; 0x04
    208c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    208e:	eb 81       	ldd	r30, Y+3	; 0x03
    2090:	fc 81       	ldd	r31, Y+4	; 0x04
    2092:	84 e0       	ldi	r24, 0x04	; 4
    2094:	80 83       	st	Z, r24
	pxTopOfStack--;
    2096:	8b 81       	ldd	r24, Y+3	; 0x03
    2098:	9c 81       	ldd	r25, Y+4	; 0x04
    209a:	01 97       	sbiw	r24, 0x01	; 1
    209c:	9c 83       	std	Y+4, r25	; 0x04
    209e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    20a0:	eb 81       	ldd	r30, Y+3	; 0x03
    20a2:	fc 81       	ldd	r31, Y+4	; 0x04
    20a4:	85 e0       	ldi	r24, 0x05	; 5
    20a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    20a8:	8b 81       	ldd	r24, Y+3	; 0x03
    20aa:	9c 81       	ldd	r25, Y+4	; 0x04
    20ac:	01 97       	sbiw	r24, 0x01	; 1
    20ae:	9c 83       	std	Y+4, r25	; 0x04
    20b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    20b2:	eb 81       	ldd	r30, Y+3	; 0x03
    20b4:	fc 81       	ldd	r31, Y+4	; 0x04
    20b6:	86 e0       	ldi	r24, 0x06	; 6
    20b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ba:	8b 81       	ldd	r24, Y+3	; 0x03
    20bc:	9c 81       	ldd	r25, Y+4	; 0x04
    20be:	01 97       	sbiw	r24, 0x01	; 1
    20c0:	9c 83       	std	Y+4, r25	; 0x04
    20c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    20c4:	eb 81       	ldd	r30, Y+3	; 0x03
    20c6:	fc 81       	ldd	r31, Y+4	; 0x04
    20c8:	87 e0       	ldi	r24, 0x07	; 7
    20ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    20cc:	8b 81       	ldd	r24, Y+3	; 0x03
    20ce:	9c 81       	ldd	r25, Y+4	; 0x04
    20d0:	01 97       	sbiw	r24, 0x01	; 1
    20d2:	9c 83       	std	Y+4, r25	; 0x04
    20d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	88 e0       	ldi	r24, 0x08	; 8
    20dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    20de:	8b 81       	ldd	r24, Y+3	; 0x03
    20e0:	9c 81       	ldd	r25, Y+4	; 0x04
    20e2:	01 97       	sbiw	r24, 0x01	; 1
    20e4:	9c 83       	std	Y+4, r25	; 0x04
    20e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	89 e0       	ldi	r24, 0x09	; 9
    20ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	9c 81       	ldd	r25, Y+4	; 0x04
    20f4:	01 97       	sbiw	r24, 0x01	; 1
    20f6:	9c 83       	std	Y+4, r25	; 0x04
    20f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    20fa:	eb 81       	ldd	r30, Y+3	; 0x03
    20fc:	fc 81       	ldd	r31, Y+4	; 0x04
    20fe:	80 e1       	ldi	r24, 0x10	; 16
    2100:	80 83       	st	Z, r24
	pxTopOfStack--;
    2102:	8b 81       	ldd	r24, Y+3	; 0x03
    2104:	9c 81       	ldd	r25, Y+4	; 0x04
    2106:	01 97       	sbiw	r24, 0x01	; 1
    2108:	9c 83       	std	Y+4, r25	; 0x04
    210a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    210c:	eb 81       	ldd	r30, Y+3	; 0x03
    210e:	fc 81       	ldd	r31, Y+4	; 0x04
    2110:	81 e1       	ldi	r24, 0x11	; 17
    2112:	80 83       	st	Z, r24
	pxTopOfStack--;
    2114:	8b 81       	ldd	r24, Y+3	; 0x03
    2116:	9c 81       	ldd	r25, Y+4	; 0x04
    2118:	01 97       	sbiw	r24, 0x01	; 1
    211a:	9c 83       	std	Y+4, r25	; 0x04
    211c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    211e:	eb 81       	ldd	r30, Y+3	; 0x03
    2120:	fc 81       	ldd	r31, Y+4	; 0x04
    2122:	82 e1       	ldi	r24, 0x12	; 18
    2124:	80 83       	st	Z, r24
	pxTopOfStack--;
    2126:	8b 81       	ldd	r24, Y+3	; 0x03
    2128:	9c 81       	ldd	r25, Y+4	; 0x04
    212a:	01 97       	sbiw	r24, 0x01	; 1
    212c:	9c 83       	std	Y+4, r25	; 0x04
    212e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2130:	eb 81       	ldd	r30, Y+3	; 0x03
    2132:	fc 81       	ldd	r31, Y+4	; 0x04
    2134:	83 e1       	ldi	r24, 0x13	; 19
    2136:	80 83       	st	Z, r24
	pxTopOfStack--;
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	01 97       	sbiw	r24, 0x01	; 1
    213e:	9c 83       	std	Y+4, r25	; 0x04
    2140:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2142:	eb 81       	ldd	r30, Y+3	; 0x03
    2144:	fc 81       	ldd	r31, Y+4	; 0x04
    2146:	84 e1       	ldi	r24, 0x14	; 20
    2148:	80 83       	st	Z, r24
	pxTopOfStack--;
    214a:	8b 81       	ldd	r24, Y+3	; 0x03
    214c:	9c 81       	ldd	r25, Y+4	; 0x04
    214e:	01 97       	sbiw	r24, 0x01	; 1
    2150:	9c 83       	std	Y+4, r25	; 0x04
    2152:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2154:	eb 81       	ldd	r30, Y+3	; 0x03
    2156:	fc 81       	ldd	r31, Y+4	; 0x04
    2158:	85 e1       	ldi	r24, 0x15	; 21
    215a:	80 83       	st	Z, r24
	pxTopOfStack--;
    215c:	8b 81       	ldd	r24, Y+3	; 0x03
    215e:	9c 81       	ldd	r25, Y+4	; 0x04
    2160:	01 97       	sbiw	r24, 0x01	; 1
    2162:	9c 83       	std	Y+4, r25	; 0x04
    2164:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2166:	eb 81       	ldd	r30, Y+3	; 0x03
    2168:	fc 81       	ldd	r31, Y+4	; 0x04
    216a:	86 e1       	ldi	r24, 0x16	; 22
    216c:	80 83       	st	Z, r24
	pxTopOfStack--;
    216e:	8b 81       	ldd	r24, Y+3	; 0x03
    2170:	9c 81       	ldd	r25, Y+4	; 0x04
    2172:	01 97       	sbiw	r24, 0x01	; 1
    2174:	9c 83       	std	Y+4, r25	; 0x04
    2176:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2178:	eb 81       	ldd	r30, Y+3	; 0x03
    217a:	fc 81       	ldd	r31, Y+4	; 0x04
    217c:	87 e1       	ldi	r24, 0x17	; 23
    217e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2180:	8b 81       	ldd	r24, Y+3	; 0x03
    2182:	9c 81       	ldd	r25, Y+4	; 0x04
    2184:	01 97       	sbiw	r24, 0x01	; 1
    2186:	9c 83       	std	Y+4, r25	; 0x04
    2188:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    218a:	eb 81       	ldd	r30, Y+3	; 0x03
    218c:	fc 81       	ldd	r31, Y+4	; 0x04
    218e:	88 e1       	ldi	r24, 0x18	; 24
    2190:	80 83       	st	Z, r24
	pxTopOfStack--;
    2192:	8b 81       	ldd	r24, Y+3	; 0x03
    2194:	9c 81       	ldd	r25, Y+4	; 0x04
    2196:	01 97       	sbiw	r24, 0x01	; 1
    2198:	9c 83       	std	Y+4, r25	; 0x04
    219a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    219c:	eb 81       	ldd	r30, Y+3	; 0x03
    219e:	fc 81       	ldd	r31, Y+4	; 0x04
    21a0:	89 e1       	ldi	r24, 0x19	; 25
    21a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    21a4:	8b 81       	ldd	r24, Y+3	; 0x03
    21a6:	9c 81       	ldd	r25, Y+4	; 0x04
    21a8:	01 97       	sbiw	r24, 0x01	; 1
    21aa:	9c 83       	std	Y+4, r25	; 0x04
    21ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    21ae:	eb 81       	ldd	r30, Y+3	; 0x03
    21b0:	fc 81       	ldd	r31, Y+4	; 0x04
    21b2:	80 e2       	ldi	r24, 0x20	; 32
    21b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    21b6:	8b 81       	ldd	r24, Y+3	; 0x03
    21b8:	9c 81       	ldd	r25, Y+4	; 0x04
    21ba:	01 97       	sbiw	r24, 0x01	; 1
    21bc:	9c 83       	std	Y+4, r25	; 0x04
    21be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    21c0:	eb 81       	ldd	r30, Y+3	; 0x03
    21c2:	fc 81       	ldd	r31, Y+4	; 0x04
    21c4:	81 e2       	ldi	r24, 0x21	; 33
    21c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    21c8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ca:	9c 81       	ldd	r25, Y+4	; 0x04
    21cc:	01 97       	sbiw	r24, 0x01	; 1
    21ce:	9c 83       	std	Y+4, r25	; 0x04
    21d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    21d2:	eb 81       	ldd	r30, Y+3	; 0x03
    21d4:	fc 81       	ldd	r31, Y+4	; 0x04
    21d6:	82 e2       	ldi	r24, 0x22	; 34
    21d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    21da:	8b 81       	ldd	r24, Y+3	; 0x03
    21dc:	9c 81       	ldd	r25, Y+4	; 0x04
    21de:	01 97       	sbiw	r24, 0x01	; 1
    21e0:	9c 83       	std	Y+4, r25	; 0x04
    21e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    21e4:	eb 81       	ldd	r30, Y+3	; 0x03
    21e6:	fc 81       	ldd	r31, Y+4	; 0x04
    21e8:	83 e2       	ldi	r24, 0x23	; 35
    21ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	9c 81       	ldd	r25, Y+4	; 0x04
    21f0:	01 97       	sbiw	r24, 0x01	; 1
    21f2:	9c 83       	std	Y+4, r25	; 0x04
    21f4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    21f6:	8f 81       	ldd	r24, Y+7	; 0x07
    21f8:	98 85       	ldd	r25, Y+8	; 0x08
    21fa:	9a 83       	std	Y+2, r25	; 0x02
    21fc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21fe:	89 81       	ldd	r24, Y+1	; 0x01
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	80 83       	st	Z, r24
	pxTopOfStack--;
    2206:	8b 81       	ldd	r24, Y+3	; 0x03
    2208:	9c 81       	ldd	r25, Y+4	; 0x04
    220a:	01 97       	sbiw	r24, 0x01	; 1
    220c:	9c 83       	std	Y+4, r25	; 0x04
    220e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2210:	89 81       	ldd	r24, Y+1	; 0x01
    2212:	9a 81       	ldd	r25, Y+2	; 0x02
    2214:	89 2f       	mov	r24, r25
    2216:	99 27       	eor	r25, r25
    2218:	9a 83       	std	Y+2, r25	; 0x02
    221a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    221c:	89 81       	ldd	r24, Y+1	; 0x01
    221e:	eb 81       	ldd	r30, Y+3	; 0x03
    2220:	fc 81       	ldd	r31, Y+4	; 0x04
    2222:	80 83       	st	Z, r24
	pxTopOfStack--;
    2224:	8b 81       	ldd	r24, Y+3	; 0x03
    2226:	9c 81       	ldd	r25, Y+4	; 0x04
    2228:	01 97       	sbiw	r24, 0x01	; 1
    222a:	9c 83       	std	Y+4, r25	; 0x04
    222c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    222e:	eb 81       	ldd	r30, Y+3	; 0x03
    2230:	fc 81       	ldd	r31, Y+4	; 0x04
    2232:	86 e2       	ldi	r24, 0x26	; 38
    2234:	80 83       	st	Z, r24
	pxTopOfStack--;
    2236:	8b 81       	ldd	r24, Y+3	; 0x03
    2238:	9c 81       	ldd	r25, Y+4	; 0x04
    223a:	01 97       	sbiw	r24, 0x01	; 1
    223c:	9c 83       	std	Y+4, r25	; 0x04
    223e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2240:	eb 81       	ldd	r30, Y+3	; 0x03
    2242:	fc 81       	ldd	r31, Y+4	; 0x04
    2244:	87 e2       	ldi	r24, 0x27	; 39
    2246:	80 83       	st	Z, r24
	pxTopOfStack--;
    2248:	8b 81       	ldd	r24, Y+3	; 0x03
    224a:	9c 81       	ldd	r25, Y+4	; 0x04
    224c:	01 97       	sbiw	r24, 0x01	; 1
    224e:	9c 83       	std	Y+4, r25	; 0x04
    2250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2252:	eb 81       	ldd	r30, Y+3	; 0x03
    2254:	fc 81       	ldd	r31, Y+4	; 0x04
    2256:	88 e2       	ldi	r24, 0x28	; 40
    2258:	80 83       	st	Z, r24
	pxTopOfStack--;
    225a:	8b 81       	ldd	r24, Y+3	; 0x03
    225c:	9c 81       	ldd	r25, Y+4	; 0x04
    225e:	01 97       	sbiw	r24, 0x01	; 1
    2260:	9c 83       	std	Y+4, r25	; 0x04
    2262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2264:	eb 81       	ldd	r30, Y+3	; 0x03
    2266:	fc 81       	ldd	r31, Y+4	; 0x04
    2268:	89 e2       	ldi	r24, 0x29	; 41
    226a:	80 83       	st	Z, r24
	pxTopOfStack--;
    226c:	8b 81       	ldd	r24, Y+3	; 0x03
    226e:	9c 81       	ldd	r25, Y+4	; 0x04
    2270:	01 97       	sbiw	r24, 0x01	; 1
    2272:	9c 83       	std	Y+4, r25	; 0x04
    2274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2276:	eb 81       	ldd	r30, Y+3	; 0x03
    2278:	fc 81       	ldd	r31, Y+4	; 0x04
    227a:	80 e3       	ldi	r24, 0x30	; 48
    227c:	80 83       	st	Z, r24
	pxTopOfStack--;
    227e:	8b 81       	ldd	r24, Y+3	; 0x03
    2280:	9c 81       	ldd	r25, Y+4	; 0x04
    2282:	01 97       	sbiw	r24, 0x01	; 1
    2284:	9c 83       	std	Y+4, r25	; 0x04
    2286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2288:	eb 81       	ldd	r30, Y+3	; 0x03
    228a:	fc 81       	ldd	r31, Y+4	; 0x04
    228c:	81 e3       	ldi	r24, 0x31	; 49
    228e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2290:	8b 81       	ldd	r24, Y+3	; 0x03
    2292:	9c 81       	ldd	r25, Y+4	; 0x04
    2294:	01 97       	sbiw	r24, 0x01	; 1
    2296:	9c 83       	std	Y+4, r25	; 0x04
    2298:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    229a:	8b 81       	ldd	r24, Y+3	; 0x03
    229c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    229e:	28 96       	adiw	r28, 0x08	; 8
    22a0:	0f b6       	in	r0, 0x3f	; 63
    22a2:	f8 94       	cli
    22a4:	de bf       	out	0x3e, r29	; 62
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	cd bf       	out	0x3d, r28	; 61
    22aa:	cf 91       	pop	r28
    22ac:	df 91       	pop	r29
    22ae:	08 95       	ret

000022b0 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    22b0:	df 93       	push	r29
    22b2:	cf 93       	push	r28
    22b4:	cd b7       	in	r28, 0x3d	; 61
    22b6:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    22b8:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    22bc:	a0 91 97 05 	lds	r26, 0x0597
    22c0:	b0 91 98 05 	lds	r27, 0x0598
    22c4:	cd 91       	ld	r28, X+
    22c6:	cd bf       	out	0x3d, r28	; 61
    22c8:	dd 91       	ld	r29, X+
    22ca:	de bf       	out	0x3e, r29	; 62
    22cc:	ff 91       	pop	r31
    22ce:	ef 91       	pop	r30
    22d0:	df 91       	pop	r29
    22d2:	cf 91       	pop	r28
    22d4:	bf 91       	pop	r27
    22d6:	af 91       	pop	r26
    22d8:	9f 91       	pop	r25
    22da:	8f 91       	pop	r24
    22dc:	7f 91       	pop	r23
    22de:	6f 91       	pop	r22
    22e0:	5f 91       	pop	r21
    22e2:	4f 91       	pop	r20
    22e4:	3f 91       	pop	r19
    22e6:	2f 91       	pop	r18
    22e8:	1f 91       	pop	r17
    22ea:	0f 91       	pop	r16
    22ec:	ff 90       	pop	r15
    22ee:	ef 90       	pop	r14
    22f0:	df 90       	pop	r13
    22f2:	cf 90       	pop	r12
    22f4:	bf 90       	pop	r11
    22f6:	af 90       	pop	r10
    22f8:	9f 90       	pop	r9
    22fa:	8f 90       	pop	r8
    22fc:	7f 90       	pop	r7
    22fe:	6f 90       	pop	r6
    2300:	5f 90       	pop	r5
    2302:	4f 90       	pop	r4
    2304:	3f 90       	pop	r3
    2306:	2f 90       	pop	r2
    2308:	1f 90       	pop	r1
    230a:	0f 90       	pop	r0
    230c:	0f be       	out	0x3f, r0	; 63
    230e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2310:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2312:	81 e0       	ldi	r24, 0x01	; 1
}
    2314:	cf 91       	pop	r28
    2316:	df 91       	pop	r29
    2318:	08 95       	ret

0000231a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    231a:	df 93       	push	r29
    231c:	cf 93       	push	r28
    231e:	cd b7       	in	r28, 0x3d	; 61
    2320:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2322:	cf 91       	pop	r28
    2324:	df 91       	pop	r29
    2326:	08 95       	ret

00002328 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2328:	0f 92       	push	r0
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	0f 92       	push	r0
    2330:	1f 92       	push	r1
    2332:	11 24       	eor	r1, r1
    2334:	2f 92       	push	r2
    2336:	3f 92       	push	r3
    2338:	4f 92       	push	r4
    233a:	5f 92       	push	r5
    233c:	6f 92       	push	r6
    233e:	7f 92       	push	r7
    2340:	8f 92       	push	r8
    2342:	9f 92       	push	r9
    2344:	af 92       	push	r10
    2346:	bf 92       	push	r11
    2348:	cf 92       	push	r12
    234a:	df 92       	push	r13
    234c:	ef 92       	push	r14
    234e:	ff 92       	push	r15
    2350:	0f 93       	push	r16
    2352:	1f 93       	push	r17
    2354:	2f 93       	push	r18
    2356:	3f 93       	push	r19
    2358:	4f 93       	push	r20
    235a:	5f 93       	push	r21
    235c:	6f 93       	push	r22
    235e:	7f 93       	push	r23
    2360:	8f 93       	push	r24
    2362:	9f 93       	push	r25
    2364:	af 93       	push	r26
    2366:	bf 93       	push	r27
    2368:	cf 93       	push	r28
    236a:	df 93       	push	r29
    236c:	ef 93       	push	r30
    236e:	ff 93       	push	r31
    2370:	a0 91 97 05 	lds	r26, 0x0597
    2374:	b0 91 98 05 	lds	r27, 0x0598
    2378:	0d b6       	in	r0, 0x3d	; 61
    237a:	0d 92       	st	X+, r0
    237c:	0e b6       	in	r0, 0x3e	; 62
    237e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2380:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2384:	a0 91 97 05 	lds	r26, 0x0597
    2388:	b0 91 98 05 	lds	r27, 0x0598
    238c:	cd 91       	ld	r28, X+
    238e:	cd bf       	out	0x3d, r28	; 61
    2390:	dd 91       	ld	r29, X+
    2392:	de bf       	out	0x3e, r29	; 62
    2394:	ff 91       	pop	r31
    2396:	ef 91       	pop	r30
    2398:	df 91       	pop	r29
    239a:	cf 91       	pop	r28
    239c:	bf 91       	pop	r27
    239e:	af 91       	pop	r26
    23a0:	9f 91       	pop	r25
    23a2:	8f 91       	pop	r24
    23a4:	7f 91       	pop	r23
    23a6:	6f 91       	pop	r22
    23a8:	5f 91       	pop	r21
    23aa:	4f 91       	pop	r20
    23ac:	3f 91       	pop	r19
    23ae:	2f 91       	pop	r18
    23b0:	1f 91       	pop	r17
    23b2:	0f 91       	pop	r16
    23b4:	ff 90       	pop	r15
    23b6:	ef 90       	pop	r14
    23b8:	df 90       	pop	r13
    23ba:	cf 90       	pop	r12
    23bc:	bf 90       	pop	r11
    23be:	af 90       	pop	r10
    23c0:	9f 90       	pop	r9
    23c2:	8f 90       	pop	r8
    23c4:	7f 90       	pop	r7
    23c6:	6f 90       	pop	r6
    23c8:	5f 90       	pop	r5
    23ca:	4f 90       	pop	r4
    23cc:	3f 90       	pop	r3
    23ce:	2f 90       	pop	r2
    23d0:	1f 90       	pop	r1
    23d2:	0f 90       	pop	r0
    23d4:	0f be       	out	0x3f, r0	; 63
    23d6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23d8:	08 95       	ret

000023da <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    23da:	0f 92       	push	r0
    23dc:	0f b6       	in	r0, 0x3f	; 63
    23de:	f8 94       	cli
    23e0:	0f 92       	push	r0
    23e2:	1f 92       	push	r1
    23e4:	11 24       	eor	r1, r1
    23e6:	2f 92       	push	r2
    23e8:	3f 92       	push	r3
    23ea:	4f 92       	push	r4
    23ec:	5f 92       	push	r5
    23ee:	6f 92       	push	r6
    23f0:	7f 92       	push	r7
    23f2:	8f 92       	push	r8
    23f4:	9f 92       	push	r9
    23f6:	af 92       	push	r10
    23f8:	bf 92       	push	r11
    23fa:	cf 92       	push	r12
    23fc:	df 92       	push	r13
    23fe:	ef 92       	push	r14
    2400:	ff 92       	push	r15
    2402:	0f 93       	push	r16
    2404:	1f 93       	push	r17
    2406:	2f 93       	push	r18
    2408:	3f 93       	push	r19
    240a:	4f 93       	push	r20
    240c:	5f 93       	push	r21
    240e:	6f 93       	push	r22
    2410:	7f 93       	push	r23
    2412:	8f 93       	push	r24
    2414:	9f 93       	push	r25
    2416:	af 93       	push	r26
    2418:	bf 93       	push	r27
    241a:	cf 93       	push	r28
    241c:	df 93       	push	r29
    241e:	ef 93       	push	r30
    2420:	ff 93       	push	r31
    2422:	a0 91 97 05 	lds	r26, 0x0597
    2426:	b0 91 98 05 	lds	r27, 0x0598
    242a:	0d b6       	in	r0, 0x3d	; 61
    242c:	0d 92       	st	X+, r0
    242e:	0e b6       	in	r0, 0x3e	; 62
    2430:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2432:	0e 94 4e 1e 	call	0x3c9c	; 0x3c9c <xTaskIncrementTick>
    2436:	88 23       	and	r24, r24
    2438:	11 f0       	breq	.+4      	; 0x243e <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    243a:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    243e:	a0 91 97 05 	lds	r26, 0x0597
    2442:	b0 91 98 05 	lds	r27, 0x0598
    2446:	cd 91       	ld	r28, X+
    2448:	cd bf       	out	0x3d, r28	; 61
    244a:	dd 91       	ld	r29, X+
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	ff 91       	pop	r31
    2450:	ef 91       	pop	r30
    2452:	df 91       	pop	r29
    2454:	cf 91       	pop	r28
    2456:	bf 91       	pop	r27
    2458:	af 91       	pop	r26
    245a:	9f 91       	pop	r25
    245c:	8f 91       	pop	r24
    245e:	7f 91       	pop	r23
    2460:	6f 91       	pop	r22
    2462:	5f 91       	pop	r21
    2464:	4f 91       	pop	r20
    2466:	3f 91       	pop	r19
    2468:	2f 91       	pop	r18
    246a:	1f 91       	pop	r17
    246c:	0f 91       	pop	r16
    246e:	ff 90       	pop	r15
    2470:	ef 90       	pop	r14
    2472:	df 90       	pop	r13
    2474:	cf 90       	pop	r12
    2476:	bf 90       	pop	r11
    2478:	af 90       	pop	r10
    247a:	9f 90       	pop	r9
    247c:	8f 90       	pop	r8
    247e:	7f 90       	pop	r7
    2480:	6f 90       	pop	r6
    2482:	5f 90       	pop	r5
    2484:	4f 90       	pop	r4
    2486:	3f 90       	pop	r3
    2488:	2f 90       	pop	r2
    248a:	1f 90       	pop	r1
    248c:	0f 90       	pop	r0
    248e:	0f be       	out	0x3f, r0	; 63
    2490:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2492:	08 95       	ret

00002494 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2494:	df 93       	push	r29
    2496:	cf 93       	push	r28
    2498:	00 d0       	rcall	.+0      	; 0x249a <prvSetupTimerInterrupt+0x6>
    249a:	00 d0       	rcall	.+0      	; 0x249c <prvSetupTimerInterrupt+0x8>
    249c:	00 d0       	rcall	.+0      	; 0x249e <prvSetupTimerInterrupt+0xa>
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    24a2:	80 e8       	ldi	r24, 0x80	; 128
    24a4:	9e e3       	ldi	r25, 0x3E	; 62
    24a6:	a0 e0       	ldi	r26, 0x00	; 0
    24a8:	b0 e0       	ldi	r27, 0x00	; 0
    24aa:	8b 83       	std	Y+3, r24	; 0x03
    24ac:	9c 83       	std	Y+4, r25	; 0x04
    24ae:	ad 83       	std	Y+5, r26	; 0x05
    24b0:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    24b2:	8b 81       	ldd	r24, Y+3	; 0x03
    24b4:	9c 81       	ldd	r25, Y+4	; 0x04
    24b6:	ad 81       	ldd	r26, Y+5	; 0x05
    24b8:	be 81       	ldd	r27, Y+6	; 0x06
    24ba:	68 94       	set
    24bc:	15 f8       	bld	r1, 5
    24be:	b6 95       	lsr	r27
    24c0:	a7 95       	ror	r26
    24c2:	97 95       	ror	r25
    24c4:	87 95       	ror	r24
    24c6:	16 94       	lsr	r1
    24c8:	d1 f7       	brne	.-12     	; 0x24be <prvSetupTimerInterrupt+0x2a>
    24ca:	8b 83       	std	Y+3, r24	; 0x03
    24cc:	9c 83       	std	Y+4, r25	; 0x04
    24ce:	ad 83       	std	Y+5, r26	; 0x05
    24d0:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    24d2:	8b 81       	ldd	r24, Y+3	; 0x03
    24d4:	9c 81       	ldd	r25, Y+4	; 0x04
    24d6:	ad 81       	ldd	r26, Y+5	; 0x05
    24d8:	be 81       	ldd	r27, Y+6	; 0x06
    24da:	01 97       	sbiw	r24, 0x01	; 1
    24dc:	a1 09       	sbc	r26, r1
    24de:	b1 09       	sbc	r27, r1
    24e0:	8b 83       	std	Y+3, r24	; 0x03
    24e2:	9c 83       	std	Y+4, r25	; 0x04
    24e4:	ad 83       	std	Y+5, r26	; 0x05
    24e6:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    24e8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ea:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    24ec:	8b 81       	ldd	r24, Y+3	; 0x03
    24ee:	9c 81       	ldd	r25, Y+4	; 0x04
    24f0:	ad 81       	ldd	r26, Y+5	; 0x05
    24f2:	be 81       	ldd	r27, Y+6	; 0x06
    24f4:	89 2f       	mov	r24, r25
    24f6:	9a 2f       	mov	r25, r26
    24f8:	ab 2f       	mov	r26, r27
    24fa:	bb 27       	eor	r27, r27
    24fc:	8b 83       	std	Y+3, r24	; 0x03
    24fe:	9c 83       	std	Y+4, r25	; 0x04
    2500:	ad 83       	std	Y+5, r26	; 0x05
    2502:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2508:	eb e4       	ldi	r30, 0x4B	; 75
    250a:	f0 e0       	ldi	r31, 0x00	; 0
    250c:	8a 81       	ldd	r24, Y+2	; 0x02
    250e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2510:	ea e4       	ldi	r30, 0x4A	; 74
    2512:	f0 e0       	ldi	r31, 0x00	; 0
    2514:	89 81       	ldd	r24, Y+1	; 0x01
    2516:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2518:	8b e0       	ldi	r24, 0x0B	; 11
    251a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    251c:	ee e4       	ldi	r30, 0x4E	; 78
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	89 81       	ldd	r24, Y+1	; 0x01
    2522:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2524:	e9 e5       	ldi	r30, 0x59	; 89
    2526:	f0 e0       	ldi	r31, 0x00	; 0
    2528:	80 81       	ld	r24, Z
    252a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    252c:	89 81       	ldd	r24, Y+1	; 0x01
    252e:	80 61       	ori	r24, 0x10	; 16
    2530:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2532:	e9 e5       	ldi	r30, 0x59	; 89
    2534:	f0 e0       	ldi	r31, 0x00	; 0
    2536:	89 81       	ldd	r24, Y+1	; 0x01
    2538:	80 83       	st	Z, r24
}
    253a:	26 96       	adiw	r28, 0x06	; 6
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	de bf       	out	0x3e, r29	; 62
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	cd bf       	out	0x3d, r28	; 61
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    254c:	0e 94 ed 11 	call	0x23da	; 0x23da <vPortYieldFromTick>
		asm volatile ( "reti" );
    2550:	18 95       	reti

00002552 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2552:	df 93       	push	r29
    2554:	cf 93       	push	r28
    2556:	00 d0       	rcall	.+0      	; 0x2558 <xQueueGenericReset+0x6>
    2558:	00 d0       	rcall	.+0      	; 0x255a <xQueueGenericReset+0x8>
    255a:	0f 92       	push	r0
    255c:	cd b7       	in	r28, 0x3d	; 61
    255e:	de b7       	in	r29, 0x3e	; 62
    2560:	9c 83       	std	Y+4, r25	; 0x04
    2562:	8b 83       	std	Y+3, r24	; 0x03
    2564:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2566:	8b 81       	ldd	r24, Y+3	; 0x03
    2568:	9c 81       	ldd	r25, Y+4	; 0x04
    256a:	9a 83       	std	Y+2, r25	; 0x02
    256c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    256e:	0f b6       	in	r0, 0x3f	; 63
    2570:	f8 94       	cli
    2572:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2574:	e9 81       	ldd	r30, Y+1	; 0x01
    2576:	fa 81       	ldd	r31, Y+2	; 0x02
    2578:	40 81       	ld	r20, Z
    257a:	51 81       	ldd	r21, Z+1	; 0x01
    257c:	e9 81       	ldd	r30, Y+1	; 0x01
    257e:	fa 81       	ldd	r31, Y+2	; 0x02
    2580:	83 8d       	ldd	r24, Z+27	; 0x1b
    2582:	28 2f       	mov	r18, r24
    2584:	30 e0       	ldi	r19, 0x00	; 0
    2586:	e9 81       	ldd	r30, Y+1	; 0x01
    2588:	fa 81       	ldd	r31, Y+2	; 0x02
    258a:	84 8d       	ldd	r24, Z+28	; 0x1c
    258c:	88 2f       	mov	r24, r24
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	bc 01       	movw	r22, r24
    2592:	26 9f       	mul	r18, r22
    2594:	c0 01       	movw	r24, r0
    2596:	27 9f       	mul	r18, r23
    2598:	90 0d       	add	r25, r0
    259a:	36 9f       	mul	r19, r22
    259c:	90 0d       	add	r25, r0
    259e:	11 24       	eor	r1, r1
    25a0:	84 0f       	add	r24, r20
    25a2:	95 1f       	adc	r25, r21
    25a4:	e9 81       	ldd	r30, Y+1	; 0x01
    25a6:	fa 81       	ldd	r31, Y+2	; 0x02
    25a8:	93 83       	std	Z+3, r25	; 0x03
    25aa:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    25ac:	e9 81       	ldd	r30, Y+1	; 0x01
    25ae:	fa 81       	ldd	r31, Y+2	; 0x02
    25b0:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    25b2:	e9 81       	ldd	r30, Y+1	; 0x01
    25b4:	fa 81       	ldd	r31, Y+2	; 0x02
    25b6:	80 81       	ld	r24, Z
    25b8:	91 81       	ldd	r25, Z+1	; 0x01
    25ba:	e9 81       	ldd	r30, Y+1	; 0x01
    25bc:	fa 81       	ldd	r31, Y+2	; 0x02
    25be:	95 83       	std	Z+5, r25	; 0x05
    25c0:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    25c2:	e9 81       	ldd	r30, Y+1	; 0x01
    25c4:	fa 81       	ldd	r31, Y+2	; 0x02
    25c6:	40 81       	ld	r20, Z
    25c8:	51 81       	ldd	r21, Z+1	; 0x01
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    25d0:	88 2f       	mov	r24, r24
    25d2:	90 e0       	ldi	r25, 0x00	; 0
    25d4:	9c 01       	movw	r18, r24
    25d6:	21 50       	subi	r18, 0x01	; 1
    25d8:	30 40       	sbci	r19, 0x00	; 0
    25da:	e9 81       	ldd	r30, Y+1	; 0x01
    25dc:	fa 81       	ldd	r31, Y+2	; 0x02
    25de:	84 8d       	ldd	r24, Z+28	; 0x1c
    25e0:	88 2f       	mov	r24, r24
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	bc 01       	movw	r22, r24
    25e6:	26 9f       	mul	r18, r22
    25e8:	c0 01       	movw	r24, r0
    25ea:	27 9f       	mul	r18, r23
    25ec:	90 0d       	add	r25, r0
    25ee:	36 9f       	mul	r19, r22
    25f0:	90 0d       	add	r25, r0
    25f2:	11 24       	eor	r1, r1
    25f4:	84 0f       	add	r24, r20
    25f6:	95 1f       	adc	r25, r21
    25f8:	e9 81       	ldd	r30, Y+1	; 0x01
    25fa:	fa 81       	ldd	r31, Y+2	; 0x02
    25fc:	97 83       	std	Z+7, r25	; 0x07
    25fe:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    2600:	e9 81       	ldd	r30, Y+1	; 0x01
    2602:	fa 81       	ldd	r31, Y+2	; 0x02
    2604:	8f ef       	ldi	r24, 0xFF	; 255
    2606:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    2608:	e9 81       	ldd	r30, Y+1	; 0x01
    260a:	fa 81       	ldd	r31, Y+2	; 0x02
    260c:	8f ef       	ldi	r24, 0xFF	; 255
    260e:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2610:	8d 81       	ldd	r24, Y+5	; 0x05
    2612:	88 23       	and	r24, r24
    2614:	79 f4       	brne	.+30     	; 0x2634 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2616:	e9 81       	ldd	r30, Y+1	; 0x01
    2618:	fa 81       	ldd	r31, Y+2	; 0x02
    261a:	80 85       	ldd	r24, Z+8	; 0x08
    261c:	88 23       	and	r24, r24
    261e:	a1 f0       	breq	.+40     	; 0x2648 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2620:	89 81       	ldd	r24, Y+1	; 0x01
    2622:	9a 81       	ldd	r25, Y+2	; 0x02
    2624:	08 96       	adiw	r24, 0x08	; 8
    2626:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    262a:	81 30       	cpi	r24, 0x01	; 1
    262c:	69 f4       	brne	.+26     	; 0x2648 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    262e:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    2632:	0a c0       	rjmp	.+20     	; 0x2648 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2634:	89 81       	ldd	r24, Y+1	; 0x01
    2636:	9a 81       	ldd	r25, Y+2	; 0x02
    2638:	08 96       	adiw	r24, 0x08	; 8
    263a:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	41 96       	adiw	r24, 0x11	; 17
    2644:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2648:	0f 90       	pop	r0
    264a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    264c:	81 e0       	ldi	r24, 0x01	; 1
}
    264e:	0f 90       	pop	r0
    2650:	0f 90       	pop	r0
    2652:	0f 90       	pop	r0
    2654:	0f 90       	pop	r0
    2656:	0f 90       	pop	r0
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	08 95       	ret

0000265e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    265e:	df 93       	push	r29
    2660:	cf 93       	push	r28
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	29 97       	sbiw	r28, 0x09	; 9
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	8f 83       	std	Y+7, r24	; 0x07
    2674:	68 87       	std	Y+8, r22	; 0x08
    2676:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2678:	1a 82       	std	Y+2, r1	; 0x02
    267a:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    267c:	8f 81       	ldd	r24, Y+7	; 0x07
    267e:	88 23       	and	r24, r24
    2680:	09 f4       	brne	.+2      	; 0x2684 <xQueueGenericCreate+0x26>
    2682:	3f c0       	rjmp	.+126    	; 0x2702 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2684:	8f e1       	ldi	r24, 0x1F	; 31
    2686:	90 e0       	ldi	r25, 0x00	; 0
    2688:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    268c:	9e 83       	std	Y+6, r25	; 0x06
    268e:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2690:	8d 81       	ldd	r24, Y+5	; 0x05
    2692:	9e 81       	ldd	r25, Y+6	; 0x06
    2694:	00 97       	sbiw	r24, 0x00	; 0
    2696:	a9 f1       	breq	.+106    	; 0x2702 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2698:	8f 81       	ldd	r24, Y+7	; 0x07
    269a:	28 2f       	mov	r18, r24
    269c:	30 e0       	ldi	r19, 0x00	; 0
    269e:	88 85       	ldd	r24, Y+8	; 0x08
    26a0:	88 2f       	mov	r24, r24
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	ac 01       	movw	r20, r24
    26a6:	24 9f       	mul	r18, r20
    26a8:	c0 01       	movw	r24, r0
    26aa:	25 9f       	mul	r18, r21
    26ac:	90 0d       	add	r25, r0
    26ae:	34 9f       	mul	r19, r20
    26b0:	90 0d       	add	r25, r0
    26b2:	11 24       	eor	r1, r1
    26b4:	01 96       	adiw	r24, 0x01	; 1
    26b6:	9c 83       	std	Y+4, r25	; 0x04
    26b8:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    26ba:	8b 81       	ldd	r24, Y+3	; 0x03
    26bc:	9c 81       	ldd	r25, Y+4	; 0x04
    26be:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    26c2:	ed 81       	ldd	r30, Y+5	; 0x05
    26c4:	fe 81       	ldd	r31, Y+6	; 0x06
    26c6:	91 83       	std	Z+1, r25	; 0x01
    26c8:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    26ca:	ed 81       	ldd	r30, Y+5	; 0x05
    26cc:	fe 81       	ldd	r31, Y+6	; 0x06
    26ce:	80 81       	ld	r24, Z
    26d0:	91 81       	ldd	r25, Z+1	; 0x01
    26d2:	00 97       	sbiw	r24, 0x00	; 0
    26d4:	91 f0       	breq	.+36     	; 0x26fa <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    26d6:	ed 81       	ldd	r30, Y+5	; 0x05
    26d8:	fe 81       	ldd	r31, Y+6	; 0x06
    26da:	8f 81       	ldd	r24, Y+7	; 0x07
    26dc:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    26de:	ed 81       	ldd	r30, Y+5	; 0x05
    26e0:	fe 81       	ldd	r31, Y+6	; 0x06
    26e2:	88 85       	ldd	r24, Y+8	; 0x08
    26e4:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    26e6:	8d 81       	ldd	r24, Y+5	; 0x05
    26e8:	9e 81       	ldd	r25, Y+6	; 0x06
    26ea:	61 e0       	ldi	r22, 0x01	; 1
    26ec:	0e 94 a9 12 	call	0x2552	; 0x2552 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    26f0:	8d 81       	ldd	r24, Y+5	; 0x05
    26f2:	9e 81       	ldd	r25, Y+6	; 0x06
    26f4:	9a 83       	std	Y+2, r25	; 0x02
    26f6:	89 83       	std	Y+1, r24	; 0x01
    26f8:	04 c0       	rjmp	.+8      	; 0x2702 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    26fa:	8d 81       	ldd	r24, Y+5	; 0x05
    26fc:	9e 81       	ldd	r25, Y+6	; 0x06
    26fe:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    2702:	89 81       	ldd	r24, Y+1	; 0x01
    2704:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2706:	29 96       	adiw	r28, 0x09	; 9
    2708:	0f b6       	in	r0, 0x3f	; 63
    270a:	f8 94       	cli
    270c:	de bf       	out	0x3e, r29	; 62
    270e:	0f be       	out	0x3f, r0	; 63
    2710:	cd bf       	out	0x3d, r28	; 61
    2712:	cf 91       	pop	r28
    2714:	df 91       	pop	r29
    2716:	08 95       	ret

00002718 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2718:	df 93       	push	r29
    271a:	cf 93       	push	r28
    271c:	00 d0       	rcall	.+0      	; 0x271e <xQueueCreateMutex+0x6>
    271e:	0f 92       	push	r0
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
    2724:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2726:	8f e1       	ldi	r24, 0x1F	; 31
    2728:	90 e0       	ldi	r25, 0x00	; 0
    272a:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    272e:	9a 83       	std	Y+2, r25	; 0x02
    2730:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	9a 81       	ldd	r25, Y+2	; 0x02
    2736:	00 97       	sbiw	r24, 0x00	; 0
    2738:	a9 f1       	breq	.+106    	; 0x27a4 <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    273a:	e9 81       	ldd	r30, Y+1	; 0x01
    273c:	fa 81       	ldd	r31, Y+2	; 0x02
    273e:	13 82       	std	Z+3, r1	; 0x03
    2740:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2742:	e9 81       	ldd	r30, Y+1	; 0x01
    2744:	fa 81       	ldd	r31, Y+2	; 0x02
    2746:	11 82       	std	Z+1, r1	; 0x01
    2748:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    274a:	e9 81       	ldd	r30, Y+1	; 0x01
    274c:	fa 81       	ldd	r31, Y+2	; 0x02
    274e:	15 82       	std	Z+5, r1	; 0x05
    2750:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    2752:	e9 81       	ldd	r30, Y+1	; 0x01
    2754:	fa 81       	ldd	r31, Y+2	; 0x02
    2756:	17 82       	std	Z+7, r1	; 0x07
    2758:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    275a:	e9 81       	ldd	r30, Y+1	; 0x01
    275c:	fa 81       	ldd	r31, Y+2	; 0x02
    275e:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    2760:	e9 81       	ldd	r30, Y+1	; 0x01
    2762:	fa 81       	ldd	r31, Y+2	; 0x02
    2764:	81 e0       	ldi	r24, 0x01	; 1
    2766:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    2768:	e9 81       	ldd	r30, Y+1	; 0x01
    276a:	fa 81       	ldd	r31, Y+2	; 0x02
    276c:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    276e:	e9 81       	ldd	r30, Y+1	; 0x01
    2770:	fa 81       	ldd	r31, Y+2	; 0x02
    2772:	8f ef       	ldi	r24, 0xFF	; 255
    2774:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    2776:	e9 81       	ldd	r30, Y+1	; 0x01
    2778:	fa 81       	ldd	r31, Y+2	; 0x02
    277a:	8f ef       	ldi	r24, 0xFF	; 255
    277c:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    277e:	89 81       	ldd	r24, Y+1	; 0x01
    2780:	9a 81       	ldd	r25, Y+2	; 0x02
    2782:	08 96       	adiw	r24, 0x08	; 8
    2784:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	9a 81       	ldd	r25, Y+2	; 0x02
    278c:	41 96       	adiw	r24, 0x11	; 17
    278e:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	9a 81       	ldd	r25, Y+2	; 0x02
    2796:	60 e0       	ldi	r22, 0x00	; 0
    2798:	70 e0       	ldi	r23, 0x00	; 0
    279a:	40 e0       	ldi	r20, 0x00	; 0
    279c:	50 e0       	ldi	r21, 0x00	; 0
    279e:	20 e0       	ldi	r18, 0x00	; 0
    27a0:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    27a4:	89 81       	ldd	r24, Y+1	; 0x01
    27a6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    27a8:	0f 90       	pop	r0
    27aa:	0f 90       	pop	r0
    27ac:	0f 90       	pop	r0
    27ae:	cf 91       	pop	r28
    27b0:	df 91       	pop	r29
    27b2:	08 95       	ret

000027b4 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    27b4:	df 93       	push	r29
    27b6:	cf 93       	push	r28
    27b8:	00 d0       	rcall	.+0      	; 0x27ba <xQueueCreateCountingSemaphore+0x6>
    27ba:	00 d0       	rcall	.+0      	; 0x27bc <xQueueCreateCountingSemaphore+0x8>
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	8b 83       	std	Y+3, r24	; 0x03
    27c2:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    27c4:	8b 81       	ldd	r24, Y+3	; 0x03
    27c6:	60 e0       	ldi	r22, 0x00	; 0
    27c8:	42 e0       	ldi	r20, 0x02	; 2
    27ca:	0e 94 2f 13 	call	0x265e	; 0x265e <xQueueGenericCreate>
    27ce:	9a 83       	std	Y+2, r25	; 0x02
    27d0:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    27d2:	89 81       	ldd	r24, Y+1	; 0x01
    27d4:	9a 81       	ldd	r25, Y+2	; 0x02
    27d6:	00 97       	sbiw	r24, 0x00	; 0
    27d8:	21 f0       	breq	.+8      	; 0x27e2 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    27da:	e9 81       	ldd	r30, Y+1	; 0x01
    27dc:	fa 81       	ldd	r31, Y+2	; 0x02
    27de:	8c 81       	ldd	r24, Y+4	; 0x04
    27e0:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    27e2:	89 81       	ldd	r24, Y+1	; 0x01
    27e4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    27e6:	0f 90       	pop	r0
    27e8:	0f 90       	pop	r0
    27ea:	0f 90       	pop	r0
    27ec:	0f 90       	pop	r0
    27ee:	cf 91       	pop	r28
    27f0:	df 91       	pop	r29
    27f2:	08 95       	ret

000027f4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    27f4:	df 93       	push	r29
    27f6:	cf 93       	push	r28
    27f8:	cd b7       	in	r28, 0x3d	; 61
    27fa:	de b7       	in	r29, 0x3e	; 62
    27fc:	2f 97       	sbiw	r28, 0x0f	; 15
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	de bf       	out	0x3e, r29	; 62
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	cd bf       	out	0x3d, r28	; 61
    2808:	99 87       	std	Y+9, r25	; 0x09
    280a:	88 87       	std	Y+8, r24	; 0x08
    280c:	7b 87       	std	Y+11, r23	; 0x0b
    280e:	6a 87       	std	Y+10, r22	; 0x0a
    2810:	5d 87       	std	Y+13, r21	; 0x0d
    2812:	4c 87       	std	Y+12, r20	; 0x0c
    2814:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2816:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2818:	88 85       	ldd	r24, Y+8	; 0x08
    281a:	99 85       	ldd	r25, Y+9	; 0x09
    281c:	9a 83       	std	Y+2, r25	; 0x02
    281e:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	f8 94       	cli
    2824:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2826:	e9 81       	ldd	r30, Y+1	; 0x01
    2828:	fa 81       	ldd	r31, Y+2	; 0x02
    282a:	92 8d       	ldd	r25, Z+26	; 0x1a
    282c:	e9 81       	ldd	r30, Y+1	; 0x01
    282e:	fa 81       	ldd	r31, Y+2	; 0x02
    2830:	83 8d       	ldd	r24, Z+27	; 0x1b
    2832:	98 17       	cp	r25, r24
    2834:	18 f0       	brcs	.+6      	; 0x283c <xQueueGenericSend+0x48>
    2836:	8e 85       	ldd	r24, Y+14	; 0x0e
    2838:	82 30       	cpi	r24, 0x02	; 2
    283a:	11 f5       	brne	.+68     	; 0x2880 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    283c:	89 81       	ldd	r24, Y+1	; 0x01
    283e:	9a 81       	ldd	r25, Y+2	; 0x02
    2840:	2a 85       	ldd	r18, Y+10	; 0x0a
    2842:	3b 85       	ldd	r19, Y+11	; 0x0b
    2844:	b9 01       	movw	r22, r18
    2846:	4e 85       	ldd	r20, Y+14	; 0x0e
    2848:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvCopyDataToQueue>
    284c:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    284e:	e9 81       	ldd	r30, Y+1	; 0x01
    2850:	fa 81       	ldd	r31, Y+2	; 0x02
    2852:	81 89       	ldd	r24, Z+17	; 0x11
    2854:	88 23       	and	r24, r24
    2856:	51 f0       	breq	.+20     	; 0x286c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2858:	89 81       	ldd	r24, Y+1	; 0x01
    285a:	9a 81       	ldd	r25, Y+2	; 0x02
    285c:	41 96       	adiw	r24, 0x11	; 17
    285e:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    2862:	81 30       	cpi	r24, 0x01	; 1
    2864:	41 f4       	brne	.+16     	; 0x2876 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2866:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    286a:	05 c0       	rjmp	.+10     	; 0x2876 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    286c:	8b 81       	ldd	r24, Y+3	; 0x03
    286e:	88 23       	and	r24, r24
    2870:	11 f0       	breq	.+4      	; 0x2876 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2872:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2876:	0f 90       	pop	r0
    2878:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	8f 87       	std	Y+15, r24	; 0x0f
    287e:	5c c0       	rjmp	.+184    	; 0x2938 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2880:	8c 85       	ldd	r24, Y+12	; 0x0c
    2882:	9d 85       	ldd	r25, Y+13	; 0x0d
    2884:	00 97       	sbiw	r24, 0x00	; 0
    2886:	21 f4       	brne	.+8      	; 0x2890 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2888:	0f 90       	pop	r0
    288a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    288c:	1f 86       	std	Y+15, r1	; 0x0f
    288e:	54 c0       	rjmp	.+168    	; 0x2938 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2890:	8c 81       	ldd	r24, Y+4	; 0x04
    2892:	88 23       	and	r24, r24
    2894:	31 f4       	brne	.+12     	; 0x28a2 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2896:	ce 01       	movw	r24, r28
    2898:	05 96       	adiw	r24, 0x05	; 5
    289a:	0e 94 e6 20 	call	0x41cc	; 0x41cc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    289e:	81 e0       	ldi	r24, 0x01	; 1
    28a0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    28a2:	0f 90       	pop	r0
    28a4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    28a6:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    28aa:	0f b6       	in	r0, 0x3f	; 63
    28ac:	f8 94       	cli
    28ae:	0f 92       	push	r0
    28b0:	e9 81       	ldd	r30, Y+1	; 0x01
    28b2:	fa 81       	ldd	r31, Y+2	; 0x02
    28b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    28b6:	8f 3f       	cpi	r24, 0xFF	; 255
    28b8:	19 f4       	brne	.+6      	; 0x28c0 <xQueueGenericSend+0xcc>
    28ba:	e9 81       	ldd	r30, Y+1	; 0x01
    28bc:	fa 81       	ldd	r31, Y+2	; 0x02
    28be:	15 8e       	std	Z+29, r1	; 0x1d
    28c0:	e9 81       	ldd	r30, Y+1	; 0x01
    28c2:	fa 81       	ldd	r31, Y+2	; 0x02
    28c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    28c6:	8f 3f       	cpi	r24, 0xFF	; 255
    28c8:	19 f4       	brne	.+6      	; 0x28d0 <xQueueGenericSend+0xdc>
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	16 8e       	std	Z+30, r1	; 0x1e
    28d0:	0f 90       	pop	r0
    28d2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    28d4:	ce 01       	movw	r24, r28
    28d6:	05 96       	adiw	r24, 0x05	; 5
    28d8:	9e 01       	movw	r18, r28
    28da:	24 5f       	subi	r18, 0xF4	; 244
    28dc:	3f 4f       	sbci	r19, 0xFF	; 255
    28de:	b9 01       	movw	r22, r18
    28e0:	0e 94 ff 20 	call	0x41fe	; 0x41fe <xTaskCheckForTimeOut>
    28e4:	88 23       	and	r24, r24
    28e6:	09 f5       	brne	.+66     	; 0x292a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    28e8:	89 81       	ldd	r24, Y+1	; 0x01
    28ea:	9a 81       	ldd	r25, Y+2	; 0x02
    28ec:	0e 94 75 18 	call	0x30ea	; 0x30ea <prvIsQueueFull>
    28f0:	88 23       	and	r24, r24
    28f2:	a1 f0       	breq	.+40     	; 0x291c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	9a 81       	ldd	r25, Y+2	; 0x02
    28f8:	08 96       	adiw	r24, 0x08	; 8
    28fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    28fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    28fe:	b9 01       	movw	r22, r18
    2900:	0e 94 9e 1f 	call	0x3f3c	; 0x3f3c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	9a 81       	ldd	r25, Y+2	; 0x02
    2908:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    290c:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2910:	88 23       	and	r24, r24
    2912:	09 f0       	breq	.+2      	; 0x2916 <xQueueGenericSend+0x122>
    2914:	85 cf       	rjmp	.-246    	; 0x2820 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2916:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    291a:	82 cf       	rjmp	.-252    	; 0x2820 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    291c:	89 81       	ldd	r24, Y+1	; 0x01
    291e:	9a 81       	ldd	r25, Y+2	; 0x02
    2920:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2924:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2928:	7b cf       	rjmp	.-266    	; 0x2820 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    292a:	89 81       	ldd	r24, Y+1	; 0x01
    292c:	9a 81       	ldd	r25, Y+2	; 0x02
    292e:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2932:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2936:	1f 86       	std	Y+15, r1	; 0x0f
    2938:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    293a:	2f 96       	adiw	r28, 0x0f	; 15
    293c:	0f b6       	in	r0, 0x3f	; 63
    293e:	f8 94       	cli
    2940:	de bf       	out	0x3e, r29	; 62
    2942:	0f be       	out	0x3f, r0	; 63
    2944:	cd bf       	out	0x3d, r28	; 61
    2946:	cf 91       	pop	r28
    2948:	df 91       	pop	r29
    294a:	08 95       	ret

0000294c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    294c:	df 93       	push	r29
    294e:	cf 93       	push	r28
    2950:	cd b7       	in	r28, 0x3d	; 61
    2952:	de b7       	in	r29, 0x3e	; 62
    2954:	2b 97       	sbiw	r28, 0x0b	; 11
    2956:	0f b6       	in	r0, 0x3f	; 63
    2958:	f8 94       	cli
    295a:	de bf       	out	0x3e, r29	; 62
    295c:	0f be       	out	0x3f, r0	; 63
    295e:	cd bf       	out	0x3d, r28	; 61
    2960:	9e 83       	std	Y+6, r25	; 0x06
    2962:	8d 83       	std	Y+5, r24	; 0x05
    2964:	78 87       	std	Y+8, r23	; 0x08
    2966:	6f 83       	std	Y+7, r22	; 0x07
    2968:	5a 87       	std	Y+10, r21	; 0x0a
    296a:	49 87       	std	Y+9, r20	; 0x09
    296c:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    296e:	8d 81       	ldd	r24, Y+5	; 0x05
    2970:	9e 81       	ldd	r25, Y+6	; 0x06
    2972:	9a 83       	std	Y+2, r25	; 0x02
    2974:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2976:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2978:	e9 81       	ldd	r30, Y+1	; 0x01
    297a:	fa 81       	ldd	r31, Y+2	; 0x02
    297c:	92 8d       	ldd	r25, Z+26	; 0x1a
    297e:	e9 81       	ldd	r30, Y+1	; 0x01
    2980:	fa 81       	ldd	r31, Y+2	; 0x02
    2982:	83 8d       	ldd	r24, Z+27	; 0x1b
    2984:	98 17       	cp	r25, r24
    2986:	18 f0       	brcs	.+6      	; 0x298e <xQueueGenericSendFromISR+0x42>
    2988:	8b 85       	ldd	r24, Y+11	; 0x0b
    298a:	82 30       	cpi	r24, 0x02	; 2
    298c:	b1 f5       	brne	.+108    	; 0x29fa <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    298e:	89 81       	ldd	r24, Y+1	; 0x01
    2990:	9a 81       	ldd	r25, Y+2	; 0x02
    2992:	2f 81       	ldd	r18, Y+7	; 0x07
    2994:	38 85       	ldd	r19, Y+8	; 0x08
    2996:	b9 01       	movw	r22, r18
    2998:	4b 85       	ldd	r20, Y+11	; 0x0b
    299a:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvCopyDataToQueue>
    299e:	88 23       	and	r24, r24
    29a0:	41 f0       	breq	.+16     	; 0x29b2 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    29a2:	89 85       	ldd	r24, Y+9	; 0x09
    29a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    29a6:	00 97       	sbiw	r24, 0x00	; 0
    29a8:	21 f0       	breq	.+8      	; 0x29b2 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    29aa:	e9 85       	ldd	r30, Y+9	; 0x09
    29ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    29ae:	81 e0       	ldi	r24, 0x01	; 1
    29b0:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    29b2:	e9 81       	ldd	r30, Y+1	; 0x01
    29b4:	fa 81       	ldd	r31, Y+2	; 0x02
    29b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    29b8:	8f 3f       	cpi	r24, 0xFF	; 255
    29ba:	a9 f4       	brne	.+42     	; 0x29e6 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29bc:	e9 81       	ldd	r30, Y+1	; 0x01
    29be:	fa 81       	ldd	r31, Y+2	; 0x02
    29c0:	81 89       	ldd	r24, Z+17	; 0x11
    29c2:	88 23       	and	r24, r24
    29c4:	b9 f0       	breq	.+46     	; 0x29f4 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29c6:	89 81       	ldd	r24, Y+1	; 0x01
    29c8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ca:	41 96       	adiw	r24, 0x11	; 17
    29cc:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    29d0:	88 23       	and	r24, r24
    29d2:	81 f0       	breq	.+32     	; 0x29f4 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    29d4:	89 85       	ldd	r24, Y+9	; 0x09
    29d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    29d8:	00 97       	sbiw	r24, 0x00	; 0
    29da:	61 f0       	breq	.+24     	; 0x29f4 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    29dc:	e9 85       	ldd	r30, Y+9	; 0x09
    29de:	fa 85       	ldd	r31, Y+10	; 0x0a
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	80 83       	st	Z, r24
    29e4:	07 c0       	rjmp	.+14     	; 0x29f4 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    29e6:	e9 81       	ldd	r30, Y+1	; 0x01
    29e8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    29ec:	8f 5f       	subi	r24, 0xFF	; 255
    29ee:	e9 81       	ldd	r30, Y+1	; 0x01
    29f0:	fa 81       	ldd	r31, Y+2	; 0x02
    29f2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    29f4:	81 e0       	ldi	r24, 0x01	; 1
    29f6:	8c 83       	std	Y+4, r24	; 0x04
    29f8:	01 c0       	rjmp	.+2      	; 0x29fc <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    29fa:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    29fc:	8c 81       	ldd	r24, Y+4	; 0x04
}
    29fe:	2b 96       	adiw	r28, 0x0b	; 11
    2a00:	0f b6       	in	r0, 0x3f	; 63
    2a02:	f8 94       	cli
    2a04:	de bf       	out	0x3e, r29	; 62
    2a06:	0f be       	out	0x3f, r0	; 63
    2a08:	cd bf       	out	0x3d, r28	; 61
    2a0a:	cf 91       	pop	r28
    2a0c:	df 91       	pop	r29
    2a0e:	08 95       	ret

00002a10 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2a10:	df 93       	push	r29
    2a12:	cf 93       	push	r28
    2a14:	cd b7       	in	r28, 0x3d	; 61
    2a16:	de b7       	in	r29, 0x3e	; 62
    2a18:	60 97       	sbiw	r28, 0x10	; 16
    2a1a:	0f b6       	in	r0, 0x3f	; 63
    2a1c:	f8 94       	cli
    2a1e:	de bf       	out	0x3e, r29	; 62
    2a20:	0f be       	out	0x3f, r0	; 63
    2a22:	cd bf       	out	0x3d, r28	; 61
    2a24:	9a 87       	std	Y+10, r25	; 0x0a
    2a26:	89 87       	std	Y+9, r24	; 0x09
    2a28:	7c 87       	std	Y+12, r23	; 0x0c
    2a2a:	6b 87       	std	Y+11, r22	; 0x0b
    2a2c:	5e 87       	std	Y+14, r21	; 0x0e
    2a2e:	4d 87       	std	Y+13, r20	; 0x0d
    2a30:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2a32:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a34:	89 85       	ldd	r24, Y+9	; 0x09
    2a36:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a38:	9a 83       	std	Y+2, r25	; 0x02
    2a3a:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2a3c:	0f b6       	in	r0, 0x3f	; 63
    2a3e:	f8 94       	cli
    2a40:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a42:	e9 81       	ldd	r30, Y+1	; 0x01
    2a44:	fa 81       	ldd	r31, Y+2	; 0x02
    2a46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a48:	88 23       	and	r24, r24
    2a4a:	09 f4       	brne	.+2      	; 0x2a4e <xQueueGenericReceive+0x3e>
    2a4c:	4b c0       	rjmp	.+150    	; 0x2ae4 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	86 81       	ldd	r24, Z+6	; 0x06
    2a54:	97 81       	ldd	r25, Z+7	; 0x07
    2a56:	9c 83       	std	Y+4, r25	; 0x04
    2a58:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
    2a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a5e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2a60:	3c 85       	ldd	r19, Y+12	; 0x0c
    2a62:	b9 01       	movw	r22, r18
    2a64:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2a68:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a6a:	88 23       	and	r24, r24
    2a6c:	11 f5       	brne	.+68     	; 0x2ab2 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2a6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a70:	fa 81       	ldd	r31, Y+2	; 0x02
    2a72:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a74:	81 50       	subi	r24, 0x01	; 1
    2a76:	e9 81       	ldd	r30, Y+1	; 0x01
    2a78:	fa 81       	ldd	r31, Y+2	; 0x02
    2a7a:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2a7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a80:	80 81       	ld	r24, Z
    2a82:	91 81       	ldd	r25, Z+1	; 0x01
    2a84:	00 97       	sbiw	r24, 0x00	; 0
    2a86:	31 f4       	brne	.+12     	; 0x2a94 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2a88:	0e 94 76 24 	call	0x48ec	; 0x48ec <pvTaskIncrementMutexHeldCount>
    2a8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a90:	93 83       	std	Z+3, r25	; 0x03
    2a92:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a94:	e9 81       	ldd	r30, Y+1	; 0x01
    2a96:	fa 81       	ldd	r31, Y+2	; 0x02
    2a98:	80 85       	ldd	r24, Z+8	; 0x08
    2a9a:	88 23       	and	r24, r24
    2a9c:	f1 f0       	breq	.+60     	; 0x2ada <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa2:	08 96       	adiw	r24, 0x08	; 8
    2aa4:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    2aa8:	81 30       	cpi	r24, 0x01	; 1
    2aaa:	b9 f4       	brne	.+46     	; 0x2ada <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2aac:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    2ab0:	14 c0       	rjmp	.+40     	; 0x2ada <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aba:	97 83       	std	Z+7, r25	; 0x07
    2abc:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2abe:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac2:	81 89       	ldd	r24, Z+17	; 0x11
    2ac4:	88 23       	and	r24, r24
    2ac6:	49 f0       	breq	.+18     	; 0x2ada <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	9a 81       	ldd	r25, Y+2	; 0x02
    2acc:	41 96       	adiw	r24, 0x11	; 17
    2ace:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    2ad2:	88 23       	and	r24, r24
    2ad4:	11 f0       	breq	.+4      	; 0x2ada <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2ad6:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2ada:	0f 90       	pop	r0
    2adc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	88 8b       	std	Y+16, r24	; 0x10
    2ae2:	6d c0       	rjmp	.+218    	; 0x2bbe <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2ae4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ae6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ae8:	00 97       	sbiw	r24, 0x00	; 0
    2aea:	21 f4       	brne	.+8      	; 0x2af4 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2aec:	0f 90       	pop	r0
    2aee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2af0:	18 8a       	std	Y+16, r1	; 0x10
    2af2:	65 c0       	rjmp	.+202    	; 0x2bbe <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    2af4:	8d 81       	ldd	r24, Y+5	; 0x05
    2af6:	88 23       	and	r24, r24
    2af8:	31 f4       	brne	.+12     	; 0x2b06 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2afa:	ce 01       	movw	r24, r28
    2afc:	06 96       	adiw	r24, 0x06	; 6
    2afe:	0e 94 e6 20 	call	0x41cc	; 0x41cc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2b02:	81 e0       	ldi	r24, 0x01	; 1
    2b04:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2b06:	0f 90       	pop	r0
    2b08:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2b0a:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	0f 92       	push	r0
    2b14:	e9 81       	ldd	r30, Y+1	; 0x01
    2b16:	fa 81       	ldd	r31, Y+2	; 0x02
    2b18:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b1a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b1c:	19 f4       	brne	.+6      	; 0x2b24 <xQueueGenericReceive+0x114>
    2b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b20:	fa 81       	ldd	r31, Y+2	; 0x02
    2b22:	15 8e       	std	Z+29, r1	; 0x1d
    2b24:	e9 81       	ldd	r30, Y+1	; 0x01
    2b26:	fa 81       	ldd	r31, Y+2	; 0x02
    2b28:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b2c:	19 f4       	brne	.+6      	; 0x2b34 <xQueueGenericReceive+0x124>
    2b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b30:	fa 81       	ldd	r31, Y+2	; 0x02
    2b32:	16 8e       	std	Z+30, r1	; 0x1e
    2b34:	0f 90       	pop	r0
    2b36:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b38:	ce 01       	movw	r24, r28
    2b3a:	06 96       	adiw	r24, 0x06	; 6
    2b3c:	9e 01       	movw	r18, r28
    2b3e:	23 5f       	subi	r18, 0xF3	; 243
    2b40:	3f 4f       	sbci	r19, 0xFF	; 255
    2b42:	b9 01       	movw	r22, r18
    2b44:	0e 94 ff 20 	call	0x41fe	; 0x41fe <xTaskCheckForTimeOut>
    2b48:	88 23       	and	r24, r24
    2b4a:	91 f5       	brne	.+100    	; 0x2bb0 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b4c:	89 81       	ldd	r24, Y+1	; 0x01
    2b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b50:	0e 94 40 18 	call	0x3080	; 0x3080 <prvIsQueueEmpty>
    2b54:	88 23       	and	r24, r24
    2b56:	29 f1       	breq	.+74     	; 0x2ba2 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2b58:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5c:	80 81       	ld	r24, Z
    2b5e:	91 81       	ldd	r25, Z+1	; 0x01
    2b60:	00 97       	sbiw	r24, 0x00	; 0
    2b62:	59 f4       	brne	.+22     	; 0x2b7a <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    2b64:	0f b6       	in	r0, 0x3f	; 63
    2b66:	f8 94       	cli
    2b68:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6e:	82 81       	ldd	r24, Z+2	; 0x02
    2b70:	93 81       	ldd	r25, Z+3	; 0x03
    2b72:	0e 94 52 23 	call	0x46a4	; 0x46a4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2b76:	0f 90       	pop	r0
    2b78:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2b7a:	89 81       	ldd	r24, Y+1	; 0x01
    2b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b7e:	41 96       	adiw	r24, 0x11	; 17
    2b80:	2d 85       	ldd	r18, Y+13	; 0x0d
    2b82:	3e 85       	ldd	r19, Y+14	; 0x0e
    2b84:	b9 01       	movw	r22, r18
    2b86:	0e 94 9e 1f 	call	0x3f3c	; 0x3f3c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2b8a:	89 81       	ldd	r24, Y+1	; 0x01
    2b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b8e:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2b92:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2b96:	88 23       	and	r24, r24
    2b98:	09 f0       	breq	.+2      	; 0x2b9c <xQueueGenericReceive+0x18c>
    2b9a:	50 cf       	rjmp	.-352    	; 0x2a3c <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    2b9c:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    2ba0:	4d cf       	rjmp	.-358    	; 0x2a3c <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2ba2:	89 81       	ldd	r24, Y+1	; 0x01
    2ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba6:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2baa:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2bae:	46 cf       	rjmp	.-372    	; 0x2a3c <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2bb0:	89 81       	ldd	r24, Y+1	; 0x01
    2bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb4:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2bb8:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2bbc:	18 8a       	std	Y+16, r1	; 0x10
    2bbe:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    2bc0:	60 96       	adiw	r28, 0x10	; 16
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	f8 94       	cli
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	cd bf       	out	0x3d, r28	; 61
    2bcc:	cf 91       	pop	r28
    2bce:	df 91       	pop	r29
    2bd0:	08 95       	ret

00002bd2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2bd2:	df 93       	push	r29
    2bd4:	cf 93       	push	r28
    2bd6:	cd b7       	in	r28, 0x3d	; 61
    2bd8:	de b7       	in	r29, 0x3e	; 62
    2bda:	2a 97       	sbiw	r28, 0x0a	; 10
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	de bf       	out	0x3e, r29	; 62
    2be2:	0f be       	out	0x3f, r0	; 63
    2be4:	cd bf       	out	0x3d, r28	; 61
    2be6:	9e 83       	std	Y+6, r25	; 0x06
    2be8:	8d 83       	std	Y+5, r24	; 0x05
    2bea:	78 87       	std	Y+8, r23	; 0x08
    2bec:	6f 83       	std	Y+7, r22	; 0x07
    2bee:	5a 87       	std	Y+10, r21	; 0x0a
    2bf0:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2bf2:	8d 81       	ldd	r24, Y+5	; 0x05
    2bf4:	9e 81       	ldd	r25, Y+6	; 0x06
    2bf6:	9a 83       	std	Y+2, r25	; 0x02
    2bf8:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2bfa:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2c00:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c02:	88 23       	and	r24, r24
    2c04:	91 f1       	breq	.+100    	; 0x2c6a <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2c06:	89 81       	ldd	r24, Y+1	; 0x01
    2c08:	9a 81       	ldd	r25, Y+2	; 0x02
    2c0a:	2f 81       	ldd	r18, Y+7	; 0x07
    2c0c:	38 85       	ldd	r19, Y+8	; 0x08
    2c0e:	b9 01       	movw	r22, r18
    2c10:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2c14:	e9 81       	ldd	r30, Y+1	; 0x01
    2c16:	fa 81       	ldd	r31, Y+2	; 0x02
    2c18:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c1a:	81 50       	subi	r24, 0x01	; 1
    2c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c20:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2c22:	e9 81       	ldd	r30, Y+1	; 0x01
    2c24:	fa 81       	ldd	r31, Y+2	; 0x02
    2c26:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c28:	8f 3f       	cpi	r24, 0xFF	; 255
    2c2a:	a9 f4       	brne	.+42     	; 0x2c56 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c30:	80 85       	ldd	r24, Z+8	; 0x08
    2c32:	88 23       	and	r24, r24
    2c34:	b9 f0       	breq	.+46     	; 0x2c64 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c36:	89 81       	ldd	r24, Y+1	; 0x01
    2c38:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3a:	08 96       	adiw	r24, 0x08	; 8
    2c3c:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    2c40:	88 23       	and	r24, r24
    2c42:	81 f0       	breq	.+32     	; 0x2c64 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2c44:	89 85       	ldd	r24, Y+9	; 0x09
    2c46:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c48:	00 97       	sbiw	r24, 0x00	; 0
    2c4a:	61 f0       	breq	.+24     	; 0x2c64 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2c4c:	e9 85       	ldd	r30, Y+9	; 0x09
    2c4e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	80 83       	st	Z, r24
    2c54:	07 c0       	rjmp	.+14     	; 0x2c64 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2c56:	e9 81       	ldd	r30, Y+1	; 0x01
    2c58:	fa 81       	ldd	r31, Y+2	; 0x02
    2c5a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c5c:	8f 5f       	subi	r24, 0xFF	; 255
    2c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c60:	fa 81       	ldd	r31, Y+2	; 0x02
    2c62:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2c64:	81 e0       	ldi	r24, 0x01	; 1
    2c66:	8c 83       	std	Y+4, r24	; 0x04
    2c68:	01 c0       	rjmp	.+2      	; 0x2c6c <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2c6a:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2c6c:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2c6e:	2a 96       	adiw	r28, 0x0a	; 10
    2c70:	0f b6       	in	r0, 0x3f	; 63
    2c72:	f8 94       	cli
    2c74:	de bf       	out	0x3e, r29	; 62
    2c76:	0f be       	out	0x3f, r0	; 63
    2c78:	cd bf       	out	0x3d, r28	; 61
    2c7a:	cf 91       	pop	r28
    2c7c:	df 91       	pop	r29
    2c7e:	08 95       	ret

00002c80 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2c80:	df 93       	push	r29
    2c82:	cf 93       	push	r28
    2c84:	cd b7       	in	r28, 0x3d	; 61
    2c86:	de b7       	in	r29, 0x3e	; 62
    2c88:	2a 97       	sbiw	r28, 0x0a	; 10
    2c8a:	0f b6       	in	r0, 0x3f	; 63
    2c8c:	f8 94       	cli
    2c8e:	de bf       	out	0x3e, r29	; 62
    2c90:	0f be       	out	0x3f, r0	; 63
    2c92:	cd bf       	out	0x3d, r28	; 61
    2c94:	98 87       	std	Y+8, r25	; 0x08
    2c96:	8f 83       	std	Y+7, r24	; 0x07
    2c98:	7a 87       	std	Y+10, r23	; 0x0a
    2c9a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2c9c:	8f 81       	ldd	r24, Y+7	; 0x07
    2c9e:	98 85       	ldd	r25, Y+8	; 0x08
    2ca0:	9a 83       	std	Y+2, r25	; 0x02
    2ca2:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2ca4:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ca6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca8:	fa 81       	ldd	r31, Y+2	; 0x02
    2caa:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cac:	88 23       	and	r24, r24
    2cae:	b1 f0       	breq	.+44     	; 0x2cdc <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2cb4:	86 81       	ldd	r24, Z+6	; 0x06
    2cb6:	97 81       	ldd	r25, Z+7	; 0x07
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc0:	29 85       	ldd	r18, Y+9	; 0x09
    2cc2:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cc4:	b9 01       	movw	r22, r18
    2cc6:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2cca:	e9 81       	ldd	r30, Y+1	; 0x01
    2ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cce:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd2:	97 83       	std	Z+7, r25	; 0x07
    2cd4:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	8e 83       	std	Y+6, r24	; 0x06
    2cda:	01 c0       	rjmp	.+2      	; 0x2cde <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2cdc:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2cde:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2ce0:	2a 96       	adiw	r28, 0x0a	; 10
    2ce2:	0f b6       	in	r0, 0x3f	; 63
    2ce4:	f8 94       	cli
    2ce6:	de bf       	out	0x3e, r29	; 62
    2ce8:	0f be       	out	0x3f, r0	; 63
    2cea:	cd bf       	out	0x3d, r28	; 61
    2cec:	cf 91       	pop	r28
    2cee:	df 91       	pop	r29
    2cf0:	08 95       	ret

00002cf2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <uxQueueMessagesWaiting+0x6>
    2cf8:	0f 92       	push	r0
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
    2cfe:	9b 83       	std	Y+3, r25	; 0x03
    2d00:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2d02:	0f b6       	in	r0, 0x3f	; 63
    2d04:	f8 94       	cli
    2d06:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2d08:	ea 81       	ldd	r30, Y+2	; 0x02
    2d0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d0e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2d10:	0f 90       	pop	r0
    2d12:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2d14:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	0f 90       	pop	r0
    2d1c:	cf 91       	pop	r28
    2d1e:	df 91       	pop	r29
    2d20:	08 95       	ret

00002d22 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2d22:	df 93       	push	r29
    2d24:	cf 93       	push	r28
    2d26:	00 d0       	rcall	.+0      	; 0x2d28 <uxQueueSpacesAvailable+0x6>
    2d28:	00 d0       	rcall	.+0      	; 0x2d2a <uxQueueSpacesAvailable+0x8>
    2d2a:	0f 92       	push	r0
    2d2c:	cd b7       	in	r28, 0x3d	; 61
    2d2e:	de b7       	in	r29, 0x3e	; 62
    2d30:	9d 83       	std	Y+5, r25	; 0x05
    2d32:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2d34:	8c 81       	ldd	r24, Y+4	; 0x04
    2d36:	9d 81       	ldd	r25, Y+5	; 0x05
    2d38:	9a 83       	std	Y+2, r25	; 0x02
    2d3a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2d3c:	0f b6       	in	r0, 0x3f	; 63
    2d3e:	f8 94       	cli
    2d40:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2d42:	e9 81       	ldd	r30, Y+1	; 0x01
    2d44:	fa 81       	ldd	r31, Y+2	; 0x02
    2d46:	93 8d       	ldd	r25, Z+27	; 0x1b
    2d48:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d4e:	29 2f       	mov	r18, r25
    2d50:	28 1b       	sub	r18, r24
    2d52:	82 2f       	mov	r24, r18
    2d54:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2d56:	0f 90       	pop	r0
    2d58:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2d5a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2d5c:	0f 90       	pop	r0
    2d5e:	0f 90       	pop	r0
    2d60:	0f 90       	pop	r0
    2d62:	0f 90       	pop	r0
    2d64:	0f 90       	pop	r0
    2d66:	cf 91       	pop	r28
    2d68:	df 91       	pop	r29
    2d6a:	08 95       	ret

00002d6c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2d6c:	df 93       	push	r29
    2d6e:	cf 93       	push	r28
    2d70:	00 d0       	rcall	.+0      	; 0x2d72 <uxQueueMessagesWaitingFromISR+0x6>
    2d72:	0f 92       	push	r0
    2d74:	cd b7       	in	r28, 0x3d	; 61
    2d76:	de b7       	in	r29, 0x3e	; 62
    2d78:	9b 83       	std	Y+3, r25	; 0x03
    2d7a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2d7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2d7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2d80:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d82:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2d84:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2d86:	0f 90       	pop	r0
    2d88:	0f 90       	pop	r0
    2d8a:	0f 90       	pop	r0
    2d8c:	cf 91       	pop	r28
    2d8e:	df 91       	pop	r29
    2d90:	08 95       	ret

00002d92 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2d92:	df 93       	push	r29
    2d94:	cf 93       	push	r28
    2d96:	00 d0       	rcall	.+0      	; 0x2d98 <vQueueDelete+0x6>
    2d98:	00 d0       	rcall	.+0      	; 0x2d9a <vQueueDelete+0x8>
    2d9a:	cd b7       	in	r28, 0x3d	; 61
    2d9c:	de b7       	in	r29, 0x3e	; 62
    2d9e:	9c 83       	std	Y+4, r25	; 0x04
    2da0:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2da2:	8b 81       	ldd	r24, Y+3	; 0x03
    2da4:	9c 81       	ldd	r25, Y+4	; 0x04
    2da6:	9a 83       	std	Y+2, r25	; 0x02
    2da8:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    2daa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dac:	fa 81       	ldd	r31, Y+2	; 0x02
    2dae:	80 81       	ld	r24, Z
    2db0:	91 81       	ldd	r25, Z+1	; 0x01
    2db2:	00 97       	sbiw	r24, 0x00	; 0
    2db4:	31 f0       	breq	.+12     	; 0x2dc2 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    2db6:	e9 81       	ldd	r30, Y+1	; 0x01
    2db8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dba:	80 81       	ld	r24, Z
    2dbc:	91 81       	ldd	r25, Z+1	; 0x01
    2dbe:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
	}
	vPortFree( pxQueue );
    2dc2:	89 81       	ldd	r24, Y+1	; 0x01
    2dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc6:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
}
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	0f 90       	pop	r0
    2dd0:	0f 90       	pop	r0
    2dd2:	cf 91       	pop	r28
    2dd4:	df 91       	pop	r29
    2dd6:	08 95       	ret

00002dd8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2dd8:	df 93       	push	r29
    2dda:	cf 93       	push	r28
    2ddc:	00 d0       	rcall	.+0      	; 0x2dde <prvCopyDataToQueue+0x6>
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <prvCopyDataToQueue+0x8>
    2de0:	00 d0       	rcall	.+0      	; 0x2de2 <prvCopyDataToQueue+0xa>
    2de2:	cd b7       	in	r28, 0x3d	; 61
    2de4:	de b7       	in	r29, 0x3e	; 62
    2de6:	9b 83       	std	Y+3, r25	; 0x03
    2de8:	8a 83       	std	Y+2, r24	; 0x02
    2dea:	7d 83       	std	Y+5, r23	; 0x05
    2dec:	6c 83       	std	Y+4, r22	; 0x04
    2dee:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    2df0:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2df2:	ea 81       	ldd	r30, Y+2	; 0x02
    2df4:	fb 81       	ldd	r31, Y+3	; 0x03
    2df6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2df8:	88 23       	and	r24, r24
    2dfa:	99 f4       	brne	.+38     	; 0x2e22 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2dfc:	ea 81       	ldd	r30, Y+2	; 0x02
    2dfe:	fb 81       	ldd	r31, Y+3	; 0x03
    2e00:	80 81       	ld	r24, Z
    2e02:	91 81       	ldd	r25, Z+1	; 0x01
    2e04:	00 97       	sbiw	r24, 0x00	; 0
    2e06:	09 f0       	breq	.+2      	; 0x2e0a <prvCopyDataToQueue+0x32>
    2e08:	8f c0       	rjmp	.+286    	; 0x2f28 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2e0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e0e:	82 81       	ldd	r24, Z+2	; 0x02
    2e10:	93 81       	ldd	r25, Z+3	; 0x03
    2e12:	0e 94 dd 23 	call	0x47ba	; 0x47ba <xTaskPriorityDisinherit>
    2e16:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    2e18:	ea 81       	ldd	r30, Y+2	; 0x02
    2e1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e1c:	13 82       	std	Z+3, r1	; 0x03
    2e1e:	12 82       	std	Z+2, r1	; 0x02
    2e20:	83 c0       	rjmp	.+262    	; 0x2f28 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2e22:	8e 81       	ldd	r24, Y+6	; 0x06
    2e24:	88 23       	and	r24, r24
    2e26:	99 f5       	brne	.+102    	; 0x2e8e <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2e28:	ea 81       	ldd	r30, Y+2	; 0x02
    2e2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e2c:	64 81       	ldd	r22, Z+4	; 0x04
    2e2e:	75 81       	ldd	r23, Z+5	; 0x05
    2e30:	ea 81       	ldd	r30, Y+2	; 0x02
    2e32:	fb 81       	ldd	r31, Y+3	; 0x03
    2e34:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e36:	48 2f       	mov	r20, r24
    2e38:	50 e0       	ldi	r21, 0x00	; 0
    2e3a:	2c 81       	ldd	r18, Y+4	; 0x04
    2e3c:	3d 81       	ldd	r19, Y+5	; 0x05
    2e3e:	cb 01       	movw	r24, r22
    2e40:	b9 01       	movw	r22, r18
    2e42:	0e 94 70 30 	call	0x60e0	; 0x60e0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2e46:	ea 81       	ldd	r30, Y+2	; 0x02
    2e48:	fb 81       	ldd	r31, Y+3	; 0x03
    2e4a:	24 81       	ldd	r18, Z+4	; 0x04
    2e4c:	35 81       	ldd	r19, Z+5	; 0x05
    2e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e50:	fb 81       	ldd	r31, Y+3	; 0x03
    2e52:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e54:	88 2f       	mov	r24, r24
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	82 0f       	add	r24, r18
    2e5a:	93 1f       	adc	r25, r19
    2e5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e60:	95 83       	std	Z+5, r25	; 0x05
    2e62:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2e64:	ea 81       	ldd	r30, Y+2	; 0x02
    2e66:	fb 81       	ldd	r31, Y+3	; 0x03
    2e68:	24 81       	ldd	r18, Z+4	; 0x04
    2e6a:	35 81       	ldd	r19, Z+5	; 0x05
    2e6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e70:	82 81       	ldd	r24, Z+2	; 0x02
    2e72:	93 81       	ldd	r25, Z+3	; 0x03
    2e74:	28 17       	cp	r18, r24
    2e76:	39 07       	cpc	r19, r25
    2e78:	08 f4       	brcc	.+2      	; 0x2e7c <prvCopyDataToQueue+0xa4>
    2e7a:	56 c0       	rjmp	.+172    	; 0x2f28 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2e7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e80:	80 81       	ld	r24, Z
    2e82:	91 81       	ldd	r25, Z+1	; 0x01
    2e84:	ea 81       	ldd	r30, Y+2	; 0x02
    2e86:	fb 81       	ldd	r31, Y+3	; 0x03
    2e88:	95 83       	std	Z+5, r25	; 0x05
    2e8a:	84 83       	std	Z+4, r24	; 0x04
    2e8c:	4d c0       	rjmp	.+154    	; 0x2f28 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e8e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e90:	fb 81       	ldd	r31, Y+3	; 0x03
    2e92:	66 81       	ldd	r22, Z+6	; 0x06
    2e94:	77 81       	ldd	r23, Z+7	; 0x07
    2e96:	ea 81       	ldd	r30, Y+2	; 0x02
    2e98:	fb 81       	ldd	r31, Y+3	; 0x03
    2e9a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e9c:	48 2f       	mov	r20, r24
    2e9e:	50 e0       	ldi	r21, 0x00	; 0
    2ea0:	2c 81       	ldd	r18, Y+4	; 0x04
    2ea2:	3d 81       	ldd	r19, Y+5	; 0x05
    2ea4:	cb 01       	movw	r24, r22
    2ea6:	b9 01       	movw	r22, r18
    2ea8:	0e 94 70 30 	call	0x60e0	; 0x60e0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2eac:	ea 81       	ldd	r30, Y+2	; 0x02
    2eae:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb0:	26 81       	ldd	r18, Z+6	; 0x06
    2eb2:	37 81       	ldd	r19, Z+7	; 0x07
    2eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    2eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2eba:	88 2f       	mov	r24, r24
    2ebc:	90 e0       	ldi	r25, 0x00	; 0
    2ebe:	90 95       	com	r25
    2ec0:	81 95       	neg	r24
    2ec2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ec4:	82 0f       	add	r24, r18
    2ec6:	93 1f       	adc	r25, r19
    2ec8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eca:	fb 81       	ldd	r31, Y+3	; 0x03
    2ecc:	97 83       	std	Z+7, r25	; 0x07
    2ece:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2ed0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ed2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ed4:	26 81       	ldd	r18, Z+6	; 0x06
    2ed6:	37 81       	ldd	r19, Z+7	; 0x07
    2ed8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eda:	fb 81       	ldd	r31, Y+3	; 0x03
    2edc:	80 81       	ld	r24, Z
    2ede:	91 81       	ldd	r25, Z+1	; 0x01
    2ee0:	28 17       	cp	r18, r24
    2ee2:	39 07       	cpc	r19, r25
    2ee4:	90 f4       	brcc	.+36     	; 0x2f0a <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2ee6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ee8:	fb 81       	ldd	r31, Y+3	; 0x03
    2eea:	22 81       	ldd	r18, Z+2	; 0x02
    2eec:	33 81       	ldd	r19, Z+3	; 0x03
    2eee:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ef4:	88 2f       	mov	r24, r24
    2ef6:	90 e0       	ldi	r25, 0x00	; 0
    2ef8:	90 95       	com	r25
    2efa:	81 95       	neg	r24
    2efc:	9f 4f       	sbci	r25, 0xFF	; 255
    2efe:	82 0f       	add	r24, r18
    2f00:	93 1f       	adc	r25, r19
    2f02:	ea 81       	ldd	r30, Y+2	; 0x02
    2f04:	fb 81       	ldd	r31, Y+3	; 0x03
    2f06:	97 83       	std	Z+7, r25	; 0x07
    2f08:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2f0a:	8e 81       	ldd	r24, Y+6	; 0x06
    2f0c:	82 30       	cpi	r24, 0x02	; 2
    2f0e:	61 f4       	brne	.+24     	; 0x2f28 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f10:	ea 81       	ldd	r30, Y+2	; 0x02
    2f12:	fb 81       	ldd	r31, Y+3	; 0x03
    2f14:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f16:	88 23       	and	r24, r24
    2f18:	39 f0       	breq	.+14     	; 0x2f28 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2f1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f20:	81 50       	subi	r24, 0x01	; 1
    2f22:	ea 81       	ldd	r30, Y+2	; 0x02
    2f24:	fb 81       	ldd	r31, Y+3	; 0x03
    2f26:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2f28:	ea 81       	ldd	r30, Y+2	; 0x02
    2f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f2e:	8f 5f       	subi	r24, 0xFF	; 255
    2f30:	ea 81       	ldd	r30, Y+2	; 0x02
    2f32:	fb 81       	ldd	r31, Y+3	; 0x03
    2f34:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2f36:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f38:	26 96       	adiw	r28, 0x06	; 6
    2f3a:	0f b6       	in	r0, 0x3f	; 63
    2f3c:	f8 94       	cli
    2f3e:	de bf       	out	0x3e, r29	; 62
    2f40:	0f be       	out	0x3f, r0	; 63
    2f42:	cd bf       	out	0x3d, r28	; 61
    2f44:	cf 91       	pop	r28
    2f46:	df 91       	pop	r29
    2f48:	08 95       	ret

00002f4a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2f4a:	df 93       	push	r29
    2f4c:	cf 93       	push	r28
    2f4e:	00 d0       	rcall	.+0      	; 0x2f50 <prvCopyDataFromQueue+0x6>
    2f50:	00 d0       	rcall	.+0      	; 0x2f52 <prvCopyDataFromQueue+0x8>
    2f52:	cd b7       	in	r28, 0x3d	; 61
    2f54:	de b7       	in	r29, 0x3e	; 62
    2f56:	9a 83       	std	Y+2, r25	; 0x02
    2f58:	89 83       	std	Y+1, r24	; 0x01
    2f5a:	7c 83       	std	Y+4, r23	; 0x04
    2f5c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f60:	fa 81       	ldd	r31, Y+2	; 0x02
    2f62:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f64:	88 23       	and	r24, r24
    2f66:	89 f1       	breq	.+98     	; 0x2fca <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2f68:	e9 81       	ldd	r30, Y+1	; 0x01
    2f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f6c:	26 81       	ldd	r18, Z+6	; 0x06
    2f6e:	37 81       	ldd	r19, Z+7	; 0x07
    2f70:	e9 81       	ldd	r30, Y+1	; 0x01
    2f72:	fa 81       	ldd	r31, Y+2	; 0x02
    2f74:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f76:	88 2f       	mov	r24, r24
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	82 0f       	add	r24, r18
    2f7c:	93 1f       	adc	r25, r19
    2f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f80:	fa 81       	ldd	r31, Y+2	; 0x02
    2f82:	97 83       	std	Z+7, r25	; 0x07
    2f84:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2f86:	e9 81       	ldd	r30, Y+1	; 0x01
    2f88:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8a:	26 81       	ldd	r18, Z+6	; 0x06
    2f8c:	37 81       	ldd	r19, Z+7	; 0x07
    2f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f90:	fa 81       	ldd	r31, Y+2	; 0x02
    2f92:	82 81       	ldd	r24, Z+2	; 0x02
    2f94:	93 81       	ldd	r25, Z+3	; 0x03
    2f96:	28 17       	cp	r18, r24
    2f98:	39 07       	cpc	r19, r25
    2f9a:	40 f0       	brcs	.+16     	; 0x2fac <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa0:	80 81       	ld	r24, Z
    2fa2:	91 81       	ldd	r25, Z+1	; 0x01
    2fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa8:	97 83       	std	Z+7, r25	; 0x07
    2faa:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2fac:	e9 81       	ldd	r30, Y+1	; 0x01
    2fae:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb0:	46 81       	ldd	r20, Z+6	; 0x06
    2fb2:	57 81       	ldd	r21, Z+7	; 0x07
    2fb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fba:	28 2f       	mov	r18, r24
    2fbc:	30 e0       	ldi	r19, 0x00	; 0
    2fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc2:	ba 01       	movw	r22, r20
    2fc4:	a9 01       	movw	r20, r18
    2fc6:	0e 94 70 30 	call	0x60e0	; 0x60e0 <memcpy>
	}
}
    2fca:	0f 90       	pop	r0
    2fcc:	0f 90       	pop	r0
    2fce:	0f 90       	pop	r0
    2fd0:	0f 90       	pop	r0
    2fd2:	cf 91       	pop	r28
    2fd4:	df 91       	pop	r29
    2fd6:	08 95       	ret

00002fd8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2fd8:	df 93       	push	r29
    2fda:	cf 93       	push	r28
    2fdc:	00 d0       	rcall	.+0      	; 0x2fde <prvUnlockQueue+0x6>
    2fde:	cd b7       	in	r28, 0x3d	; 61
    2fe0:	de b7       	in	r29, 0x3e	; 62
    2fe2:	9a 83       	std	Y+2, r25	; 0x02
    2fe4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2fe6:	0f b6       	in	r0, 0x3f	; 63
    2fe8:	f8 94       	cli
    2fea:	0f 92       	push	r0
    2fec:	15 c0       	rjmp	.+42     	; 0x3018 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fee:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff2:	81 89       	ldd	r24, Z+17	; 0x11
    2ff4:	88 23       	and	r24, r24
    2ff6:	a9 f0       	breq	.+42     	; 0x3022 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ff8:	89 81       	ldd	r24, Y+1	; 0x01
    2ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    2ffc:	41 96       	adiw	r24, 0x11	; 17
    2ffe:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    3002:	88 23       	and	r24, r24
    3004:	11 f0       	breq	.+4      	; 0x300a <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3006:	0e 94 62 21 	call	0x42c4	; 0x42c4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    300a:	e9 81       	ldd	r30, Y+1	; 0x01
    300c:	fa 81       	ldd	r31, Y+2	; 0x02
    300e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3010:	81 50       	subi	r24, 0x01	; 1
    3012:	e9 81       	ldd	r30, Y+1	; 0x01
    3014:	fa 81       	ldd	r31, Y+2	; 0x02
    3016:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3018:	e9 81       	ldd	r30, Y+1	; 0x01
    301a:	fa 81       	ldd	r31, Y+2	; 0x02
    301c:	86 8d       	ldd	r24, Z+30	; 0x1e
    301e:	18 16       	cp	r1, r24
    3020:	34 f3       	brlt	.-52     	; 0x2fee <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3022:	e9 81       	ldd	r30, Y+1	; 0x01
    3024:	fa 81       	ldd	r31, Y+2	; 0x02
    3026:	8f ef       	ldi	r24, 0xFF	; 255
    3028:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    302a:	0f 90       	pop	r0
    302c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    302e:	0f b6       	in	r0, 0x3f	; 63
    3030:	f8 94       	cli
    3032:	0f 92       	push	r0
    3034:	15 c0       	rjmp	.+42     	; 0x3060 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3036:	e9 81       	ldd	r30, Y+1	; 0x01
    3038:	fa 81       	ldd	r31, Y+2	; 0x02
    303a:	80 85       	ldd	r24, Z+8	; 0x08
    303c:	88 23       	and	r24, r24
    303e:	a9 f0       	breq	.+42     	; 0x306a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	9a 81       	ldd	r25, Y+2	; 0x02
    3044:	08 96       	adiw	r24, 0x08	; 8
    3046:	0e 94 16 20 	call	0x402c	; 0x402c <xTaskRemoveFromEventList>
    304a:	88 23       	and	r24, r24
    304c:	11 f0       	breq	.+4      	; 0x3052 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    304e:	0e 94 62 21 	call	0x42c4	; 0x42c4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3052:	e9 81       	ldd	r30, Y+1	; 0x01
    3054:	fa 81       	ldd	r31, Y+2	; 0x02
    3056:	85 8d       	ldd	r24, Z+29	; 0x1d
    3058:	81 50       	subi	r24, 0x01	; 1
    305a:	e9 81       	ldd	r30, Y+1	; 0x01
    305c:	fa 81       	ldd	r31, Y+2	; 0x02
    305e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3060:	e9 81       	ldd	r30, Y+1	; 0x01
    3062:	fa 81       	ldd	r31, Y+2	; 0x02
    3064:	85 8d       	ldd	r24, Z+29	; 0x1d
    3066:	18 16       	cp	r1, r24
    3068:	34 f3       	brlt	.-52     	; 0x3036 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    306a:	e9 81       	ldd	r30, Y+1	; 0x01
    306c:	fa 81       	ldd	r31, Y+2	; 0x02
    306e:	8f ef       	ldi	r24, 0xFF	; 255
    3070:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3072:	0f 90       	pop	r0
    3074:	0f be       	out	0x3f, r0	; 63
}
    3076:	0f 90       	pop	r0
    3078:	0f 90       	pop	r0
    307a:	cf 91       	pop	r28
    307c:	df 91       	pop	r29
    307e:	08 95       	ret

00003080 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3080:	df 93       	push	r29
    3082:	cf 93       	push	r28
    3084:	00 d0       	rcall	.+0      	; 0x3086 <prvIsQueueEmpty+0x6>
    3086:	0f 92       	push	r0
    3088:	cd b7       	in	r28, 0x3d	; 61
    308a:	de b7       	in	r29, 0x3e	; 62
    308c:	9b 83       	std	Y+3, r25	; 0x03
    308e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3090:	0f b6       	in	r0, 0x3f	; 63
    3092:	f8 94       	cli
    3094:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3096:	ea 81       	ldd	r30, Y+2	; 0x02
    3098:	fb 81       	ldd	r31, Y+3	; 0x03
    309a:	82 8d       	ldd	r24, Z+26	; 0x1a
    309c:	88 23       	and	r24, r24
    309e:	19 f4       	brne	.+6      	; 0x30a6 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    30a0:	81 e0       	ldi	r24, 0x01	; 1
    30a2:	89 83       	std	Y+1, r24	; 0x01
    30a4:	01 c0       	rjmp	.+2      	; 0x30a8 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    30a6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    30a8:	0f 90       	pop	r0
    30aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    30ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    30ae:	0f 90       	pop	r0
    30b0:	0f 90       	pop	r0
    30b2:	0f 90       	pop	r0
    30b4:	cf 91       	pop	r28
    30b6:	df 91       	pop	r29
    30b8:	08 95       	ret

000030ba <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    30ba:	df 93       	push	r29
    30bc:	cf 93       	push	r28
    30be:	00 d0       	rcall	.+0      	; 0x30c0 <xQueueIsQueueEmptyFromISR+0x6>
    30c0:	0f 92       	push	r0
    30c2:	cd b7       	in	r28, 0x3d	; 61
    30c4:	de b7       	in	r29, 0x3e	; 62
    30c6:	9b 83       	std	Y+3, r25	; 0x03
    30c8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    30ca:	ea 81       	ldd	r30, Y+2	; 0x02
    30cc:	fb 81       	ldd	r31, Y+3	; 0x03
    30ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    30d0:	88 23       	and	r24, r24
    30d2:	19 f4       	brne	.+6      	; 0x30da <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    30d4:	81 e0       	ldi	r24, 0x01	; 1
    30d6:	89 83       	std	Y+1, r24	; 0x01
    30d8:	01 c0       	rjmp	.+2      	; 0x30dc <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    30da:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    30dc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    30de:	0f 90       	pop	r0
    30e0:	0f 90       	pop	r0
    30e2:	0f 90       	pop	r0
    30e4:	cf 91       	pop	r28
    30e6:	df 91       	pop	r29
    30e8:	08 95       	ret

000030ea <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    30ea:	df 93       	push	r29
    30ec:	cf 93       	push	r28
    30ee:	00 d0       	rcall	.+0      	; 0x30f0 <prvIsQueueFull+0x6>
    30f0:	0f 92       	push	r0
    30f2:	cd b7       	in	r28, 0x3d	; 61
    30f4:	de b7       	in	r29, 0x3e	; 62
    30f6:	9b 83       	std	Y+3, r25	; 0x03
    30f8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    30fa:	0f b6       	in	r0, 0x3f	; 63
    30fc:	f8 94       	cli
    30fe:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3100:	ea 81       	ldd	r30, Y+2	; 0x02
    3102:	fb 81       	ldd	r31, Y+3	; 0x03
    3104:	92 8d       	ldd	r25, Z+26	; 0x1a
    3106:	ea 81       	ldd	r30, Y+2	; 0x02
    3108:	fb 81       	ldd	r31, Y+3	; 0x03
    310a:	83 8d       	ldd	r24, Z+27	; 0x1b
    310c:	98 17       	cp	r25, r24
    310e:	19 f4       	brne	.+6      	; 0x3116 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3110:	81 e0       	ldi	r24, 0x01	; 1
    3112:	89 83       	std	Y+1, r24	; 0x01
    3114:	01 c0       	rjmp	.+2      	; 0x3118 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    3116:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3118:	0f 90       	pop	r0
    311a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    311c:	89 81       	ldd	r24, Y+1	; 0x01
}
    311e:	0f 90       	pop	r0
    3120:	0f 90       	pop	r0
    3122:	0f 90       	pop	r0
    3124:	cf 91       	pop	r28
    3126:	df 91       	pop	r29
    3128:	08 95       	ret

0000312a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    312a:	df 93       	push	r29
    312c:	cf 93       	push	r28
    312e:	00 d0       	rcall	.+0      	; 0x3130 <xQueueIsQueueFullFromISR+0x6>
    3130:	0f 92       	push	r0
    3132:	cd b7       	in	r28, 0x3d	; 61
    3134:	de b7       	in	r29, 0x3e	; 62
    3136:	9b 83       	std	Y+3, r25	; 0x03
    3138:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    313a:	ea 81       	ldd	r30, Y+2	; 0x02
    313c:	fb 81       	ldd	r31, Y+3	; 0x03
    313e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3140:	ea 81       	ldd	r30, Y+2	; 0x02
    3142:	fb 81       	ldd	r31, Y+3	; 0x03
    3144:	83 8d       	ldd	r24, Z+27	; 0x1b
    3146:	98 17       	cp	r25, r24
    3148:	19 f4       	brne	.+6      	; 0x3150 <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    314a:	81 e0       	ldi	r24, 0x01	; 1
    314c:	89 83       	std	Y+1, r24	; 0x01
    314e:	01 c0       	rjmp	.+2      	; 0x3152 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    3150:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3152:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3154:	0f 90       	pop	r0
    3156:	0f 90       	pop	r0
    3158:	0f 90       	pop	r0
    315a:	cf 91       	pop	r28
    315c:	df 91       	pop	r29
    315e:	08 95       	ret

00003160 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    3160:	df 93       	push	r29
    3162:	cf 93       	push	r28
    3164:	cd b7       	in	r28, 0x3d	; 61
    3166:	de b7       	in	r29, 0x3e	; 62
    3168:	2a 97       	sbiw	r28, 0x0a	; 10
    316a:	0f b6       	in	r0, 0x3f	; 63
    316c:	f8 94       	cli
    316e:	de bf       	out	0x3e, r29	; 62
    3170:	0f be       	out	0x3f, r0	; 63
    3172:	cd bf       	out	0x3d, r28	; 61
    3174:	9d 83       	std	Y+5, r25	; 0x05
    3176:	8c 83       	std	Y+4, r24	; 0x04
    3178:	7f 83       	std	Y+7, r23	; 0x07
    317a:	6e 83       	std	Y+6, r22	; 0x06
    317c:	59 87       	std	Y+9, r21	; 0x09
    317e:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3180:	8c 81       	ldd	r24, Y+4	; 0x04
    3182:	9d 81       	ldd	r25, Y+5	; 0x05
    3184:	9a 83       	std	Y+2, r25	; 0x02
    3186:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    3188:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	9a 81       	ldd	r25, Y+2	; 0x02
    318e:	0e 94 75 18 	call	0x30ea	; 0x30ea <prvIsQueueFull>
    3192:	88 23       	and	r24, r24
    3194:	a9 f0       	breq	.+42     	; 0x31c0 <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3196:	88 85       	ldd	r24, Y+8	; 0x08
    3198:	99 85       	ldd	r25, Y+9	; 0x09
    319a:	00 97       	sbiw	r24, 0x00	; 0
    319c:	71 f0       	breq	.+28     	; 0x31ba <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    319e:	89 81       	ldd	r24, Y+1	; 0x01
    31a0:	9a 81       	ldd	r25, Y+2	; 0x02
    31a2:	9c 01       	movw	r18, r24
    31a4:	28 5f       	subi	r18, 0xF8	; 248
    31a6:	3f 4f       	sbci	r19, 0xFF	; 255
    31a8:	88 85       	ldd	r24, Y+8	; 0x08
    31aa:	99 85       	ldd	r25, Y+9	; 0x09
    31ac:	b9 01       	movw	r22, r18
    31ae:	0e 94 cd 07 	call	0xf9a	; 0xf9a <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    31b2:	78 94       	sei
					return errQUEUE_BLOCKED;
    31b4:	8c ef       	ldi	r24, 0xFC	; 252
    31b6:	8a 87       	std	Y+10, r24	; 0x0a
    31b8:	2a c0       	rjmp	.+84     	; 0x320e <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    31ba:	78 94       	sei
					return errQUEUE_FULL;
    31bc:	1a 86       	std	Y+10, r1	; 0x0a
    31be:	27 c0       	rjmp	.+78     	; 0x320e <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    31c0:	78 94       	sei

		portDISABLE_INTERRUPTS();
    31c2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    31c4:	e9 81       	ldd	r30, Y+1	; 0x01
    31c6:	fa 81       	ldd	r31, Y+2	; 0x02
    31c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    31ca:	e9 81       	ldd	r30, Y+1	; 0x01
    31cc:	fa 81       	ldd	r31, Y+2	; 0x02
    31ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    31d0:	98 17       	cp	r25, r24
    31d2:	c8 f4       	brcc	.+50     	; 0x3206 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    31d4:	89 81       	ldd	r24, Y+1	; 0x01
    31d6:	9a 81       	ldd	r25, Y+2	; 0x02
    31d8:	2e 81       	ldd	r18, Y+6	; 0x06
    31da:	3f 81       	ldd	r19, Y+7	; 0x07
    31dc:	b9 01       	movw	r22, r18
    31de:	40 e0       	ldi	r20, 0x00	; 0
    31e0:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvCopyDataToQueue>
				xReturn = pdPASS;
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31e8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ea:	fa 81       	ldd	r31, Y+2	; 0x02
    31ec:	81 89       	ldd	r24, Z+17	; 0x11
    31ee:	88 23       	and	r24, r24
    31f0:	59 f0       	breq	.+22     	; 0x3208 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
    31f4:	9a 81       	ldd	r25, Y+2	; 0x02
    31f6:	41 96       	adiw	r24, 0x11	; 17
    31f8:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <xCoRoutineRemoveFromEventList>
    31fc:	88 23       	and	r24, r24
    31fe:	21 f0       	breq	.+8      	; 0x3208 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    3200:	8b ef       	ldi	r24, 0xFB	; 251
    3202:	8b 83       	std	Y+3, r24	; 0x03
    3204:	01 c0       	rjmp	.+2      	; 0x3208 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    3206:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    3208:	78 94       	sei

		return xReturn;
    320a:	8b 81       	ldd	r24, Y+3	; 0x03
    320c:	8a 87       	std	Y+10, r24	; 0x0a
    320e:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    3210:	2a 96       	adiw	r28, 0x0a	; 10
    3212:	0f b6       	in	r0, 0x3f	; 63
    3214:	f8 94       	cli
    3216:	de bf       	out	0x3e, r29	; 62
    3218:	0f be       	out	0x3f, r0	; 63
    321a:	cd bf       	out	0x3d, r28	; 61
    321c:	cf 91       	pop	r28
    321e:	df 91       	pop	r29
    3220:	08 95       	ret

00003222 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    3222:	df 93       	push	r29
    3224:	cf 93       	push	r28
    3226:	cd b7       	in	r28, 0x3d	; 61
    3228:	de b7       	in	r29, 0x3e	; 62
    322a:	2a 97       	sbiw	r28, 0x0a	; 10
    322c:	0f b6       	in	r0, 0x3f	; 63
    322e:	f8 94       	cli
    3230:	de bf       	out	0x3e, r29	; 62
    3232:	0f be       	out	0x3f, r0	; 63
    3234:	cd bf       	out	0x3d, r28	; 61
    3236:	9d 83       	std	Y+5, r25	; 0x05
    3238:	8c 83       	std	Y+4, r24	; 0x04
    323a:	7f 83       	std	Y+7, r23	; 0x07
    323c:	6e 83       	std	Y+6, r22	; 0x06
    323e:	59 87       	std	Y+9, r21	; 0x09
    3240:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3242:	8c 81       	ldd	r24, Y+4	; 0x04
    3244:	9d 81       	ldd	r25, Y+5	; 0x05
    3246:	9a 83       	std	Y+2, r25	; 0x02
    3248:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    324a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    324c:	e9 81       	ldd	r30, Y+1	; 0x01
    324e:	fa 81       	ldd	r31, Y+2	; 0x02
    3250:	82 8d       	ldd	r24, Z+26	; 0x1a
    3252:	88 23       	and	r24, r24
    3254:	a9 f4       	brne	.+42     	; 0x3280 <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3256:	88 85       	ldd	r24, Y+8	; 0x08
    3258:	99 85       	ldd	r25, Y+9	; 0x09
    325a:	00 97       	sbiw	r24, 0x00	; 0
    325c:	71 f0       	breq	.+28     	; 0x327a <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    325e:	89 81       	ldd	r24, Y+1	; 0x01
    3260:	9a 81       	ldd	r25, Y+2	; 0x02
    3262:	9c 01       	movw	r18, r24
    3264:	2f 5e       	subi	r18, 0xEF	; 239
    3266:	3f 4f       	sbci	r19, 0xFF	; 255
    3268:	88 85       	ldd	r24, Y+8	; 0x08
    326a:	99 85       	ldd	r25, Y+9	; 0x09
    326c:	b9 01       	movw	r22, r18
    326e:	0e 94 cd 07 	call	0xf9a	; 0xf9a <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3272:	78 94       	sei
					return errQUEUE_BLOCKED;
    3274:	8c ef       	ldi	r24, 0xFC	; 252
    3276:	8a 87       	std	Y+10, r24	; 0x0a
    3278:	58 c0       	rjmp	.+176    	; 0x332a <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    327a:	78 94       	sei
					return errQUEUE_FULL;
    327c:	1a 86       	std	Y+10, r1	; 0x0a
    327e:	55 c0       	rjmp	.+170    	; 0x332a <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    3280:	78 94       	sei

		portDISABLE_INTERRUPTS();
    3282:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3284:	e9 81       	ldd	r30, Y+1	; 0x01
    3286:	fa 81       	ldd	r31, Y+2	; 0x02
    3288:	82 8d       	ldd	r24, Z+26	; 0x1a
    328a:	88 23       	and	r24, r24
    328c:	09 f4       	brne	.+2      	; 0x3290 <xQueueCRReceive+0x6e>
    328e:	49 c0       	rjmp	.+146    	; 0x3322 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3290:	e9 81       	ldd	r30, Y+1	; 0x01
    3292:	fa 81       	ldd	r31, Y+2	; 0x02
    3294:	26 81       	ldd	r18, Z+6	; 0x06
    3296:	37 81       	ldd	r19, Z+7	; 0x07
    3298:	e9 81       	ldd	r30, Y+1	; 0x01
    329a:	fa 81       	ldd	r31, Y+2	; 0x02
    329c:	84 8d       	ldd	r24, Z+28	; 0x1c
    329e:	88 2f       	mov	r24, r24
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	82 0f       	add	r24, r18
    32a4:	93 1f       	adc	r25, r19
    32a6:	e9 81       	ldd	r30, Y+1	; 0x01
    32a8:	fa 81       	ldd	r31, Y+2	; 0x02
    32aa:	97 83       	std	Z+7, r25	; 0x07
    32ac:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    32ae:	e9 81       	ldd	r30, Y+1	; 0x01
    32b0:	fa 81       	ldd	r31, Y+2	; 0x02
    32b2:	26 81       	ldd	r18, Z+6	; 0x06
    32b4:	37 81       	ldd	r19, Z+7	; 0x07
    32b6:	e9 81       	ldd	r30, Y+1	; 0x01
    32b8:	fa 81       	ldd	r31, Y+2	; 0x02
    32ba:	82 81       	ldd	r24, Z+2	; 0x02
    32bc:	93 81       	ldd	r25, Z+3	; 0x03
    32be:	28 17       	cp	r18, r24
    32c0:	39 07       	cpc	r19, r25
    32c2:	40 f0       	brcs	.+16     	; 0x32d4 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    32c4:	e9 81       	ldd	r30, Y+1	; 0x01
    32c6:	fa 81       	ldd	r31, Y+2	; 0x02
    32c8:	80 81       	ld	r24, Z
    32ca:	91 81       	ldd	r25, Z+1	; 0x01
    32cc:	e9 81       	ldd	r30, Y+1	; 0x01
    32ce:	fa 81       	ldd	r31, Y+2	; 0x02
    32d0:	97 83       	std	Z+7, r25	; 0x07
    32d2:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    32d4:	e9 81       	ldd	r30, Y+1	; 0x01
    32d6:	fa 81       	ldd	r31, Y+2	; 0x02
    32d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    32da:	81 50       	subi	r24, 0x01	; 1
    32dc:	e9 81       	ldd	r30, Y+1	; 0x01
    32de:	fa 81       	ldd	r31, Y+2	; 0x02
    32e0:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    32e2:	e9 81       	ldd	r30, Y+1	; 0x01
    32e4:	fa 81       	ldd	r31, Y+2	; 0x02
    32e6:	46 81       	ldd	r20, Z+6	; 0x06
    32e8:	57 81       	ldd	r21, Z+7	; 0x07
    32ea:	e9 81       	ldd	r30, Y+1	; 0x01
    32ec:	fa 81       	ldd	r31, Y+2	; 0x02
    32ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    32f0:	28 2f       	mov	r18, r24
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	8e 81       	ldd	r24, Y+6	; 0x06
    32f6:	9f 81       	ldd	r25, Y+7	; 0x07
    32f8:	ba 01       	movw	r22, r20
    32fa:	a9 01       	movw	r20, r18
    32fc:	0e 94 70 30 	call	0x60e0	; 0x60e0 <memcpy>

				xReturn = pdPASS;
    3300:	81 e0       	ldi	r24, 0x01	; 1
    3302:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3304:	e9 81       	ldd	r30, Y+1	; 0x01
    3306:	fa 81       	ldd	r31, Y+2	; 0x02
    3308:	80 85       	ldd	r24, Z+8	; 0x08
    330a:	88 23       	and	r24, r24
    330c:	59 f0       	breq	.+22     	; 0x3324 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    330e:	89 81       	ldd	r24, Y+1	; 0x01
    3310:	9a 81       	ldd	r25, Y+2	; 0x02
    3312:	08 96       	adiw	r24, 0x08	; 8
    3314:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <xCoRoutineRemoveFromEventList>
    3318:	88 23       	and	r24, r24
    331a:	21 f0       	breq	.+8      	; 0x3324 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    331c:	8b ef       	ldi	r24, 0xFB	; 251
    331e:	8b 83       	std	Y+3, r24	; 0x03
    3320:	01 c0       	rjmp	.+2      	; 0x3324 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    3322:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    3324:	78 94       	sei

		return xReturn;
    3326:	8b 81       	ldd	r24, Y+3	; 0x03
    3328:	8a 87       	std	Y+10, r24	; 0x0a
    332a:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    332c:	2a 96       	adiw	r28, 0x0a	; 10
    332e:	0f b6       	in	r0, 0x3f	; 63
    3330:	f8 94       	cli
    3332:	de bf       	out	0x3e, r29	; 62
    3334:	0f be       	out	0x3f, r0	; 63
    3336:	cd bf       	out	0x3d, r28	; 61
    3338:	cf 91       	pop	r28
    333a:	df 91       	pop	r29
    333c:	08 95       	ret

0000333e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    333e:	df 93       	push	r29
    3340:	cf 93       	push	r28
    3342:	cd b7       	in	r28, 0x3d	; 61
    3344:	de b7       	in	r29, 0x3e	; 62
    3346:	28 97       	sbiw	r28, 0x08	; 8
    3348:	0f b6       	in	r0, 0x3f	; 63
    334a:	f8 94       	cli
    334c:	de bf       	out	0x3e, r29	; 62
    334e:	0f be       	out	0x3f, r0	; 63
    3350:	cd bf       	out	0x3d, r28	; 61
    3352:	9c 83       	std	Y+4, r25	; 0x04
    3354:	8b 83       	std	Y+3, r24	; 0x03
    3356:	7e 83       	std	Y+6, r23	; 0x06
    3358:	6d 83       	std	Y+5, r22	; 0x05
    335a:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    335c:	8b 81       	ldd	r24, Y+3	; 0x03
    335e:	9c 81       	ldd	r25, Y+4	; 0x04
    3360:	9a 83       	std	Y+2, r25	; 0x02
    3362:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3364:	e9 81       	ldd	r30, Y+1	; 0x01
    3366:	fa 81       	ldd	r31, Y+2	; 0x02
    3368:	92 8d       	ldd	r25, Z+26	; 0x1a
    336a:	e9 81       	ldd	r30, Y+1	; 0x01
    336c:	fa 81       	ldd	r31, Y+2	; 0x02
    336e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3370:	98 17       	cp	r25, r24
    3372:	d0 f4       	brcc	.+52     	; 0x33a8 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3374:	89 81       	ldd	r24, Y+1	; 0x01
    3376:	9a 81       	ldd	r25, Y+2	; 0x02
    3378:	2d 81       	ldd	r18, Y+5	; 0x05
    337a:	3e 81       	ldd	r19, Y+6	; 0x06
    337c:	b9 01       	movw	r22, r18
    337e:	40 e0       	ldi	r20, 0x00	; 0
    3380:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    3384:	8f 81       	ldd	r24, Y+7	; 0x07
    3386:	88 23       	and	r24, r24
    3388:	79 f4       	brne	.+30     	; 0x33a8 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	81 89       	ldd	r24, Z+17	; 0x11
    3390:	88 23       	and	r24, r24
    3392:	51 f0       	breq	.+20     	; 0x33a8 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3394:	89 81       	ldd	r24, Y+1	; 0x01
    3396:	9a 81       	ldd	r25, Y+2	; 0x02
    3398:	41 96       	adiw	r24, 0x11	; 17
    339a:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <xCoRoutineRemoveFromEventList>
    339e:	88 23       	and	r24, r24
    33a0:	19 f0       	breq	.+6      	; 0x33a8 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	88 87       	std	Y+8, r24	; 0x08
    33a6:	02 c0       	rjmp	.+4      	; 0x33ac <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    33a8:	8f 81       	ldd	r24, Y+7	; 0x07
    33aa:	88 87       	std	Y+8, r24	; 0x08
    33ac:	88 85       	ldd	r24, Y+8	; 0x08
	}
    33ae:	28 96       	adiw	r28, 0x08	; 8
    33b0:	0f b6       	in	r0, 0x3f	; 63
    33b2:	f8 94       	cli
    33b4:	de bf       	out	0x3e, r29	; 62
    33b6:	0f be       	out	0x3f, r0	; 63
    33b8:	cd bf       	out	0x3d, r28	; 61
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    33c0:	df 93       	push	r29
    33c2:	cf 93       	push	r28
    33c4:	cd b7       	in	r28, 0x3d	; 61
    33c6:	de b7       	in	r29, 0x3e	; 62
    33c8:	29 97       	sbiw	r28, 0x09	; 9
    33ca:	0f b6       	in	r0, 0x3f	; 63
    33cc:	f8 94       	cli
    33ce:	de bf       	out	0x3e, r29	; 62
    33d0:	0f be       	out	0x3f, r0	; 63
    33d2:	cd bf       	out	0x3d, r28	; 61
    33d4:	9d 83       	std	Y+5, r25	; 0x05
    33d6:	8c 83       	std	Y+4, r24	; 0x04
    33d8:	7f 83       	std	Y+7, r23	; 0x07
    33da:	6e 83       	std	Y+6, r22	; 0x06
    33dc:	59 87       	std	Y+9, r21	; 0x09
    33de:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    33e0:	8c 81       	ldd	r24, Y+4	; 0x04
    33e2:	9d 81       	ldd	r25, Y+5	; 0x05
    33e4:	9a 83       	std	Y+2, r25	; 0x02
    33e6:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    33ee:	88 23       	and	r24, r24
    33f0:	09 f4       	brne	.+2      	; 0x33f4 <xQueueCRReceiveFromISR+0x34>
    33f2:	50 c0       	rjmp	.+160    	; 0x3494 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    33f4:	e9 81       	ldd	r30, Y+1	; 0x01
    33f6:	fa 81       	ldd	r31, Y+2	; 0x02
    33f8:	26 81       	ldd	r18, Z+6	; 0x06
    33fa:	37 81       	ldd	r19, Z+7	; 0x07
    33fc:	e9 81       	ldd	r30, Y+1	; 0x01
    33fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3400:	84 8d       	ldd	r24, Z+28	; 0x1c
    3402:	88 2f       	mov	r24, r24
    3404:	90 e0       	ldi	r25, 0x00	; 0
    3406:	82 0f       	add	r24, r18
    3408:	93 1f       	adc	r25, r19
    340a:	e9 81       	ldd	r30, Y+1	; 0x01
    340c:	fa 81       	ldd	r31, Y+2	; 0x02
    340e:	97 83       	std	Z+7, r25	; 0x07
    3410:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    3412:	e9 81       	ldd	r30, Y+1	; 0x01
    3414:	fa 81       	ldd	r31, Y+2	; 0x02
    3416:	26 81       	ldd	r18, Z+6	; 0x06
    3418:	37 81       	ldd	r19, Z+7	; 0x07
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	82 81       	ldd	r24, Z+2	; 0x02
    3420:	93 81       	ldd	r25, Z+3	; 0x03
    3422:	28 17       	cp	r18, r24
    3424:	39 07       	cpc	r19, r25
    3426:	40 f0       	brcs	.+16     	; 0x3438 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3428:	e9 81       	ldd	r30, Y+1	; 0x01
    342a:	fa 81       	ldd	r31, Y+2	; 0x02
    342c:	80 81       	ld	r24, Z
    342e:	91 81       	ldd	r25, Z+1	; 0x01
    3430:	e9 81       	ldd	r30, Y+1	; 0x01
    3432:	fa 81       	ldd	r31, Y+2	; 0x02
    3434:	97 83       	std	Z+7, r25	; 0x07
    3436:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    3438:	e9 81       	ldd	r30, Y+1	; 0x01
    343a:	fa 81       	ldd	r31, Y+2	; 0x02
    343c:	82 8d       	ldd	r24, Z+26	; 0x1a
    343e:	81 50       	subi	r24, 0x01	; 1
    3440:	e9 81       	ldd	r30, Y+1	; 0x01
    3442:	fa 81       	ldd	r31, Y+2	; 0x02
    3444:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3446:	e9 81       	ldd	r30, Y+1	; 0x01
    3448:	fa 81       	ldd	r31, Y+2	; 0x02
    344a:	46 81       	ldd	r20, Z+6	; 0x06
    344c:	57 81       	ldd	r21, Z+7	; 0x07
    344e:	e9 81       	ldd	r30, Y+1	; 0x01
    3450:	fa 81       	ldd	r31, Y+2	; 0x02
    3452:	84 8d       	ldd	r24, Z+28	; 0x1c
    3454:	28 2f       	mov	r18, r24
    3456:	30 e0       	ldi	r19, 0x00	; 0
    3458:	8e 81       	ldd	r24, Y+6	; 0x06
    345a:	9f 81       	ldd	r25, Y+7	; 0x07
    345c:	ba 01       	movw	r22, r20
    345e:	a9 01       	movw	r20, r18
    3460:	0e 94 70 30 	call	0x60e0	; 0x60e0 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    3464:	e8 85       	ldd	r30, Y+8	; 0x08
    3466:	f9 85       	ldd	r31, Y+9	; 0x09
    3468:	80 81       	ld	r24, Z
    346a:	88 23       	and	r24, r24
    346c:	81 f4       	brne	.+32     	; 0x348e <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    346e:	e9 81       	ldd	r30, Y+1	; 0x01
    3470:	fa 81       	ldd	r31, Y+2	; 0x02
    3472:	80 85       	ldd	r24, Z+8	; 0x08
    3474:	88 23       	and	r24, r24
    3476:	59 f0       	breq	.+22     	; 0x348e <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3478:	89 81       	ldd	r24, Y+1	; 0x01
    347a:	9a 81       	ldd	r25, Y+2	; 0x02
    347c:	08 96       	adiw	r24, 0x08	; 8
    347e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <xCoRoutineRemoveFromEventList>
    3482:	88 23       	and	r24, r24
    3484:	21 f0       	breq	.+8      	; 0x348e <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    3486:	e8 85       	ldd	r30, Y+8	; 0x08
    3488:	f9 85       	ldd	r31, Y+9	; 0x09
    348a:	81 e0       	ldi	r24, 0x01	; 1
    348c:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    348e:	81 e0       	ldi	r24, 0x01	; 1
    3490:	8b 83       	std	Y+3, r24	; 0x03
    3492:	01 c0       	rjmp	.+2      	; 0x3496 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    3494:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    3496:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3498:	29 96       	adiw	r28, 0x09	; 9
    349a:	0f b6       	in	r0, 0x3f	; 63
    349c:	f8 94       	cli
    349e:	de bf       	out	0x3e, r29	; 62
    34a0:	0f be       	out	0x3f, r0	; 63
    34a2:	cd bf       	out	0x3d, r28	; 61
    34a4:	cf 91       	pop	r28
    34a6:	df 91       	pop	r29
    34a8:	08 95       	ret

000034aa <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    34aa:	af 92       	push	r10
    34ac:	bf 92       	push	r11
    34ae:	cf 92       	push	r12
    34b0:	df 92       	push	r13
    34b2:	ef 92       	push	r14
    34b4:	ff 92       	push	r15
    34b6:	0f 93       	push	r16
    34b8:	1f 93       	push	r17
    34ba:	df 93       	push	r29
    34bc:	cf 93       	push	r28
    34be:	cd b7       	in	r28, 0x3d	; 61
    34c0:	de b7       	in	r29, 0x3e	; 62
    34c2:	64 97       	sbiw	r28, 0x14	; 20
    34c4:	0f b6       	in	r0, 0x3f	; 63
    34c6:	f8 94       	cli
    34c8:	de bf       	out	0x3e, r29	; 62
    34ca:	0f be       	out	0x3f, r0	; 63
    34cc:	cd bf       	out	0x3d, r28	; 61
    34ce:	9f 83       	std	Y+7, r25	; 0x07
    34d0:	8e 83       	std	Y+6, r24	; 0x06
    34d2:	79 87       	std	Y+9, r23	; 0x09
    34d4:	68 87       	std	Y+8, r22	; 0x08
    34d6:	5b 87       	std	Y+11, r21	; 0x0b
    34d8:	4a 87       	std	Y+10, r20	; 0x0a
    34da:	3d 87       	std	Y+13, r19	; 0x0d
    34dc:	2c 87       	std	Y+12, r18	; 0x0c
    34de:	0e 87       	std	Y+14, r16	; 0x0e
    34e0:	f8 8a       	std	Y+16, r15	; 0x10
    34e2:	ef 86       	std	Y+15, r14	; 0x0f
    34e4:	da 8a       	std	Y+18, r13	; 0x12
    34e6:	c9 8a       	std	Y+17, r12	; 0x11
    34e8:	bc 8a       	std	Y+20, r11	; 0x14
    34ea:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    34ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    34ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    34f0:	29 89       	ldd	r18, Y+17	; 0x11
    34f2:	3a 89       	ldd	r19, Y+18	; 0x12
    34f4:	b9 01       	movw	r22, r18
    34f6:	0e 94 bb 22 	call	0x4576	; 0x4576 <prvAllocateTCBAndStack>
    34fa:	9c 83       	std	Y+4, r25	; 0x04
    34fc:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    34fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3500:	9c 81       	ldd	r25, Y+4	; 0x04
    3502:	00 97       	sbiw	r24, 0x00	; 0
    3504:	09 f4       	brne	.+2      	; 0x3508 <xTaskGenericCreate+0x5e>
    3506:	8d c0       	rjmp	.+282    	; 0x3622 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    3508:	eb 81       	ldd	r30, Y+3	; 0x03
    350a:	fc 81       	ldd	r31, Y+4	; 0x04
    350c:	27 89       	ldd	r18, Z+23	; 0x17
    350e:	30 8d       	ldd	r19, Z+24	; 0x18
    3510:	8a 85       	ldd	r24, Y+10	; 0x0a
    3512:	9b 85       	ldd	r25, Y+11	; 0x0b
    3514:	01 97       	sbiw	r24, 0x01	; 1
    3516:	82 0f       	add	r24, r18
    3518:	93 1f       	adc	r25, r19
    351a:	9a 83       	std	Y+2, r25	; 0x02
    351c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    351e:	8b 81       	ldd	r24, Y+3	; 0x03
    3520:	9c 81       	ldd	r25, Y+4	; 0x04
    3522:	28 85       	ldd	r18, Y+8	; 0x08
    3524:	39 85       	ldd	r19, Y+9	; 0x09
    3526:	eb 89       	ldd	r30, Y+19	; 0x13
    3528:	fc 89       	ldd	r31, Y+20	; 0x14
    352a:	aa 85       	ldd	r26, Y+10	; 0x0a
    352c:	bb 85       	ldd	r27, Y+11	; 0x0b
    352e:	b9 01       	movw	r22, r18
    3530:	4e 85       	ldd	r20, Y+14	; 0x0e
    3532:	9f 01       	movw	r18, r30
    3534:	8d 01       	movw	r16, r26
    3536:	0e 94 7c 21 	call	0x42f8	; 0x42f8 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    353a:	89 81       	ldd	r24, Y+1	; 0x01
    353c:	9a 81       	ldd	r25, Y+2	; 0x02
    353e:	2e 81       	ldd	r18, Y+6	; 0x06
    3540:	3f 81       	ldd	r19, Y+7	; 0x07
    3542:	4c 85       	ldd	r20, Y+12	; 0x0c
    3544:	5d 85       	ldd	r21, Y+13	; 0x0d
    3546:	b9 01       	movw	r22, r18
    3548:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <pxPortInitialiseStack>
    354c:	eb 81       	ldd	r30, Y+3	; 0x03
    354e:	fc 81       	ldd	r31, Y+4	; 0x04
    3550:	91 83       	std	Z+1, r25	; 0x01
    3552:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3554:	8f 85       	ldd	r24, Y+15	; 0x0f
    3556:	98 89       	ldd	r25, Y+16	; 0x10
    3558:	00 97       	sbiw	r24, 0x00	; 0
    355a:	31 f0       	breq	.+12     	; 0x3568 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    355c:	ef 85       	ldd	r30, Y+15	; 0x0f
    355e:	f8 89       	ldd	r31, Y+16	; 0x10
    3560:	8b 81       	ldd	r24, Y+3	; 0x03
    3562:	9c 81       	ldd	r25, Y+4	; 0x04
    3564:	91 83       	std	Z+1, r25	; 0x01
    3566:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3568:	0f b6       	in	r0, 0x3f	; 63
    356a:	f8 94       	cli
    356c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    356e:	80 91 9a 05 	lds	r24, 0x059A
    3572:	8f 5f       	subi	r24, 0xFF	; 255
    3574:	80 93 9a 05 	sts	0x059A, r24
			if( pxCurrentTCB == NULL )
    3578:	80 91 97 05 	lds	r24, 0x0597
    357c:	90 91 98 05 	lds	r25, 0x0598
    3580:	00 97       	sbiw	r24, 0x00	; 0
    3582:	69 f4       	brne	.+26     	; 0x359e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3584:	8b 81       	ldd	r24, Y+3	; 0x03
    3586:	9c 81       	ldd	r25, Y+4	; 0x04
    3588:	90 93 98 05 	sts	0x0598, r25
    358c:	80 93 97 05 	sts	0x0597, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3590:	80 91 9a 05 	lds	r24, 0x059A
    3594:	81 30       	cpi	r24, 0x01	; 1
    3596:	a9 f4       	brne	.+42     	; 0x35c2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3598:	0e 94 f6 21 	call	0x43ec	; 0x43ec <prvInitialiseTaskLists>
    359c:	12 c0       	rjmp	.+36     	; 0x35c2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    359e:	80 91 9e 05 	lds	r24, 0x059E
    35a2:	88 23       	and	r24, r24
    35a4:	71 f4       	brne	.+28     	; 0x35c2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    35a6:	e0 91 97 05 	lds	r30, 0x0597
    35aa:	f0 91 98 05 	lds	r31, 0x0598
    35ae:	96 89       	ldd	r25, Z+22	; 0x16
    35b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    35b2:	89 17       	cp	r24, r25
    35b4:	30 f0       	brcs	.+12     	; 0x35c2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    35b6:	8b 81       	ldd	r24, Y+3	; 0x03
    35b8:	9c 81       	ldd	r25, Y+4	; 0x04
    35ba:	90 93 98 05 	sts	0x0598, r25
    35be:	80 93 97 05 	sts	0x0597, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    35c2:	80 91 a2 05 	lds	r24, 0x05A2
    35c6:	8f 5f       	subi	r24, 0xFF	; 255
    35c8:	80 93 a2 05 	sts	0x05A2, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    35cc:	eb 81       	ldd	r30, Y+3	; 0x03
    35ce:	fc 81       	ldd	r31, Y+4	; 0x04
    35d0:	96 89       	ldd	r25, Z+22	; 0x16
    35d2:	80 91 9d 05 	lds	r24, 0x059D
    35d6:	89 17       	cp	r24, r25
    35d8:	28 f4       	brcc	.+10     	; 0x35e4 <xTaskGenericCreate+0x13a>
    35da:	eb 81       	ldd	r30, Y+3	; 0x03
    35dc:	fc 81       	ldd	r31, Y+4	; 0x04
    35de:	86 89       	ldd	r24, Z+22	; 0x16
    35e0:	80 93 9d 05 	sts	0x059D, r24
    35e4:	eb 81       	ldd	r30, Y+3	; 0x03
    35e6:	fc 81       	ldd	r31, Y+4	; 0x04
    35e8:	86 89       	ldd	r24, Z+22	; 0x16
    35ea:	28 2f       	mov	r18, r24
    35ec:	30 e0       	ldi	r19, 0x00	; 0
    35ee:	c9 01       	movw	r24, r18
    35f0:	88 0f       	add	r24, r24
    35f2:	99 1f       	adc	r25, r25
    35f4:	88 0f       	add	r24, r24
    35f6:	99 1f       	adc	r25, r25
    35f8:	88 0f       	add	r24, r24
    35fa:	99 1f       	adc	r25, r25
    35fc:	82 0f       	add	r24, r18
    35fe:	93 1f       	adc	r25, r19
    3600:	ac 01       	movw	r20, r24
    3602:	4c 55       	subi	r20, 0x5C	; 92
    3604:	5a 4f       	sbci	r21, 0xFA	; 250
    3606:	8b 81       	ldd	r24, Y+3	; 0x03
    3608:	9c 81       	ldd	r25, Y+4	; 0x04
    360a:	9c 01       	movw	r18, r24
    360c:	2e 5f       	subi	r18, 0xFE	; 254
    360e:	3f 4f       	sbci	r19, 0xFF	; 255
    3610:	ca 01       	movw	r24, r20
    3612:	b9 01       	movw	r22, r18
    3614:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

			xReturn = pdPASS;
    3618:	81 e0       	ldi	r24, 0x01	; 1
    361a:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    361c:	0f 90       	pop	r0
    361e:	0f be       	out	0x3f, r0	; 63
    3620:	02 c0       	rjmp	.+4      	; 0x3626 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3622:	8f ef       	ldi	r24, 0xFF	; 255
    3624:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3626:	8d 81       	ldd	r24, Y+5	; 0x05
    3628:	81 30       	cpi	r24, 0x01	; 1
    362a:	71 f4       	brne	.+28     	; 0x3648 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    362c:	80 91 9e 05 	lds	r24, 0x059E
    3630:	88 23       	and	r24, r24
    3632:	51 f0       	breq	.+20     	; 0x3648 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3634:	e0 91 97 05 	lds	r30, 0x0597
    3638:	f0 91 98 05 	lds	r31, 0x0598
    363c:	96 89       	ldd	r25, Z+22	; 0x16
    363e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3640:	98 17       	cp	r25, r24
    3642:	10 f4       	brcc	.+4      	; 0x3648 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    3644:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3648:	8d 81       	ldd	r24, Y+5	; 0x05
}
    364a:	64 96       	adiw	r28, 0x14	; 20
    364c:	0f b6       	in	r0, 0x3f	; 63
    364e:	f8 94       	cli
    3650:	de bf       	out	0x3e, r29	; 62
    3652:	0f be       	out	0x3f, r0	; 63
    3654:	cd bf       	out	0x3d, r28	; 61
    3656:	cf 91       	pop	r28
    3658:	df 91       	pop	r29
    365a:	1f 91       	pop	r17
    365c:	0f 91       	pop	r16
    365e:	ff 90       	pop	r15
    3660:	ef 90       	pop	r14
    3662:	df 90       	pop	r13
    3664:	cf 90       	pop	r12
    3666:	bf 90       	pop	r11
    3668:	af 90       	pop	r10
    366a:	08 95       	ret

0000366c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    366c:	df 93       	push	r29
    366e:	cf 93       	push	r28
    3670:	00 d0       	rcall	.+0      	; 0x3672 <vTaskDelete+0x6>
    3672:	00 d0       	rcall	.+0      	; 0x3674 <vTaskDelete+0x8>
    3674:	00 d0       	rcall	.+0      	; 0x3676 <vTaskDelete+0xa>
    3676:	cd b7       	in	r28, 0x3d	; 61
    3678:	de b7       	in	r29, 0x3e	; 62
    367a:	9c 83       	std	Y+4, r25	; 0x04
    367c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    367e:	0f b6       	in	r0, 0x3f	; 63
    3680:	f8 94       	cli
    3682:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3684:	8b 81       	ldd	r24, Y+3	; 0x03
    3686:	9c 81       	ldd	r25, Y+4	; 0x04
    3688:	00 97       	sbiw	r24, 0x00	; 0
    368a:	39 f4       	brne	.+14     	; 0x369a <vTaskDelete+0x2e>
    368c:	80 91 97 05 	lds	r24, 0x0597
    3690:	90 91 98 05 	lds	r25, 0x0598
    3694:	9e 83       	std	Y+6, r25	; 0x06
    3696:	8d 83       	std	Y+5, r24	; 0x05
    3698:	04 c0       	rjmp	.+8      	; 0x36a2 <vTaskDelete+0x36>
    369a:	8b 81       	ldd	r24, Y+3	; 0x03
    369c:	9c 81       	ldd	r25, Y+4	; 0x04
    369e:	9e 83       	std	Y+6, r25	; 0x06
    36a0:	8d 83       	std	Y+5, r24	; 0x05
    36a2:	8d 81       	ldd	r24, Y+5	; 0x05
    36a4:	9e 81       	ldd	r25, Y+6	; 0x06
    36a6:	9a 83       	std	Y+2, r25	; 0x02
    36a8:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    36aa:	89 81       	ldd	r24, Y+1	; 0x01
    36ac:	9a 81       	ldd	r25, Y+2	; 0x02
    36ae:	02 96       	adiw	r24, 0x02	; 2
    36b0:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    36b4:	e9 81       	ldd	r30, Y+1	; 0x01
    36b6:	fa 81       	ldd	r31, Y+2	; 0x02
    36b8:	84 89       	ldd	r24, Z+20	; 0x14
    36ba:	95 89       	ldd	r25, Z+21	; 0x15
    36bc:	00 97       	sbiw	r24, 0x00	; 0
    36be:	29 f0       	breq	.+10     	; 0x36ca <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    36c0:	89 81       	ldd	r24, Y+1	; 0x01
    36c2:	9a 81       	ldd	r25, Y+2	; 0x02
    36c4:	0c 96       	adiw	r24, 0x0c	; 12
    36c6:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    36ca:	89 81       	ldd	r24, Y+1	; 0x01
    36cc:	9a 81       	ldd	r25, Y+2	; 0x02
    36ce:	9c 01       	movw	r18, r24
    36d0:	2e 5f       	subi	r18, 0xFE	; 254
    36d2:	3f 4f       	sbci	r19, 0xFF	; 255
    36d4:	87 ee       	ldi	r24, 0xE7	; 231
    36d6:	95 e0       	ldi	r25, 0x05	; 5
    36d8:	b9 01       	movw	r22, r18
    36da:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    36de:	80 91 99 05 	lds	r24, 0x0599
    36e2:	8f 5f       	subi	r24, 0xFF	; 255
    36e4:	80 93 99 05 	sts	0x0599, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    36e8:	80 91 a2 05 	lds	r24, 0x05A2
    36ec:	8f 5f       	subi	r24, 0xFF	; 255
    36ee:	80 93 a2 05 	sts	0x05A2, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    36f2:	0f 90       	pop	r0
    36f4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    36f6:	80 91 9e 05 	lds	r24, 0x059E
    36fa:	88 23       	and	r24, r24
    36fc:	99 f0       	breq	.+38     	; 0x3724 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    36fe:	20 91 97 05 	lds	r18, 0x0597
    3702:	30 91 98 05 	lds	r19, 0x0598
    3706:	89 81       	ldd	r24, Y+1	; 0x01
    3708:	9a 81       	ldd	r25, Y+2	; 0x02
    370a:	82 17       	cp	r24, r18
    370c:	93 07       	cpc	r25, r19
    370e:	19 f4       	brne	.+6      	; 0x3716 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    3710:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    3714:	07 c0       	rjmp	.+14     	; 0x3724 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    3716:	0f b6       	in	r0, 0x3f	; 63
    3718:	f8 94       	cli
    371a:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    371c:	0e 94 15 23 	call	0x462a	; 0x462a <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3720:	0f 90       	pop	r0
    3722:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    3724:	26 96       	adiw	r28, 0x06	; 6
    3726:	0f b6       	in	r0, 0x3f	; 63
    3728:	f8 94       	cli
    372a:	de bf       	out	0x3e, r29	; 62
    372c:	0f be       	out	0x3f, r0	; 63
    372e:	cd bf       	out	0x3d, r28	; 61
    3730:	cf 91       	pop	r28
    3732:	df 91       	pop	r29
    3734:	08 95       	ret

00003736 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3736:	df 93       	push	r29
    3738:	cf 93       	push	r28
    373a:	cd b7       	in	r28, 0x3d	; 61
    373c:	de b7       	in	r29, 0x3e	; 62
    373e:	2a 97       	sbiw	r28, 0x0a	; 10
    3740:	0f b6       	in	r0, 0x3f	; 63
    3742:	f8 94       	cli
    3744:	de bf       	out	0x3e, r29	; 62
    3746:	0f be       	out	0x3f, r0	; 63
    3748:	cd bf       	out	0x3d, r28	; 61
    374a:	98 87       	std	Y+8, r25	; 0x08
    374c:	8f 83       	std	Y+7, r24	; 0x07
    374e:	7a 87       	std	Y+10, r23	; 0x0a
    3750:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3752:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3754:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3758:	80 91 9b 05 	lds	r24, 0x059B
    375c:	90 91 9c 05 	lds	r25, 0x059C
    3760:	9a 83       	std	Y+2, r25	; 0x02
    3762:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3764:	ef 81       	ldd	r30, Y+7	; 0x07
    3766:	f8 85       	ldd	r31, Y+8	; 0x08
    3768:	20 81       	ld	r18, Z
    376a:	31 81       	ldd	r19, Z+1	; 0x01
    376c:	89 85       	ldd	r24, Y+9	; 0x09
    376e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3770:	82 0f       	add	r24, r18
    3772:	93 1f       	adc	r25, r19
    3774:	9e 83       	std	Y+6, r25	; 0x06
    3776:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3778:	ef 81       	ldd	r30, Y+7	; 0x07
    377a:	f8 85       	ldd	r31, Y+8	; 0x08
    377c:	20 81       	ld	r18, Z
    377e:	31 81       	ldd	r19, Z+1	; 0x01
    3780:	89 81       	ldd	r24, Y+1	; 0x01
    3782:	9a 81       	ldd	r25, Y+2	; 0x02
    3784:	82 17       	cp	r24, r18
    3786:	93 07       	cpc	r25, r19
    3788:	98 f4       	brcc	.+38     	; 0x37b0 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    378a:	ef 81       	ldd	r30, Y+7	; 0x07
    378c:	f8 85       	ldd	r31, Y+8	; 0x08
    378e:	20 81       	ld	r18, Z
    3790:	31 81       	ldd	r19, Z+1	; 0x01
    3792:	8d 81       	ldd	r24, Y+5	; 0x05
    3794:	9e 81       	ldd	r25, Y+6	; 0x06
    3796:	82 17       	cp	r24, r18
    3798:	93 07       	cpc	r25, r19
    379a:	e0 f4       	brcc	.+56     	; 0x37d4 <vTaskDelayUntil+0x9e>
    379c:	2d 81       	ldd	r18, Y+5	; 0x05
    379e:	3e 81       	ldd	r19, Y+6	; 0x06
    37a0:	89 81       	ldd	r24, Y+1	; 0x01
    37a2:	9a 81       	ldd	r25, Y+2	; 0x02
    37a4:	82 17       	cp	r24, r18
    37a6:	93 07       	cpc	r25, r19
    37a8:	a8 f4       	brcc	.+42     	; 0x37d4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    37aa:	81 e0       	ldi	r24, 0x01	; 1
    37ac:	8b 83       	std	Y+3, r24	; 0x03
    37ae:	12 c0       	rjmp	.+36     	; 0x37d4 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    37b0:	ef 81       	ldd	r30, Y+7	; 0x07
    37b2:	f8 85       	ldd	r31, Y+8	; 0x08
    37b4:	20 81       	ld	r18, Z
    37b6:	31 81       	ldd	r19, Z+1	; 0x01
    37b8:	8d 81       	ldd	r24, Y+5	; 0x05
    37ba:	9e 81       	ldd	r25, Y+6	; 0x06
    37bc:	82 17       	cp	r24, r18
    37be:	93 07       	cpc	r25, r19
    37c0:	38 f0       	brcs	.+14     	; 0x37d0 <vTaskDelayUntil+0x9a>
    37c2:	2d 81       	ldd	r18, Y+5	; 0x05
    37c4:	3e 81       	ldd	r19, Y+6	; 0x06
    37c6:	89 81       	ldd	r24, Y+1	; 0x01
    37c8:	9a 81       	ldd	r25, Y+2	; 0x02
    37ca:	82 17       	cp	r24, r18
    37cc:	93 07       	cpc	r25, r19
    37ce:	10 f4       	brcc	.+4      	; 0x37d4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    37d4:	ef 81       	ldd	r30, Y+7	; 0x07
    37d6:	f8 85       	ldd	r31, Y+8	; 0x08
    37d8:	8d 81       	ldd	r24, Y+5	; 0x05
    37da:	9e 81       	ldd	r25, Y+6	; 0x06
    37dc:	91 83       	std	Z+1, r25	; 0x01
    37de:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    37e0:	8b 81       	ldd	r24, Y+3	; 0x03
    37e2:	88 23       	and	r24, r24
    37e4:	59 f0       	breq	.+22     	; 0x37fc <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    37e6:	80 91 97 05 	lds	r24, 0x0597
    37ea:	90 91 98 05 	lds	r25, 0x0598
    37ee:	02 96       	adiw	r24, 0x02	; 2
    37f0:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    37f4:	8d 81       	ldd	r24, Y+5	; 0x05
    37f6:	9e 81       	ldd	r25, Y+6	; 0x06
    37f8:	0e 94 72 22 	call	0x44e4	; 0x44e4 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    37fc:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    3800:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3802:	8c 81       	ldd	r24, Y+4	; 0x04
    3804:	88 23       	and	r24, r24
    3806:	11 f4       	brne	.+4      	; 0x380c <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3808:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    380c:	2a 96       	adiw	r28, 0x0a	; 10
    380e:	0f b6       	in	r0, 0x3f	; 63
    3810:	f8 94       	cli
    3812:	de bf       	out	0x3e, r29	; 62
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	cd bf       	out	0x3d, r28	; 61
    3818:	cf 91       	pop	r28
    381a:	df 91       	pop	r29
    381c:	08 95       	ret

0000381e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    381e:	df 93       	push	r29
    3820:	cf 93       	push	r28
    3822:	00 d0       	rcall	.+0      	; 0x3824 <vTaskDelay+0x6>
    3824:	00 d0       	rcall	.+0      	; 0x3826 <vTaskDelay+0x8>
    3826:	0f 92       	push	r0
    3828:	cd b7       	in	r28, 0x3d	; 61
    382a:	de b7       	in	r29, 0x3e	; 62
    382c:	9d 83       	std	Y+5, r25	; 0x05
    382e:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    3830:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3832:	8c 81       	ldd	r24, Y+4	; 0x04
    3834:	9d 81       	ldd	r25, Y+5	; 0x05
    3836:	00 97       	sbiw	r24, 0x00	; 0
    3838:	d1 f0       	breq	.+52     	; 0x386e <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    383a:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    383e:	20 91 9b 05 	lds	r18, 0x059B
    3842:	30 91 9c 05 	lds	r19, 0x059C
    3846:	8c 81       	ldd	r24, Y+4	; 0x04
    3848:	9d 81       	ldd	r25, Y+5	; 0x05
    384a:	82 0f       	add	r24, r18
    384c:	93 1f       	adc	r25, r19
    384e:	9b 83       	std	Y+3, r25	; 0x03
    3850:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3852:	80 91 97 05 	lds	r24, 0x0597
    3856:	90 91 98 05 	lds	r25, 0x0598
    385a:	02 96       	adiw	r24, 0x02	; 2
    385c:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3860:	8a 81       	ldd	r24, Y+2	; 0x02
    3862:	9b 81       	ldd	r25, Y+3	; 0x03
    3864:	0e 94 72 22 	call	0x44e4	; 0x44e4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3868:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    386c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    386e:	89 81       	ldd	r24, Y+1	; 0x01
    3870:	88 23       	and	r24, r24
    3872:	11 f4       	brne	.+4      	; 0x3878 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3874:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3878:	0f 90       	pop	r0
    387a:	0f 90       	pop	r0
    387c:	0f 90       	pop	r0
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	cf 91       	pop	r28
    3884:	df 91       	pop	r29
    3886:	08 95       	ret

00003888 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    3888:	df 93       	push	r29
    388a:	cf 93       	push	r28
    388c:	cd b7       	in	r28, 0x3d	; 61
    388e:	de b7       	in	r29, 0x3e	; 62
    3890:	27 97       	sbiw	r28, 0x07	; 7
    3892:	0f b6       	in	r0, 0x3f	; 63
    3894:	f8 94       	cli
    3896:	de bf       	out	0x3e, r29	; 62
    3898:	0f be       	out	0x3f, r0	; 63
    389a:	cd bf       	out	0x3d, r28	; 61
    389c:	9d 83       	std	Y+5, r25	; 0x05
    389e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    38a0:	0f b6       	in	r0, 0x3f	; 63
    38a2:	f8 94       	cli
    38a4:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    38a6:	8c 81       	ldd	r24, Y+4	; 0x04
    38a8:	9d 81       	ldd	r25, Y+5	; 0x05
    38aa:	00 97       	sbiw	r24, 0x00	; 0
    38ac:	39 f4       	brne	.+14     	; 0x38bc <uxTaskPriorityGet+0x34>
    38ae:	80 91 97 05 	lds	r24, 0x0597
    38b2:	90 91 98 05 	lds	r25, 0x0598
    38b6:	9f 83       	std	Y+7, r25	; 0x07
    38b8:	8e 83       	std	Y+6, r24	; 0x06
    38ba:	04 c0       	rjmp	.+8      	; 0x38c4 <uxTaskPriorityGet+0x3c>
    38bc:	8c 81       	ldd	r24, Y+4	; 0x04
    38be:	9d 81       	ldd	r25, Y+5	; 0x05
    38c0:	9f 83       	std	Y+7, r25	; 0x07
    38c2:	8e 83       	std	Y+6, r24	; 0x06
    38c4:	8e 81       	ldd	r24, Y+6	; 0x06
    38c6:	9f 81       	ldd	r25, Y+7	; 0x07
    38c8:	9b 83       	std	Y+3, r25	; 0x03
    38ca:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    38cc:	ea 81       	ldd	r30, Y+2	; 0x02
    38ce:	fb 81       	ldd	r31, Y+3	; 0x03
    38d0:	86 89       	ldd	r24, Z+22	; 0x16
    38d2:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    38d4:	0f 90       	pop	r0
    38d6:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    38d8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    38da:	27 96       	adiw	r28, 0x07	; 7
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	de bf       	out	0x3e, r29	; 62
    38e2:	0f be       	out	0x3f, r0	; 63
    38e4:	cd bf       	out	0x3d, r28	; 61
    38e6:	cf 91       	pop	r28
    38e8:	df 91       	pop	r29
    38ea:	08 95       	ret

000038ec <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    38ec:	df 93       	push	r29
    38ee:	cf 93       	push	r28
    38f0:	cd b7       	in	r28, 0x3d	; 61
    38f2:	de b7       	in	r29, 0x3e	; 62
    38f4:	2a 97       	sbiw	r28, 0x0a	; 10
    38f6:	0f b6       	in	r0, 0x3f	; 63
    38f8:	f8 94       	cli
    38fa:	de bf       	out	0x3e, r29	; 62
    38fc:	0f be       	out	0x3f, r0	; 63
    38fe:	cd bf       	out	0x3d, r28	; 61
    3900:	9f 83       	std	Y+7, r25	; 0x07
    3902:	8e 83       	std	Y+6, r24	; 0x06
    3904:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3906:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3908:	88 85       	ldd	r24, Y+8	; 0x08
    390a:	84 30       	cpi	r24, 0x04	; 4
    390c:	10 f0       	brcs	.+4      	; 0x3912 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    390e:	83 e0       	ldi	r24, 0x03	; 3
    3910:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3912:	0f b6       	in	r0, 0x3f	; 63
    3914:	f8 94       	cli
    3916:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3918:	8e 81       	ldd	r24, Y+6	; 0x06
    391a:	9f 81       	ldd	r25, Y+7	; 0x07
    391c:	00 97       	sbiw	r24, 0x00	; 0
    391e:	39 f4       	brne	.+14     	; 0x392e <vTaskPrioritySet+0x42>
    3920:	80 91 97 05 	lds	r24, 0x0597
    3924:	90 91 98 05 	lds	r25, 0x0598
    3928:	9a 87       	std	Y+10, r25	; 0x0a
    392a:	89 87       	std	Y+9, r24	; 0x09
    392c:	04 c0       	rjmp	.+8      	; 0x3936 <vTaskPrioritySet+0x4a>
    392e:	8e 81       	ldd	r24, Y+6	; 0x06
    3930:	9f 81       	ldd	r25, Y+7	; 0x07
    3932:	9a 87       	std	Y+10, r25	; 0x0a
    3934:	89 87       	std	Y+9, r24	; 0x09
    3936:	89 85       	ldd	r24, Y+9	; 0x09
    3938:	9a 85       	ldd	r25, Y+10	; 0x0a
    393a:	9d 83       	std	Y+5, r25	; 0x05
    393c:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    393e:	ec 81       	ldd	r30, Y+4	; 0x04
    3940:	fd 81       	ldd	r31, Y+5	; 0x05
    3942:	85 a5       	ldd	r24, Z+45	; 0x2d
    3944:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3946:	9b 81       	ldd	r25, Y+3	; 0x03
    3948:	88 85       	ldd	r24, Y+8	; 0x08
    394a:	98 17       	cp	r25, r24
    394c:	09 f4       	brne	.+2      	; 0x3950 <vTaskPrioritySet+0x64>
    394e:	8d c0       	rjmp	.+282    	; 0x3a6a <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    3950:	98 85       	ldd	r25, Y+8	; 0x08
    3952:	8b 81       	ldd	r24, Y+3	; 0x03
    3954:	89 17       	cp	r24, r25
    3956:	a0 f4       	brcc	.+40     	; 0x3980 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    3958:	20 91 97 05 	lds	r18, 0x0597
    395c:	30 91 98 05 	lds	r19, 0x0598
    3960:	8c 81       	ldd	r24, Y+4	; 0x04
    3962:	9d 81       	ldd	r25, Y+5	; 0x05
    3964:	82 17       	cp	r24, r18
    3966:	93 07       	cpc	r25, r19
    3968:	b1 f0       	breq	.+44     	; 0x3996 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    396a:	e0 91 97 05 	lds	r30, 0x0597
    396e:	f0 91 98 05 	lds	r31, 0x0598
    3972:	96 89       	ldd	r25, Z+22	; 0x16
    3974:	88 85       	ldd	r24, Y+8	; 0x08
    3976:	89 17       	cp	r24, r25
    3978:	70 f0       	brcs	.+28     	; 0x3996 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    397a:	81 e0       	ldi	r24, 0x01	; 1
    397c:	89 83       	std	Y+1, r24	; 0x01
    397e:	0b c0       	rjmp	.+22     	; 0x3996 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    3980:	20 91 97 05 	lds	r18, 0x0597
    3984:	30 91 98 05 	lds	r19, 0x0598
    3988:	8c 81       	ldd	r24, Y+4	; 0x04
    398a:	9d 81       	ldd	r25, Y+5	; 0x05
    398c:	82 17       	cp	r24, r18
    398e:	93 07       	cpc	r25, r19
    3990:	11 f4       	brne	.+4      	; 0x3996 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    3992:	81 e0       	ldi	r24, 0x01	; 1
    3994:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    3996:	ec 81       	ldd	r30, Y+4	; 0x04
    3998:	fd 81       	ldd	r31, Y+5	; 0x05
    399a:	86 89       	ldd	r24, Z+22	; 0x16
    399c:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    399e:	ec 81       	ldd	r30, Y+4	; 0x04
    39a0:	fd 81       	ldd	r31, Y+5	; 0x05
    39a2:	95 a5       	ldd	r25, Z+45	; 0x2d
    39a4:	ec 81       	ldd	r30, Y+4	; 0x04
    39a6:	fd 81       	ldd	r31, Y+5	; 0x05
    39a8:	86 89       	ldd	r24, Z+22	; 0x16
    39aa:	98 17       	cp	r25, r24
    39ac:	21 f4       	brne	.+8      	; 0x39b6 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    39ae:	ec 81       	ldd	r30, Y+4	; 0x04
    39b0:	fd 81       	ldd	r31, Y+5	; 0x05
    39b2:	88 85       	ldd	r24, Y+8	; 0x08
    39b4:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    39b6:	ec 81       	ldd	r30, Y+4	; 0x04
    39b8:	fd 81       	ldd	r31, Y+5	; 0x05
    39ba:	88 85       	ldd	r24, Y+8	; 0x08
    39bc:	85 a7       	std	Z+45, r24	; 0x2d
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    39be:	ec 81       	ldd	r30, Y+4	; 0x04
    39c0:	fd 81       	ldd	r31, Y+5	; 0x05
    39c2:	84 85       	ldd	r24, Z+12	; 0x0c
    39c4:	95 85       	ldd	r25, Z+13	; 0x0d
    39c6:	99 23       	and	r25, r25
    39c8:	5c f0       	brlt	.+22     	; 0x39e0 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    39ca:	88 85       	ldd	r24, Y+8	; 0x08
    39cc:	28 2f       	mov	r18, r24
    39ce:	30 e0       	ldi	r19, 0x00	; 0
    39d0:	84 e0       	ldi	r24, 0x04	; 4
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	82 1b       	sub	r24, r18
    39d6:	93 0b       	sbc	r25, r19
    39d8:	ec 81       	ldd	r30, Y+4	; 0x04
    39da:	fd 81       	ldd	r31, Y+5	; 0x05
    39dc:	95 87       	std	Z+13, r25	; 0x0d
    39de:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    39e0:	ec 81       	ldd	r30, Y+4	; 0x04
    39e2:	fd 81       	ldd	r31, Y+5	; 0x05
    39e4:	42 85       	ldd	r20, Z+10	; 0x0a
    39e6:	53 85       	ldd	r21, Z+11	; 0x0b
    39e8:	8a 81       	ldd	r24, Y+2	; 0x02
    39ea:	28 2f       	mov	r18, r24
    39ec:	30 e0       	ldi	r19, 0x00	; 0
    39ee:	c9 01       	movw	r24, r18
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	88 0f       	add	r24, r24
    39f6:	99 1f       	adc	r25, r25
    39f8:	88 0f       	add	r24, r24
    39fa:	99 1f       	adc	r25, r25
    39fc:	82 0f       	add	r24, r18
    39fe:	93 1f       	adc	r25, r19
    3a00:	8c 55       	subi	r24, 0x5C	; 92
    3a02:	9a 4f       	sbci	r25, 0xFA	; 250
    3a04:	48 17       	cp	r20, r24
    3a06:	59 07       	cpc	r21, r25
    3a08:	59 f5       	brne	.+86     	; 0x3a60 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a0a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a0c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a0e:	02 96       	adiw	r24, 0x02	; 2
    3a10:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3a14:	ec 81       	ldd	r30, Y+4	; 0x04
    3a16:	fd 81       	ldd	r31, Y+5	; 0x05
    3a18:	96 89       	ldd	r25, Z+22	; 0x16
    3a1a:	80 91 9d 05 	lds	r24, 0x059D
    3a1e:	89 17       	cp	r24, r25
    3a20:	28 f4       	brcc	.+10     	; 0x3a2c <vTaskPrioritySet+0x140>
    3a22:	ec 81       	ldd	r30, Y+4	; 0x04
    3a24:	fd 81       	ldd	r31, Y+5	; 0x05
    3a26:	86 89       	ldd	r24, Z+22	; 0x16
    3a28:	80 93 9d 05 	sts	0x059D, r24
    3a2c:	ec 81       	ldd	r30, Y+4	; 0x04
    3a2e:	fd 81       	ldd	r31, Y+5	; 0x05
    3a30:	86 89       	ldd	r24, Z+22	; 0x16
    3a32:	28 2f       	mov	r18, r24
    3a34:	30 e0       	ldi	r19, 0x00	; 0
    3a36:	c9 01       	movw	r24, r18
    3a38:	88 0f       	add	r24, r24
    3a3a:	99 1f       	adc	r25, r25
    3a3c:	88 0f       	add	r24, r24
    3a3e:	99 1f       	adc	r25, r25
    3a40:	88 0f       	add	r24, r24
    3a42:	99 1f       	adc	r25, r25
    3a44:	82 0f       	add	r24, r18
    3a46:	93 1f       	adc	r25, r19
    3a48:	ac 01       	movw	r20, r24
    3a4a:	4c 55       	subi	r20, 0x5C	; 92
    3a4c:	5a 4f       	sbci	r21, 0xFA	; 250
    3a4e:	8c 81       	ldd	r24, Y+4	; 0x04
    3a50:	9d 81       	ldd	r25, Y+5	; 0x05
    3a52:	9c 01       	movw	r18, r24
    3a54:	2e 5f       	subi	r18, 0xFE	; 254
    3a56:	3f 4f       	sbci	r19, 0xFF	; 255
    3a58:	ca 01       	movw	r24, r20
    3a5a:	b9 01       	movw	r22, r18
    3a5c:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	81 30       	cpi	r24, 0x01	; 1
    3a64:	11 f4       	brne	.+4      	; 0x3a6a <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3a66:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3a6a:	0f 90       	pop	r0
    3a6c:	0f be       	out	0x3f, r0	; 63
	}
    3a6e:	2a 96       	adiw	r28, 0x0a	; 10
    3a70:	0f b6       	in	r0, 0x3f	; 63
    3a72:	f8 94       	cli
    3a74:	de bf       	out	0x3e, r29	; 62
    3a76:	0f be       	out	0x3f, r0	; 63
    3a78:	cd bf       	out	0x3d, r28	; 61
    3a7a:	cf 91       	pop	r28
    3a7c:	df 91       	pop	r29
    3a7e:	08 95       	ret

00003a80 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3a80:	af 92       	push	r10
    3a82:	bf 92       	push	r11
    3a84:	cf 92       	push	r12
    3a86:	df 92       	push	r13
    3a88:	ef 92       	push	r14
    3a8a:	ff 92       	push	r15
    3a8c:	0f 93       	push	r16
    3a8e:	df 93       	push	r29
    3a90:	cf 93       	push	r28
    3a92:	0f 92       	push	r0
    3a94:	cd b7       	in	r28, 0x3d	; 61
    3a96:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3a98:	8c e6       	ldi	r24, 0x6C	; 108
    3a9a:	91 e2       	ldi	r25, 0x21	; 33
    3a9c:	28 e7       	ldi	r18, 0x78	; 120
    3a9e:	30 e0       	ldi	r19, 0x00	; 0
    3aa0:	b9 01       	movw	r22, r18
    3aa2:	45 e5       	ldi	r20, 0x55	; 85
    3aa4:	50 e0       	ldi	r21, 0x00	; 0
    3aa6:	20 e0       	ldi	r18, 0x00	; 0
    3aa8:	30 e0       	ldi	r19, 0x00	; 0
    3aaa:	00 e0       	ldi	r16, 0x00	; 0
    3aac:	ee 24       	eor	r14, r14
    3aae:	ff 24       	eor	r15, r15
    3ab0:	cc 24       	eor	r12, r12
    3ab2:	dd 24       	eor	r13, r13
    3ab4:	aa 24       	eor	r10, r10
    3ab6:	bb 24       	eor	r11, r11
    3ab8:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>
    3abc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3abe:	89 81       	ldd	r24, Y+1	; 0x01
    3ac0:	81 30       	cpi	r24, 0x01	; 1
    3ac2:	51 f4       	brne	.+20     	; 0x3ad8 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3ac4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    3ac6:	81 e0       	ldi	r24, 0x01	; 1
    3ac8:	80 93 9e 05 	sts	0x059E, r24
		xTickCount = ( TickType_t ) 0U;
    3acc:	10 92 9c 05 	sts	0x059C, r1
    3ad0:	10 92 9b 05 	sts	0x059B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3ad4:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3ad8:	0f 90       	pop	r0
    3ada:	cf 91       	pop	r28
    3adc:	df 91       	pop	r29
    3ade:	0f 91       	pop	r16
    3ae0:	ff 90       	pop	r15
    3ae2:	ef 90       	pop	r14
    3ae4:	df 90       	pop	r13
    3ae6:	cf 90       	pop	r12
    3ae8:	bf 90       	pop	r11
    3aea:	af 90       	pop	r10
    3aec:	08 95       	ret

00003aee <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3aee:	df 93       	push	r29
    3af0:	cf 93       	push	r28
    3af2:	cd b7       	in	r28, 0x3d	; 61
    3af4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3af6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3af8:	10 92 9e 05 	sts	0x059E, r1
	vPortEndScheduler();
    3afc:	0e 94 8d 11 	call	0x231a	; 0x231a <vPortEndScheduler>
}
    3b00:	cf 91       	pop	r28
    3b02:	df 91       	pop	r29
    3b04:	08 95       	ret

00003b06 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3b06:	df 93       	push	r29
    3b08:	cf 93       	push	r28
    3b0a:	cd b7       	in	r28, 0x3d	; 61
    3b0c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3b0e:	80 91 a3 05 	lds	r24, 0x05A3
    3b12:	8f 5f       	subi	r24, 0xFF	; 255
    3b14:	80 93 a3 05 	sts	0x05A3, r24
}
    3b18:	cf 91       	pop	r28
    3b1a:	df 91       	pop	r29
    3b1c:	08 95       	ret

00003b1e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3b1e:	df 93       	push	r29
    3b20:	cf 93       	push	r28
    3b22:	00 d0       	rcall	.+0      	; 0x3b24 <xTaskResumeAll+0x6>
    3b24:	0f 92       	push	r0
    3b26:	cd b7       	in	r28, 0x3d	; 61
    3b28:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3b2a:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3b2c:	0f b6       	in	r0, 0x3f	; 63
    3b2e:	f8 94       	cli
    3b30:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3b32:	80 91 a3 05 	lds	r24, 0x05A3
    3b36:	81 50       	subi	r24, 0x01	; 1
    3b38:	80 93 a3 05 	sts	0x05A3, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3b3c:	80 91 a3 05 	lds	r24, 0x05A3
    3b40:	88 23       	and	r24, r24
    3b42:	09 f0       	breq	.+2      	; 0x3b46 <xTaskResumeAll+0x28>
    3b44:	6d c0       	rjmp	.+218    	; 0x3c20 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3b46:	80 91 9a 05 	lds	r24, 0x059A
    3b4a:	88 23       	and	r24, r24
    3b4c:	09 f4       	brne	.+2      	; 0x3b50 <xTaskResumeAll+0x32>
    3b4e:	68 c0       	rjmp	.+208    	; 0x3c20 <xTaskResumeAll+0x102>
    3b50:	45 c0       	rjmp	.+138    	; 0x3bdc <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3b52:	e0 91 e3 05 	lds	r30, 0x05E3
    3b56:	f0 91 e4 05 	lds	r31, 0x05E4
    3b5a:	86 81       	ldd	r24, Z+6	; 0x06
    3b5c:	97 81       	ldd	r25, Z+7	; 0x07
    3b5e:	9b 83       	std	Y+3, r25	; 0x03
    3b60:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b62:	8a 81       	ldd	r24, Y+2	; 0x02
    3b64:	9b 81       	ldd	r25, Y+3	; 0x03
    3b66:	0c 96       	adiw	r24, 0x0c	; 12
    3b68:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b70:	02 96       	adiw	r24, 0x02	; 2
    3b72:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3b76:	ea 81       	ldd	r30, Y+2	; 0x02
    3b78:	fb 81       	ldd	r31, Y+3	; 0x03
    3b7a:	96 89       	ldd	r25, Z+22	; 0x16
    3b7c:	80 91 9d 05 	lds	r24, 0x059D
    3b80:	89 17       	cp	r24, r25
    3b82:	28 f4       	brcc	.+10     	; 0x3b8e <xTaskResumeAll+0x70>
    3b84:	ea 81       	ldd	r30, Y+2	; 0x02
    3b86:	fb 81       	ldd	r31, Y+3	; 0x03
    3b88:	86 89       	ldd	r24, Z+22	; 0x16
    3b8a:	80 93 9d 05 	sts	0x059D, r24
    3b8e:	ea 81       	ldd	r30, Y+2	; 0x02
    3b90:	fb 81       	ldd	r31, Y+3	; 0x03
    3b92:	86 89       	ldd	r24, Z+22	; 0x16
    3b94:	28 2f       	mov	r18, r24
    3b96:	30 e0       	ldi	r19, 0x00	; 0
    3b98:	c9 01       	movw	r24, r18
    3b9a:	88 0f       	add	r24, r24
    3b9c:	99 1f       	adc	r25, r25
    3b9e:	88 0f       	add	r24, r24
    3ba0:	99 1f       	adc	r25, r25
    3ba2:	88 0f       	add	r24, r24
    3ba4:	99 1f       	adc	r25, r25
    3ba6:	82 0f       	add	r24, r18
    3ba8:	93 1f       	adc	r25, r19
    3baa:	ac 01       	movw	r20, r24
    3bac:	4c 55       	subi	r20, 0x5C	; 92
    3bae:	5a 4f       	sbci	r21, 0xFA	; 250
    3bb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3bb2:	9b 81       	ldd	r25, Y+3	; 0x03
    3bb4:	9c 01       	movw	r18, r24
    3bb6:	2e 5f       	subi	r18, 0xFE	; 254
    3bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    3bba:	ca 01       	movw	r24, r20
    3bbc:	b9 01       	movw	r22, r18
    3bbe:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3bc2:	ea 81       	ldd	r30, Y+2	; 0x02
    3bc4:	fb 81       	ldd	r31, Y+3	; 0x03
    3bc6:	96 89       	ldd	r25, Z+22	; 0x16
    3bc8:	e0 91 97 05 	lds	r30, 0x0597
    3bcc:	f0 91 98 05 	lds	r31, 0x0598
    3bd0:	86 89       	ldd	r24, Z+22	; 0x16
    3bd2:	98 17       	cp	r25, r24
    3bd4:	18 f0       	brcs	.+6      	; 0x3bdc <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    3bd6:	81 e0       	ldi	r24, 0x01	; 1
    3bd8:	80 93 a0 05 	sts	0x05A0, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3bdc:	80 91 de 05 	lds	r24, 0x05DE
    3be0:	88 23       	and	r24, r24
    3be2:	09 f0       	breq	.+2      	; 0x3be6 <xTaskResumeAll+0xc8>
    3be4:	b6 cf       	rjmp	.-148    	; 0x3b52 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3be6:	80 91 9f 05 	lds	r24, 0x059F
    3bea:	88 23       	and	r24, r24
    3bec:	89 f0       	breq	.+34     	; 0x3c10 <xTaskResumeAll+0xf2>
    3bee:	0c c0       	rjmp	.+24     	; 0x3c08 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    3bf0:	0e 94 4e 1e 	call	0x3c9c	; 0x3c9c <xTaskIncrementTick>
    3bf4:	88 23       	and	r24, r24
    3bf6:	19 f0       	breq	.+6      	; 0x3bfe <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    3bf8:	81 e0       	ldi	r24, 0x01	; 1
    3bfa:	80 93 a0 05 	sts	0x05A0, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3bfe:	80 91 9f 05 	lds	r24, 0x059F
    3c02:	81 50       	subi	r24, 0x01	; 1
    3c04:	80 93 9f 05 	sts	0x059F, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3c08:	80 91 9f 05 	lds	r24, 0x059F
    3c0c:	88 23       	and	r24, r24
    3c0e:	81 f7       	brne	.-32     	; 0x3bf0 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3c10:	80 91 a0 05 	lds	r24, 0x05A0
    3c14:	81 30       	cpi	r24, 0x01	; 1
    3c16:	21 f4       	brne	.+8      	; 0x3c20 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3c18:	81 e0       	ldi	r24, 0x01	; 1
    3c1a:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3c1c:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3c20:	0f 90       	pop	r0
    3c22:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3c24:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c26:	0f 90       	pop	r0
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3c32:	df 93       	push	r29
    3c34:	cf 93       	push	r28
    3c36:	00 d0       	rcall	.+0      	; 0x3c38 <xTaskGetTickCount+0x6>
    3c38:	cd b7       	in	r28, 0x3d	; 61
    3c3a:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3c3c:	0f b6       	in	r0, 0x3f	; 63
    3c3e:	f8 94       	cli
    3c40:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3c42:	80 91 9b 05 	lds	r24, 0x059B
    3c46:	90 91 9c 05 	lds	r25, 0x059C
    3c4a:	9a 83       	std	Y+2, r25	; 0x02
    3c4c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c4e:	0f 90       	pop	r0
    3c50:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3c52:	89 81       	ldd	r24, Y+1	; 0x01
    3c54:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c56:	0f 90       	pop	r0
    3c58:	0f 90       	pop	r0
    3c5a:	cf 91       	pop	r28
    3c5c:	df 91       	pop	r29
    3c5e:	08 95       	ret

00003c60 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3c60:	df 93       	push	r29
    3c62:	cf 93       	push	r28
    3c64:	00 d0       	rcall	.+0      	; 0x3c66 <xTaskGetTickCountFromISR+0x6>
    3c66:	0f 92       	push	r0
    3c68:	cd b7       	in	r28, 0x3d	; 61
    3c6a:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c6c:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3c6e:	80 91 9b 05 	lds	r24, 0x059B
    3c72:	90 91 9c 05 	lds	r25, 0x059C
    3c76:	9b 83       	std	Y+3, r25	; 0x03
    3c78:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c7c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3c7e:	0f 90       	pop	r0
    3c80:	0f 90       	pop	r0
    3c82:	0f 90       	pop	r0
    3c84:	cf 91       	pop	r28
    3c86:	df 91       	pop	r29
    3c88:	08 95       	ret

00003c8a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3c8a:	df 93       	push	r29
    3c8c:	cf 93       	push	r28
    3c8e:	cd b7       	in	r28, 0x3d	; 61
    3c90:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3c92:	80 91 9a 05 	lds	r24, 0x059A
}
    3c96:	cf 91       	pop	r28
    3c98:	df 91       	pop	r29
    3c9a:	08 95       	ret

00003c9c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3c9c:	df 93       	push	r29
    3c9e:	cf 93       	push	r28
    3ca0:	cd b7       	in	r28, 0x3d	; 61
    3ca2:	de b7       	in	r29, 0x3e	; 62
    3ca4:	29 97       	sbiw	r28, 0x09	; 9
    3ca6:	0f b6       	in	r0, 0x3f	; 63
    3ca8:	f8 94       	cli
    3caa:	de bf       	out	0x3e, r29	; 62
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3cb0:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3cb2:	80 91 a3 05 	lds	r24, 0x05A3
    3cb6:	88 23       	and	r24, r24
    3cb8:	09 f0       	breq	.+2      	; 0x3cbc <xTaskIncrementTick+0x20>
    3cba:	c2 c0       	rjmp	.+388    	; 0x3e40 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3cbc:	80 91 9b 05 	lds	r24, 0x059B
    3cc0:	90 91 9c 05 	lds	r25, 0x059C
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	90 93 9c 05 	sts	0x059C, r25
    3cca:	80 93 9b 05 	sts	0x059B, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3cce:	80 91 9b 05 	lds	r24, 0x059B
    3cd2:	90 91 9c 05 	lds	r25, 0x059C
    3cd6:	9c 83       	std	Y+4, r25	; 0x04
    3cd8:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    3cda:	8b 81       	ldd	r24, Y+3	; 0x03
    3cdc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cde:	00 97       	sbiw	r24, 0x00	; 0
    3ce0:	d9 f4       	brne	.+54     	; 0x3d18 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3ce2:	80 91 da 05 	lds	r24, 0x05DA
    3ce6:	90 91 db 05 	lds	r25, 0x05DB
    3cea:	9a 83       	std	Y+2, r25	; 0x02
    3cec:	89 83       	std	Y+1, r24	; 0x01
    3cee:	80 91 dc 05 	lds	r24, 0x05DC
    3cf2:	90 91 dd 05 	lds	r25, 0x05DD
    3cf6:	90 93 db 05 	sts	0x05DB, r25
    3cfa:	80 93 da 05 	sts	0x05DA, r24
    3cfe:	89 81       	ldd	r24, Y+1	; 0x01
    3d00:	9a 81       	ldd	r25, Y+2	; 0x02
    3d02:	90 93 dd 05 	sts	0x05DD, r25
    3d06:	80 93 dc 05 	sts	0x05DC, r24
    3d0a:	80 91 a1 05 	lds	r24, 0x05A1
    3d0e:	8f 5f       	subi	r24, 0xFF	; 255
    3d10:	80 93 a1 05 	sts	0x05A1, r24
    3d14:	0e 94 15 23 	call	0x462a	; 0x462a <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3d18:	20 91 ca 00 	lds	r18, 0x00CA
    3d1c:	30 91 cb 00 	lds	r19, 0x00CB
    3d20:	8b 81       	ldd	r24, Y+3	; 0x03
    3d22:	9c 81       	ldd	r25, Y+4	; 0x04
    3d24:	82 17       	cp	r24, r18
    3d26:	93 07       	cpc	r25, r19
    3d28:	08 f4       	brcc	.+2      	; 0x3d2c <xTaskIncrementTick+0x90>
    3d2a:	71 c0       	rjmp	.+226    	; 0x3e0e <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3d2c:	e0 91 da 05 	lds	r30, 0x05DA
    3d30:	f0 91 db 05 	lds	r31, 0x05DB
    3d34:	80 81       	ld	r24, Z
    3d36:	88 23       	and	r24, r24
    3d38:	39 f4       	brne	.+14     	; 0x3d48 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3d3a:	8f ef       	ldi	r24, 0xFF	; 255
    3d3c:	9f ef       	ldi	r25, 0xFF	; 255
    3d3e:	90 93 cb 00 	sts	0x00CB, r25
    3d42:	80 93 ca 00 	sts	0x00CA, r24
    3d46:	63 c0       	rjmp	.+198    	; 0x3e0e <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3d48:	e0 91 da 05 	lds	r30, 0x05DA
    3d4c:	f0 91 db 05 	lds	r31, 0x05DB
    3d50:	05 80       	ldd	r0, Z+5	; 0x05
    3d52:	f6 81       	ldd	r31, Z+6	; 0x06
    3d54:	e0 2d       	mov	r30, r0
    3d56:	86 81       	ldd	r24, Z+6	; 0x06
    3d58:	97 81       	ldd	r25, Z+7	; 0x07
    3d5a:	99 87       	std	Y+9, r25	; 0x09
    3d5c:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3d5e:	e8 85       	ldd	r30, Y+8	; 0x08
    3d60:	f9 85       	ldd	r31, Y+9	; 0x09
    3d62:	82 81       	ldd	r24, Z+2	; 0x02
    3d64:	93 81       	ldd	r25, Z+3	; 0x03
    3d66:	9f 83       	std	Y+7, r25	; 0x07
    3d68:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    3d6a:	2b 81       	ldd	r18, Y+3	; 0x03
    3d6c:	3c 81       	ldd	r19, Y+4	; 0x04
    3d6e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d70:	9f 81       	ldd	r25, Y+7	; 0x07
    3d72:	28 17       	cp	r18, r24
    3d74:	39 07       	cpc	r19, r25
    3d76:	38 f4       	brcc	.+14     	; 0x3d86 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3d78:	8e 81       	ldd	r24, Y+6	; 0x06
    3d7a:	9f 81       	ldd	r25, Y+7	; 0x07
    3d7c:	90 93 cb 00 	sts	0x00CB, r25
    3d80:	80 93 ca 00 	sts	0x00CA, r24
    3d84:	44 c0       	rjmp	.+136    	; 0x3e0e <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3d86:	88 85       	ldd	r24, Y+8	; 0x08
    3d88:	99 85       	ldd	r25, Y+9	; 0x09
    3d8a:	02 96       	adiw	r24, 0x02	; 2
    3d8c:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3d90:	e8 85       	ldd	r30, Y+8	; 0x08
    3d92:	f9 85       	ldd	r31, Y+9	; 0x09
    3d94:	84 89       	ldd	r24, Z+20	; 0x14
    3d96:	95 89       	ldd	r25, Z+21	; 0x15
    3d98:	00 97       	sbiw	r24, 0x00	; 0
    3d9a:	29 f0       	breq	.+10     	; 0x3da6 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3d9c:	88 85       	ldd	r24, Y+8	; 0x08
    3d9e:	99 85       	ldd	r25, Y+9	; 0x09
    3da0:	0c 96       	adiw	r24, 0x0c	; 12
    3da2:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3da6:	e8 85       	ldd	r30, Y+8	; 0x08
    3da8:	f9 85       	ldd	r31, Y+9	; 0x09
    3daa:	96 89       	ldd	r25, Z+22	; 0x16
    3dac:	80 91 9d 05 	lds	r24, 0x059D
    3db0:	89 17       	cp	r24, r25
    3db2:	28 f4       	brcc	.+10     	; 0x3dbe <xTaskIncrementTick+0x122>
    3db4:	e8 85       	ldd	r30, Y+8	; 0x08
    3db6:	f9 85       	ldd	r31, Y+9	; 0x09
    3db8:	86 89       	ldd	r24, Z+22	; 0x16
    3dba:	80 93 9d 05 	sts	0x059D, r24
    3dbe:	e8 85       	ldd	r30, Y+8	; 0x08
    3dc0:	f9 85       	ldd	r31, Y+9	; 0x09
    3dc2:	86 89       	ldd	r24, Z+22	; 0x16
    3dc4:	28 2f       	mov	r18, r24
    3dc6:	30 e0       	ldi	r19, 0x00	; 0
    3dc8:	c9 01       	movw	r24, r18
    3dca:	88 0f       	add	r24, r24
    3dcc:	99 1f       	adc	r25, r25
    3dce:	88 0f       	add	r24, r24
    3dd0:	99 1f       	adc	r25, r25
    3dd2:	88 0f       	add	r24, r24
    3dd4:	99 1f       	adc	r25, r25
    3dd6:	82 0f       	add	r24, r18
    3dd8:	93 1f       	adc	r25, r19
    3dda:	ac 01       	movw	r20, r24
    3ddc:	4c 55       	subi	r20, 0x5C	; 92
    3dde:	5a 4f       	sbci	r21, 0xFA	; 250
    3de0:	88 85       	ldd	r24, Y+8	; 0x08
    3de2:	99 85       	ldd	r25, Y+9	; 0x09
    3de4:	9c 01       	movw	r18, r24
    3de6:	2e 5f       	subi	r18, 0xFE	; 254
    3de8:	3f 4f       	sbci	r19, 0xFF	; 255
    3dea:	ca 01       	movw	r24, r20
    3dec:	b9 01       	movw	r22, r18
    3dee:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3df2:	e8 85       	ldd	r30, Y+8	; 0x08
    3df4:	f9 85       	ldd	r31, Y+9	; 0x09
    3df6:	96 89       	ldd	r25, Z+22	; 0x16
    3df8:	e0 91 97 05 	lds	r30, 0x0597
    3dfc:	f0 91 98 05 	lds	r31, 0x0598
    3e00:	86 89       	ldd	r24, Z+22	; 0x16
    3e02:	98 17       	cp	r25, r24
    3e04:	08 f4       	brcc	.+2      	; 0x3e08 <xTaskIncrementTick+0x16c>
    3e06:	92 cf       	rjmp	.-220    	; 0x3d2c <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    3e08:	81 e0       	ldi	r24, 0x01	; 1
    3e0a:	8d 83       	std	Y+5, r24	; 0x05
    3e0c:	8f cf       	rjmp	.-226    	; 0x3d2c <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3e0e:	e0 91 97 05 	lds	r30, 0x0597
    3e12:	f0 91 98 05 	lds	r31, 0x0598
    3e16:	86 89       	ldd	r24, Z+22	; 0x16
    3e18:	28 2f       	mov	r18, r24
    3e1a:	30 e0       	ldi	r19, 0x00	; 0
    3e1c:	c9 01       	movw	r24, r18
    3e1e:	88 0f       	add	r24, r24
    3e20:	99 1f       	adc	r25, r25
    3e22:	88 0f       	add	r24, r24
    3e24:	99 1f       	adc	r25, r25
    3e26:	88 0f       	add	r24, r24
    3e28:	99 1f       	adc	r25, r25
    3e2a:	82 0f       	add	r24, r18
    3e2c:	93 1f       	adc	r25, r19
    3e2e:	fc 01       	movw	r30, r24
    3e30:	ec 55       	subi	r30, 0x5C	; 92
    3e32:	fa 4f       	sbci	r31, 0xFA	; 250
    3e34:	80 81       	ld	r24, Z
    3e36:	82 30       	cpi	r24, 0x02	; 2
    3e38:	40 f0       	brcs	.+16     	; 0x3e4a <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    3e3a:	81 e0       	ldi	r24, 0x01	; 1
    3e3c:	8d 83       	std	Y+5, r24	; 0x05
    3e3e:	05 c0       	rjmp	.+10     	; 0x3e4a <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3e40:	80 91 9f 05 	lds	r24, 0x059F
    3e44:	8f 5f       	subi	r24, 0xFF	; 255
    3e46:	80 93 9f 05 	sts	0x059F, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3e4a:	80 91 a0 05 	lds	r24, 0x05A0
    3e4e:	88 23       	and	r24, r24
    3e50:	11 f0       	breq	.+4      	; 0x3e56 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    3e52:	81 e0       	ldi	r24, 0x01	; 1
    3e54:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3e56:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3e58:	29 96       	adiw	r28, 0x09	; 9
    3e5a:	0f b6       	in	r0, 0x3f	; 63
    3e5c:	f8 94       	cli
    3e5e:	de bf       	out	0x3e, r29	; 62
    3e60:	0f be       	out	0x3f, r0	; 63
    3e62:	cd bf       	out	0x3d, r28	; 61
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	08 95       	ret

00003e6a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3e6a:	df 93       	push	r29
    3e6c:	cf 93       	push	r28
    3e6e:	00 d0       	rcall	.+0      	; 0x3e70 <vTaskSwitchContext+0x6>
    3e70:	cd b7       	in	r28, 0x3d	; 61
    3e72:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3e74:	80 91 a3 05 	lds	r24, 0x05A3
    3e78:	88 23       	and	r24, r24
    3e7a:	21 f0       	breq	.+8      	; 0x3e84 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3e7c:	81 e0       	ldi	r24, 0x01	; 1
    3e7e:	80 93 a0 05 	sts	0x05A0, r24
    3e82:	57 c0       	rjmp	.+174    	; 0x3f32 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    3e84:	10 92 a0 05 	sts	0x05A0, r1
    3e88:	05 c0       	rjmp	.+10     	; 0x3e94 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3e8a:	80 91 9d 05 	lds	r24, 0x059D
    3e8e:	81 50       	subi	r24, 0x01	; 1
    3e90:	80 93 9d 05 	sts	0x059D, r24
    3e94:	80 91 9d 05 	lds	r24, 0x059D
    3e98:	28 2f       	mov	r18, r24
    3e9a:	30 e0       	ldi	r19, 0x00	; 0
    3e9c:	c9 01       	movw	r24, r18
    3e9e:	88 0f       	add	r24, r24
    3ea0:	99 1f       	adc	r25, r25
    3ea2:	88 0f       	add	r24, r24
    3ea4:	99 1f       	adc	r25, r25
    3ea6:	88 0f       	add	r24, r24
    3ea8:	99 1f       	adc	r25, r25
    3eaa:	82 0f       	add	r24, r18
    3eac:	93 1f       	adc	r25, r19
    3eae:	fc 01       	movw	r30, r24
    3eb0:	ec 55       	subi	r30, 0x5C	; 92
    3eb2:	fa 4f       	sbci	r31, 0xFA	; 250
    3eb4:	80 81       	ld	r24, Z
    3eb6:	88 23       	and	r24, r24
    3eb8:	41 f3       	breq	.-48     	; 0x3e8a <vTaskSwitchContext+0x20>
    3eba:	80 91 9d 05 	lds	r24, 0x059D
    3ebe:	28 2f       	mov	r18, r24
    3ec0:	30 e0       	ldi	r19, 0x00	; 0
    3ec2:	c9 01       	movw	r24, r18
    3ec4:	88 0f       	add	r24, r24
    3ec6:	99 1f       	adc	r25, r25
    3ec8:	88 0f       	add	r24, r24
    3eca:	99 1f       	adc	r25, r25
    3ecc:	88 0f       	add	r24, r24
    3ece:	99 1f       	adc	r25, r25
    3ed0:	82 0f       	add	r24, r18
    3ed2:	93 1f       	adc	r25, r19
    3ed4:	8c 55       	subi	r24, 0x5C	; 92
    3ed6:	9a 4f       	sbci	r25, 0xFA	; 250
    3ed8:	9a 83       	std	Y+2, r25	; 0x02
    3eda:	89 83       	std	Y+1, r24	; 0x01
    3edc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ede:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee0:	01 80       	ldd	r0, Z+1	; 0x01
    3ee2:	f2 81       	ldd	r31, Z+2	; 0x02
    3ee4:	e0 2d       	mov	r30, r0
    3ee6:	82 81       	ldd	r24, Z+2	; 0x02
    3ee8:	93 81       	ldd	r25, Z+3	; 0x03
    3eea:	e9 81       	ldd	r30, Y+1	; 0x01
    3eec:	fa 81       	ldd	r31, Y+2	; 0x02
    3eee:	92 83       	std	Z+2, r25	; 0x02
    3ef0:	81 83       	std	Z+1, r24	; 0x01
    3ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef6:	21 81       	ldd	r18, Z+1	; 0x01
    3ef8:	32 81       	ldd	r19, Z+2	; 0x02
    3efa:	89 81       	ldd	r24, Y+1	; 0x01
    3efc:	9a 81       	ldd	r25, Y+2	; 0x02
    3efe:	03 96       	adiw	r24, 0x03	; 3
    3f00:	28 17       	cp	r18, r24
    3f02:	39 07       	cpc	r19, r25
    3f04:	59 f4       	brne	.+22     	; 0x3f1c <vTaskSwitchContext+0xb2>
    3f06:	e9 81       	ldd	r30, Y+1	; 0x01
    3f08:	fa 81       	ldd	r31, Y+2	; 0x02
    3f0a:	01 80       	ldd	r0, Z+1	; 0x01
    3f0c:	f2 81       	ldd	r31, Z+2	; 0x02
    3f0e:	e0 2d       	mov	r30, r0
    3f10:	82 81       	ldd	r24, Z+2	; 0x02
    3f12:	93 81       	ldd	r25, Z+3	; 0x03
    3f14:	e9 81       	ldd	r30, Y+1	; 0x01
    3f16:	fa 81       	ldd	r31, Y+2	; 0x02
    3f18:	92 83       	std	Z+2, r25	; 0x02
    3f1a:	81 83       	std	Z+1, r24	; 0x01
    3f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f20:	01 80       	ldd	r0, Z+1	; 0x01
    3f22:	f2 81       	ldd	r31, Z+2	; 0x02
    3f24:	e0 2d       	mov	r30, r0
    3f26:	86 81       	ldd	r24, Z+6	; 0x06
    3f28:	97 81       	ldd	r25, Z+7	; 0x07
    3f2a:	90 93 98 05 	sts	0x0598, r25
    3f2e:	80 93 97 05 	sts	0x0597, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3f32:	0f 90       	pop	r0
    3f34:	0f 90       	pop	r0
    3f36:	cf 91       	pop	r28
    3f38:	df 91       	pop	r29
    3f3a:	08 95       	ret

00003f3c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3f3c:	df 93       	push	r29
    3f3e:	cf 93       	push	r28
    3f40:	00 d0       	rcall	.+0      	; 0x3f42 <vTaskPlaceOnEventList+0x6>
    3f42:	00 d0       	rcall	.+0      	; 0x3f44 <vTaskPlaceOnEventList+0x8>
    3f44:	00 d0       	rcall	.+0      	; 0x3f46 <vTaskPlaceOnEventList+0xa>
    3f46:	cd b7       	in	r28, 0x3d	; 61
    3f48:	de b7       	in	r29, 0x3e	; 62
    3f4a:	9c 83       	std	Y+4, r25	; 0x04
    3f4c:	8b 83       	std	Y+3, r24	; 0x03
    3f4e:	7e 83       	std	Y+6, r23	; 0x06
    3f50:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f52:	80 91 97 05 	lds	r24, 0x0597
    3f56:	90 91 98 05 	lds	r25, 0x0598
    3f5a:	9c 01       	movw	r18, r24
    3f5c:	24 5f       	subi	r18, 0xF4	; 244
    3f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f60:	8b 81       	ldd	r24, Y+3	; 0x03
    3f62:	9c 81       	ldd	r25, Y+4	; 0x04
    3f64:	b9 01       	movw	r22, r18
    3f66:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3f6a:	80 91 97 05 	lds	r24, 0x0597
    3f6e:	90 91 98 05 	lds	r25, 0x0598
    3f72:	02 96       	adiw	r24, 0x02	; 2
    3f74:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3f78:	20 91 9b 05 	lds	r18, 0x059B
    3f7c:	30 91 9c 05 	lds	r19, 0x059C
    3f80:	8d 81       	ldd	r24, Y+5	; 0x05
    3f82:	9e 81       	ldd	r25, Y+6	; 0x06
    3f84:	82 0f       	add	r24, r18
    3f86:	93 1f       	adc	r25, r19
    3f88:	9a 83       	std	Y+2, r25	; 0x02
    3f8a:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3f8c:	89 81       	ldd	r24, Y+1	; 0x01
    3f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f90:	0e 94 72 22 	call	0x44e4	; 0x44e4 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3f94:	26 96       	adiw	r28, 0x06	; 6
    3f96:	0f b6       	in	r0, 0x3f	; 63
    3f98:	f8 94       	cli
    3f9a:	de bf       	out	0x3e, r29	; 62
    3f9c:	0f be       	out	0x3f, r0	; 63
    3f9e:	cd bf       	out	0x3d, r28	; 61
    3fa0:	cf 91       	pop	r28
    3fa2:	df 91       	pop	r29
    3fa4:	08 95       	ret

00003fa6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3fa6:	df 93       	push	r29
    3fa8:	cf 93       	push	r28
    3faa:	cd b7       	in	r28, 0x3d	; 61
    3fac:	de b7       	in	r29, 0x3e	; 62
    3fae:	28 97       	sbiw	r28, 0x08	; 8
    3fb0:	0f b6       	in	r0, 0x3f	; 63
    3fb2:	f8 94       	cli
    3fb4:	de bf       	out	0x3e, r29	; 62
    3fb6:	0f be       	out	0x3f, r0	; 63
    3fb8:	cd bf       	out	0x3d, r28	; 61
    3fba:	9c 83       	std	Y+4, r25	; 0x04
    3fbc:	8b 83       	std	Y+3, r24	; 0x03
    3fbe:	7e 83       	std	Y+6, r23	; 0x06
    3fc0:	6d 83       	std	Y+5, r22	; 0x05
    3fc2:	58 87       	std	Y+8, r21	; 0x08
    3fc4:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3fc6:	e0 91 97 05 	lds	r30, 0x0597
    3fca:	f0 91 98 05 	lds	r31, 0x0598
    3fce:	8d 81       	ldd	r24, Y+5	; 0x05
    3fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    3fd2:	90 68       	ori	r25, 0x80	; 128
    3fd4:	95 87       	std	Z+13, r25	; 0x0d
    3fd6:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3fd8:	80 91 97 05 	lds	r24, 0x0597
    3fdc:	90 91 98 05 	lds	r25, 0x0598
    3fe0:	9c 01       	movw	r18, r24
    3fe2:	24 5f       	subi	r18, 0xF4	; 244
    3fe4:	3f 4f       	sbci	r19, 0xFF	; 255
    3fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fea:	b9 01       	movw	r22, r18
    3fec:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3ff0:	80 91 97 05 	lds	r24, 0x0597
    3ff4:	90 91 98 05 	lds	r25, 0x0598
    3ff8:	02 96       	adiw	r24, 0x02	; 2
    3ffa:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3ffe:	20 91 9b 05 	lds	r18, 0x059B
    4002:	30 91 9c 05 	lds	r19, 0x059C
    4006:	8f 81       	ldd	r24, Y+7	; 0x07
    4008:	98 85       	ldd	r25, Y+8	; 0x08
    400a:	82 0f       	add	r24, r18
    400c:	93 1f       	adc	r25, r19
    400e:	9a 83       	std	Y+2, r25	; 0x02
    4010:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4012:	89 81       	ldd	r24, Y+1	; 0x01
    4014:	9a 81       	ldd	r25, Y+2	; 0x02
    4016:	0e 94 72 22 	call	0x44e4	; 0x44e4 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    401a:	28 96       	adiw	r28, 0x08	; 8
    401c:	0f b6       	in	r0, 0x3f	; 63
    401e:	f8 94       	cli
    4020:	de bf       	out	0x3e, r29	; 62
    4022:	0f be       	out	0x3f, r0	; 63
    4024:	cd bf       	out	0x3d, r28	; 61
    4026:	cf 91       	pop	r28
    4028:	df 91       	pop	r29
    402a:	08 95       	ret

0000402c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    402c:	df 93       	push	r29
    402e:	cf 93       	push	r28
    4030:	00 d0       	rcall	.+0      	; 0x4032 <xTaskRemoveFromEventList+0x6>
    4032:	00 d0       	rcall	.+0      	; 0x4034 <xTaskRemoveFromEventList+0x8>
    4034:	0f 92       	push	r0
    4036:	cd b7       	in	r28, 0x3d	; 61
    4038:	de b7       	in	r29, 0x3e	; 62
    403a:	9d 83       	std	Y+5, r25	; 0x05
    403c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    403e:	ec 81       	ldd	r30, Y+4	; 0x04
    4040:	fd 81       	ldd	r31, Y+5	; 0x05
    4042:	05 80       	ldd	r0, Z+5	; 0x05
    4044:	f6 81       	ldd	r31, Z+6	; 0x06
    4046:	e0 2d       	mov	r30, r0
    4048:	86 81       	ldd	r24, Z+6	; 0x06
    404a:	97 81       	ldd	r25, Z+7	; 0x07
    404c:	9b 83       	std	Y+3, r25	; 0x03
    404e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4050:	8a 81       	ldd	r24, Y+2	; 0x02
    4052:	9b 81       	ldd	r25, Y+3	; 0x03
    4054:	0c 96       	adiw	r24, 0x0c	; 12
    4056:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    405a:	80 91 a3 05 	lds	r24, 0x05A3
    405e:	88 23       	and	r24, r24
    4060:	61 f5       	brne	.+88     	; 0x40ba <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4062:	8a 81       	ldd	r24, Y+2	; 0x02
    4064:	9b 81       	ldd	r25, Y+3	; 0x03
    4066:	02 96       	adiw	r24, 0x02	; 2
    4068:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    406c:	ea 81       	ldd	r30, Y+2	; 0x02
    406e:	fb 81       	ldd	r31, Y+3	; 0x03
    4070:	96 89       	ldd	r25, Z+22	; 0x16
    4072:	80 91 9d 05 	lds	r24, 0x059D
    4076:	89 17       	cp	r24, r25
    4078:	28 f4       	brcc	.+10     	; 0x4084 <xTaskRemoveFromEventList+0x58>
    407a:	ea 81       	ldd	r30, Y+2	; 0x02
    407c:	fb 81       	ldd	r31, Y+3	; 0x03
    407e:	86 89       	ldd	r24, Z+22	; 0x16
    4080:	80 93 9d 05 	sts	0x059D, r24
    4084:	ea 81       	ldd	r30, Y+2	; 0x02
    4086:	fb 81       	ldd	r31, Y+3	; 0x03
    4088:	86 89       	ldd	r24, Z+22	; 0x16
    408a:	28 2f       	mov	r18, r24
    408c:	30 e0       	ldi	r19, 0x00	; 0
    408e:	c9 01       	movw	r24, r18
    4090:	88 0f       	add	r24, r24
    4092:	99 1f       	adc	r25, r25
    4094:	88 0f       	add	r24, r24
    4096:	99 1f       	adc	r25, r25
    4098:	88 0f       	add	r24, r24
    409a:	99 1f       	adc	r25, r25
    409c:	82 0f       	add	r24, r18
    409e:	93 1f       	adc	r25, r19
    40a0:	ac 01       	movw	r20, r24
    40a2:	4c 55       	subi	r20, 0x5C	; 92
    40a4:	5a 4f       	sbci	r21, 0xFA	; 250
    40a6:	8a 81       	ldd	r24, Y+2	; 0x02
    40a8:	9b 81       	ldd	r25, Y+3	; 0x03
    40aa:	9c 01       	movw	r18, r24
    40ac:	2e 5f       	subi	r18, 0xFE	; 254
    40ae:	3f 4f       	sbci	r19, 0xFF	; 255
    40b0:	ca 01       	movw	r24, r20
    40b2:	b9 01       	movw	r22, r18
    40b4:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
    40b8:	0a c0       	rjmp	.+20     	; 0x40ce <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    40ba:	8a 81       	ldd	r24, Y+2	; 0x02
    40bc:	9b 81       	ldd	r25, Y+3	; 0x03
    40be:	9c 01       	movw	r18, r24
    40c0:	24 5f       	subi	r18, 0xF4	; 244
    40c2:	3f 4f       	sbci	r19, 0xFF	; 255
    40c4:	8e ed       	ldi	r24, 0xDE	; 222
    40c6:	95 e0       	ldi	r25, 0x05	; 5
    40c8:	b9 01       	movw	r22, r18
    40ca:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    40ce:	ea 81       	ldd	r30, Y+2	; 0x02
    40d0:	fb 81       	ldd	r31, Y+3	; 0x03
    40d2:	96 89       	ldd	r25, Z+22	; 0x16
    40d4:	e0 91 97 05 	lds	r30, 0x0597
    40d8:	f0 91 98 05 	lds	r31, 0x0598
    40dc:	86 89       	ldd	r24, Z+22	; 0x16
    40de:	89 17       	cp	r24, r25
    40e0:	30 f4       	brcc	.+12     	; 0x40ee <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    40e2:	81 e0       	ldi	r24, 0x01	; 1
    40e4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    40e6:	81 e0       	ldi	r24, 0x01	; 1
    40e8:	80 93 a0 05 	sts	0x05A0, r24
    40ec:	01 c0       	rjmp	.+2      	; 0x40f0 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    40ee:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    40f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    40f2:	0f 90       	pop	r0
    40f4:	0f 90       	pop	r0
    40f6:	0f 90       	pop	r0
    40f8:	0f 90       	pop	r0
    40fa:	0f 90       	pop	r0
    40fc:	cf 91       	pop	r28
    40fe:	df 91       	pop	r29
    4100:	08 95       	ret

00004102 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4102:	df 93       	push	r29
    4104:	cf 93       	push	r28
    4106:	cd b7       	in	r28, 0x3d	; 61
    4108:	de b7       	in	r29, 0x3e	; 62
    410a:	27 97       	sbiw	r28, 0x07	; 7
    410c:	0f b6       	in	r0, 0x3f	; 63
    410e:	f8 94       	cli
    4110:	de bf       	out	0x3e, r29	; 62
    4112:	0f be       	out	0x3f, r0	; 63
    4114:	cd bf       	out	0x3d, r28	; 61
    4116:	9d 83       	std	Y+5, r25	; 0x05
    4118:	8c 83       	std	Y+4, r24	; 0x04
    411a:	7f 83       	std	Y+7, r23	; 0x07
    411c:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    411e:	8e 81       	ldd	r24, Y+6	; 0x06
    4120:	9f 81       	ldd	r25, Y+7	; 0x07
    4122:	90 68       	ori	r25, 0x80	; 128
    4124:	ec 81       	ldd	r30, Y+4	; 0x04
    4126:	fd 81       	ldd	r31, Y+5	; 0x05
    4128:	91 83       	std	Z+1, r25	; 0x01
    412a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    412c:	ec 81       	ldd	r30, Y+4	; 0x04
    412e:	fd 81       	ldd	r31, Y+5	; 0x05
    4130:	86 81       	ldd	r24, Z+6	; 0x06
    4132:	97 81       	ldd	r25, Z+7	; 0x07
    4134:	9b 83       	std	Y+3, r25	; 0x03
    4136:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4138:	8c 81       	ldd	r24, Y+4	; 0x04
    413a:	9d 81       	ldd	r25, Y+5	; 0x05
    413c:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4140:	8a 81       	ldd	r24, Y+2	; 0x02
    4142:	9b 81       	ldd	r25, Y+3	; 0x03
    4144:	02 96       	adiw	r24, 0x02	; 2
    4146:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    414a:	ea 81       	ldd	r30, Y+2	; 0x02
    414c:	fb 81       	ldd	r31, Y+3	; 0x03
    414e:	96 89       	ldd	r25, Z+22	; 0x16
    4150:	80 91 9d 05 	lds	r24, 0x059D
    4154:	89 17       	cp	r24, r25
    4156:	28 f4       	brcc	.+10     	; 0x4162 <xTaskRemoveFromUnorderedEventList+0x60>
    4158:	ea 81       	ldd	r30, Y+2	; 0x02
    415a:	fb 81       	ldd	r31, Y+3	; 0x03
    415c:	86 89       	ldd	r24, Z+22	; 0x16
    415e:	80 93 9d 05 	sts	0x059D, r24
    4162:	ea 81       	ldd	r30, Y+2	; 0x02
    4164:	fb 81       	ldd	r31, Y+3	; 0x03
    4166:	86 89       	ldd	r24, Z+22	; 0x16
    4168:	28 2f       	mov	r18, r24
    416a:	30 e0       	ldi	r19, 0x00	; 0
    416c:	c9 01       	movw	r24, r18
    416e:	88 0f       	add	r24, r24
    4170:	99 1f       	adc	r25, r25
    4172:	88 0f       	add	r24, r24
    4174:	99 1f       	adc	r25, r25
    4176:	88 0f       	add	r24, r24
    4178:	99 1f       	adc	r25, r25
    417a:	82 0f       	add	r24, r18
    417c:	93 1f       	adc	r25, r19
    417e:	ac 01       	movw	r20, r24
    4180:	4c 55       	subi	r20, 0x5C	; 92
    4182:	5a 4f       	sbci	r21, 0xFA	; 250
    4184:	8a 81       	ldd	r24, Y+2	; 0x02
    4186:	9b 81       	ldd	r25, Y+3	; 0x03
    4188:	9c 01       	movw	r18, r24
    418a:	2e 5f       	subi	r18, 0xFE	; 254
    418c:	3f 4f       	sbci	r19, 0xFF	; 255
    418e:	ca 01       	movw	r24, r20
    4190:	b9 01       	movw	r22, r18
    4192:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4196:	ea 81       	ldd	r30, Y+2	; 0x02
    4198:	fb 81       	ldd	r31, Y+3	; 0x03
    419a:	96 89       	ldd	r25, Z+22	; 0x16
    419c:	e0 91 97 05 	lds	r30, 0x0597
    41a0:	f0 91 98 05 	lds	r31, 0x0598
    41a4:	86 89       	ldd	r24, Z+22	; 0x16
    41a6:	89 17       	cp	r24, r25
    41a8:	30 f4       	brcc	.+12     	; 0x41b6 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    41aa:	81 e0       	ldi	r24, 0x01	; 1
    41ac:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    41ae:	81 e0       	ldi	r24, 0x01	; 1
    41b0:	80 93 a0 05 	sts	0x05A0, r24
    41b4:	01 c0       	rjmp	.+2      	; 0x41b8 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    41b6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    41b8:	89 81       	ldd	r24, Y+1	; 0x01
}
    41ba:	27 96       	adiw	r28, 0x07	; 7
    41bc:	0f b6       	in	r0, 0x3f	; 63
    41be:	f8 94       	cli
    41c0:	de bf       	out	0x3e, r29	; 62
    41c2:	0f be       	out	0x3f, r0	; 63
    41c4:	cd bf       	out	0x3d, r28	; 61
    41c6:	cf 91       	pop	r28
    41c8:	df 91       	pop	r29
    41ca:	08 95       	ret

000041cc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    41cc:	df 93       	push	r29
    41ce:	cf 93       	push	r28
    41d0:	00 d0       	rcall	.+0      	; 0x41d2 <vTaskSetTimeOutState+0x6>
    41d2:	cd b7       	in	r28, 0x3d	; 61
    41d4:	de b7       	in	r29, 0x3e	; 62
    41d6:	9a 83       	std	Y+2, r25	; 0x02
    41d8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    41da:	80 91 a1 05 	lds	r24, 0x05A1
    41de:	e9 81       	ldd	r30, Y+1	; 0x01
    41e0:	fa 81       	ldd	r31, Y+2	; 0x02
    41e2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    41e4:	80 91 9b 05 	lds	r24, 0x059B
    41e8:	90 91 9c 05 	lds	r25, 0x059C
    41ec:	e9 81       	ldd	r30, Y+1	; 0x01
    41ee:	fa 81       	ldd	r31, Y+2	; 0x02
    41f0:	92 83       	std	Z+2, r25	; 0x02
    41f2:	81 83       	std	Z+1, r24	; 0x01
}
    41f4:	0f 90       	pop	r0
    41f6:	0f 90       	pop	r0
    41f8:	cf 91       	pop	r28
    41fa:	df 91       	pop	r29
    41fc:	08 95       	ret

000041fe <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    41fe:	df 93       	push	r29
    4200:	cf 93       	push	r28
    4202:	cd b7       	in	r28, 0x3d	; 61
    4204:	de b7       	in	r29, 0x3e	; 62
    4206:	27 97       	sbiw	r28, 0x07	; 7
    4208:	0f b6       	in	r0, 0x3f	; 63
    420a:	f8 94       	cli
    420c:	de bf       	out	0x3e, r29	; 62
    420e:	0f be       	out	0x3f, r0	; 63
    4210:	cd bf       	out	0x3d, r28	; 61
    4212:	9d 83       	std	Y+5, r25	; 0x05
    4214:	8c 83       	std	Y+4, r24	; 0x04
    4216:	7f 83       	std	Y+7, r23	; 0x07
    4218:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    421a:	0f b6       	in	r0, 0x3f	; 63
    421c:	f8 94       	cli
    421e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4220:	80 91 9b 05 	lds	r24, 0x059B
    4224:	90 91 9c 05 	lds	r25, 0x059C
    4228:	9a 83       	std	Y+2, r25	; 0x02
    422a:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    422c:	ec 81       	ldd	r30, Y+4	; 0x04
    422e:	fd 81       	ldd	r31, Y+5	; 0x05
    4230:	90 81       	ld	r25, Z
    4232:	80 91 a1 05 	lds	r24, 0x05A1
    4236:	98 17       	cp	r25, r24
    4238:	61 f0       	breq	.+24     	; 0x4252 <xTaskCheckForTimeOut+0x54>
    423a:	ec 81       	ldd	r30, Y+4	; 0x04
    423c:	fd 81       	ldd	r31, Y+5	; 0x05
    423e:	21 81       	ldd	r18, Z+1	; 0x01
    4240:	32 81       	ldd	r19, Z+2	; 0x02
    4242:	89 81       	ldd	r24, Y+1	; 0x01
    4244:	9a 81       	ldd	r25, Y+2	; 0x02
    4246:	82 17       	cp	r24, r18
    4248:	93 07       	cpc	r25, r19
    424a:	18 f0       	brcs	.+6      	; 0x4252 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    424c:	81 e0       	ldi	r24, 0x01	; 1
    424e:	8b 83       	std	Y+3, r24	; 0x03
    4250:	2d c0       	rjmp	.+90     	; 0x42ac <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    4252:	ec 81       	ldd	r30, Y+4	; 0x04
    4254:	fd 81       	ldd	r31, Y+5	; 0x05
    4256:	21 81       	ldd	r18, Z+1	; 0x01
    4258:	32 81       	ldd	r19, Z+2	; 0x02
    425a:	89 81       	ldd	r24, Y+1	; 0x01
    425c:	9a 81       	ldd	r25, Y+2	; 0x02
    425e:	ac 01       	movw	r20, r24
    4260:	42 1b       	sub	r20, r18
    4262:	53 0b       	sbc	r21, r19
    4264:	9a 01       	movw	r18, r20
    4266:	ee 81       	ldd	r30, Y+6	; 0x06
    4268:	ff 81       	ldd	r31, Y+7	; 0x07
    426a:	80 81       	ld	r24, Z
    426c:	91 81       	ldd	r25, Z+1	; 0x01
    426e:	28 17       	cp	r18, r24
    4270:	39 07       	cpc	r19, r25
    4272:	d0 f4       	brcc	.+52     	; 0x42a8 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    4274:	ee 81       	ldd	r30, Y+6	; 0x06
    4276:	ff 81       	ldd	r31, Y+7	; 0x07
    4278:	40 81       	ld	r20, Z
    427a:	51 81       	ldd	r21, Z+1	; 0x01
    427c:	ec 81       	ldd	r30, Y+4	; 0x04
    427e:	fd 81       	ldd	r31, Y+5	; 0x05
    4280:	21 81       	ldd	r18, Z+1	; 0x01
    4282:	32 81       	ldd	r19, Z+2	; 0x02
    4284:	89 81       	ldd	r24, Y+1	; 0x01
    4286:	9a 81       	ldd	r25, Y+2	; 0x02
    4288:	b9 01       	movw	r22, r18
    428a:	68 1b       	sub	r22, r24
    428c:	79 0b       	sbc	r23, r25
    428e:	cb 01       	movw	r24, r22
    4290:	84 0f       	add	r24, r20
    4292:	95 1f       	adc	r25, r21
    4294:	ee 81       	ldd	r30, Y+6	; 0x06
    4296:	ff 81       	ldd	r31, Y+7	; 0x07
    4298:	91 83       	std	Z+1, r25	; 0x01
    429a:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    429c:	8c 81       	ldd	r24, Y+4	; 0x04
    429e:	9d 81       	ldd	r25, Y+5	; 0x05
    42a0:	0e 94 e6 20 	call	0x41cc	; 0x41cc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    42a4:	1b 82       	std	Y+3, r1	; 0x03
    42a6:	02 c0       	rjmp	.+4      	; 0x42ac <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    42a8:	81 e0       	ldi	r24, 0x01	; 1
    42aa:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    42ac:	0f 90       	pop	r0
    42ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    42b0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    42b2:	27 96       	adiw	r28, 0x07	; 7
    42b4:	0f b6       	in	r0, 0x3f	; 63
    42b6:	f8 94       	cli
    42b8:	de bf       	out	0x3e, r29	; 62
    42ba:	0f be       	out	0x3f, r0	; 63
    42bc:	cd bf       	out	0x3d, r28	; 61
    42be:	cf 91       	pop	r28
    42c0:	df 91       	pop	r29
    42c2:	08 95       	ret

000042c4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    42c4:	df 93       	push	r29
    42c6:	cf 93       	push	r28
    42c8:	cd b7       	in	r28, 0x3d	; 61
    42ca:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    42cc:	81 e0       	ldi	r24, 0x01	; 1
    42ce:	80 93 a0 05 	sts	0x05A0, r24
}
    42d2:	cf 91       	pop	r28
    42d4:	df 91       	pop	r29
    42d6:	08 95       	ret

000042d8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    42d8:	df 93       	push	r29
    42da:	cf 93       	push	r28
    42dc:	00 d0       	rcall	.+0      	; 0x42de <prvIdleTask+0x6>
    42de:	cd b7       	in	r28, 0x3d	; 61
    42e0:	de b7       	in	r29, 0x3e	; 62
    42e2:	9a 83       	std	Y+2, r25	; 0x02
    42e4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    42e6:	0e 94 33 22 	call	0x4466	; 0x4466 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    42ea:	80 91 a4 05 	lds	r24, 0x05A4
    42ee:	82 30       	cpi	r24, 0x02	; 2
    42f0:	d0 f3       	brcs	.-12     	; 0x42e6 <prvIdleTask+0xe>
			{
				taskYIELD();
    42f2:	0e 94 94 11 	call	0x2328	; 0x2328 <vPortYield>
    42f6:	f7 cf       	rjmp	.-18     	; 0x42e6 <prvIdleTask+0xe>

000042f8 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    42f8:	0f 93       	push	r16
    42fa:	1f 93       	push	r17
    42fc:	df 93       	push	r29
    42fe:	cf 93       	push	r28
    4300:	cd b7       	in	r28, 0x3d	; 61
    4302:	de b7       	in	r29, 0x3e	; 62
    4304:	2a 97       	sbiw	r28, 0x0a	; 10
    4306:	0f b6       	in	r0, 0x3f	; 63
    4308:	f8 94       	cli
    430a:	de bf       	out	0x3e, r29	; 62
    430c:	0f be       	out	0x3f, r0	; 63
    430e:	cd bf       	out	0x3d, r28	; 61
    4310:	9b 83       	std	Y+3, r25	; 0x03
    4312:	8a 83       	std	Y+2, r24	; 0x02
    4314:	7d 83       	std	Y+5, r23	; 0x05
    4316:	6c 83       	std	Y+4, r22	; 0x04
    4318:	4e 83       	std	Y+6, r20	; 0x06
    431a:	38 87       	std	Y+8, r19	; 0x08
    431c:	2f 83       	std	Y+7, r18	; 0x07
    431e:	1a 87       	std	Y+10, r17	; 0x0a
    4320:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4322:	19 82       	std	Y+1, r1	; 0x01
    4324:	21 c0       	rjmp	.+66     	; 0x4368 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    4326:	89 81       	ldd	r24, Y+1	; 0x01
    4328:	48 2f       	mov	r20, r24
    432a:	50 e0       	ldi	r21, 0x00	; 0
    432c:	89 81       	ldd	r24, Y+1	; 0x01
    432e:	28 2f       	mov	r18, r24
    4330:	30 e0       	ldi	r19, 0x00	; 0
    4332:	8c 81       	ldd	r24, Y+4	; 0x04
    4334:	9d 81       	ldd	r25, Y+5	; 0x05
    4336:	fc 01       	movw	r30, r24
    4338:	e2 0f       	add	r30, r18
    433a:	f3 1f       	adc	r31, r19
    433c:	20 81       	ld	r18, Z
    433e:	8a 81       	ldd	r24, Y+2	; 0x02
    4340:	9b 81       	ldd	r25, Y+3	; 0x03
    4342:	84 0f       	add	r24, r20
    4344:	95 1f       	adc	r25, r21
    4346:	fc 01       	movw	r30, r24
    4348:	79 96       	adiw	r30, 0x19	; 25
    434a:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    434c:	89 81       	ldd	r24, Y+1	; 0x01
    434e:	28 2f       	mov	r18, r24
    4350:	30 e0       	ldi	r19, 0x00	; 0
    4352:	8c 81       	ldd	r24, Y+4	; 0x04
    4354:	9d 81       	ldd	r25, Y+5	; 0x05
    4356:	fc 01       	movw	r30, r24
    4358:	e2 0f       	add	r30, r18
    435a:	f3 1f       	adc	r31, r19
    435c:	80 81       	ld	r24, Z
    435e:	88 23       	and	r24, r24
    4360:	31 f0       	breq	.+12     	; 0x436e <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4362:	89 81       	ldd	r24, Y+1	; 0x01
    4364:	8f 5f       	subi	r24, 0xFF	; 255
    4366:	89 83       	std	Y+1, r24	; 0x01
    4368:	89 81       	ldd	r24, Y+1	; 0x01
    436a:	84 31       	cpi	r24, 0x14	; 20
    436c:	e0 f2       	brcs	.-72     	; 0x4326 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    436e:	ea 81       	ldd	r30, Y+2	; 0x02
    4370:	fb 81       	ldd	r31, Y+3	; 0x03
    4372:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4374:	8e 81       	ldd	r24, Y+6	; 0x06
    4376:	84 30       	cpi	r24, 0x04	; 4
    4378:	10 f0       	brcs	.+4      	; 0x437e <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    437a:	83 e0       	ldi	r24, 0x03	; 3
    437c:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    437e:	ea 81       	ldd	r30, Y+2	; 0x02
    4380:	fb 81       	ldd	r31, Y+3	; 0x03
    4382:	8e 81       	ldd	r24, Y+6	; 0x06
    4384:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    4386:	ea 81       	ldd	r30, Y+2	; 0x02
    4388:	fb 81       	ldd	r31, Y+3	; 0x03
    438a:	8e 81       	ldd	r24, Y+6	; 0x06
    438c:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    438e:	ea 81       	ldd	r30, Y+2	; 0x02
    4390:	fb 81       	ldd	r31, Y+3	; 0x03
    4392:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4394:	8a 81       	ldd	r24, Y+2	; 0x02
    4396:	9b 81       	ldd	r25, Y+3	; 0x03
    4398:	02 96       	adiw	r24, 0x02	; 2
    439a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    439e:	8a 81       	ldd	r24, Y+2	; 0x02
    43a0:	9b 81       	ldd	r25, Y+3	; 0x03
    43a2:	0c 96       	adiw	r24, 0x0c	; 12
    43a4:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    43a8:	ea 81       	ldd	r30, Y+2	; 0x02
    43aa:	fb 81       	ldd	r31, Y+3	; 0x03
    43ac:	8a 81       	ldd	r24, Y+2	; 0x02
    43ae:	9b 81       	ldd	r25, Y+3	; 0x03
    43b0:	91 87       	std	Z+9, r25	; 0x09
    43b2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43b4:	8e 81       	ldd	r24, Y+6	; 0x06
    43b6:	28 2f       	mov	r18, r24
    43b8:	30 e0       	ldi	r19, 0x00	; 0
    43ba:	84 e0       	ldi	r24, 0x04	; 4
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	82 1b       	sub	r24, r18
    43c0:	93 0b       	sbc	r25, r19
    43c2:	ea 81       	ldd	r30, Y+2	; 0x02
    43c4:	fb 81       	ldd	r31, Y+3	; 0x03
    43c6:	95 87       	std	Z+13, r25	; 0x0d
    43c8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    43ca:	ea 81       	ldd	r30, Y+2	; 0x02
    43cc:	fb 81       	ldd	r31, Y+3	; 0x03
    43ce:	8a 81       	ldd	r24, Y+2	; 0x02
    43d0:	9b 81       	ldd	r25, Y+3	; 0x03
    43d2:	93 8b       	std	Z+19, r25	; 0x13
    43d4:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    43d6:	2a 96       	adiw	r28, 0x0a	; 10
    43d8:	0f b6       	in	r0, 0x3f	; 63
    43da:	f8 94       	cli
    43dc:	de bf       	out	0x3e, r29	; 62
    43de:	0f be       	out	0x3f, r0	; 63
    43e0:	cd bf       	out	0x3d, r28	; 61
    43e2:	cf 91       	pop	r28
    43e4:	df 91       	pop	r29
    43e6:	1f 91       	pop	r17
    43e8:	0f 91       	pop	r16
    43ea:	08 95       	ret

000043ec <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    43ec:	df 93       	push	r29
    43ee:	cf 93       	push	r28
    43f0:	0f 92       	push	r0
    43f2:	cd b7       	in	r28, 0x3d	; 61
    43f4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    43f6:	19 82       	std	Y+1, r1	; 0x01
    43f8:	13 c0       	rjmp	.+38     	; 0x4420 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    43fa:	89 81       	ldd	r24, Y+1	; 0x01
    43fc:	28 2f       	mov	r18, r24
    43fe:	30 e0       	ldi	r19, 0x00	; 0
    4400:	c9 01       	movw	r24, r18
    4402:	88 0f       	add	r24, r24
    4404:	99 1f       	adc	r25, r25
    4406:	88 0f       	add	r24, r24
    4408:	99 1f       	adc	r25, r25
    440a:	88 0f       	add	r24, r24
    440c:	99 1f       	adc	r25, r25
    440e:	82 0f       	add	r24, r18
    4410:	93 1f       	adc	r25, r19
    4412:	8c 55       	subi	r24, 0x5C	; 92
    4414:	9a 4f       	sbci	r25, 0xFA	; 250
    4416:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    441a:	89 81       	ldd	r24, Y+1	; 0x01
    441c:	8f 5f       	subi	r24, 0xFF	; 255
    441e:	89 83       	std	Y+1, r24	; 0x01
    4420:	89 81       	ldd	r24, Y+1	; 0x01
    4422:	84 30       	cpi	r24, 0x04	; 4
    4424:	50 f3       	brcs	.-44     	; 0x43fa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4426:	88 ec       	ldi	r24, 0xC8	; 200
    4428:	95 e0       	ldi	r25, 0x05	; 5
    442a:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    442e:	81 ed       	ldi	r24, 0xD1	; 209
    4430:	95 e0       	ldi	r25, 0x05	; 5
    4432:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4436:	8e ed       	ldi	r24, 0xDE	; 222
    4438:	95 e0       	ldi	r25, 0x05	; 5
    443a:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    443e:	87 ee       	ldi	r24, 0xE7	; 231
    4440:	95 e0       	ldi	r25, 0x05	; 5
    4442:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4446:	88 ec       	ldi	r24, 0xC8	; 200
    4448:	95 e0       	ldi	r25, 0x05	; 5
    444a:	90 93 db 05 	sts	0x05DB, r25
    444e:	80 93 da 05 	sts	0x05DA, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4452:	81 ed       	ldi	r24, 0xD1	; 209
    4454:	95 e0       	ldi	r25, 0x05	; 5
    4456:	90 93 dd 05 	sts	0x05DD, r25
    445a:	80 93 dc 05 	sts	0x05DC, r24
}
    445e:	0f 90       	pop	r0
    4460:	cf 91       	pop	r28
    4462:	df 91       	pop	r29
    4464:	08 95       	ret

00004466 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4466:	df 93       	push	r29
    4468:	cf 93       	push	r28
    446a:	00 d0       	rcall	.+0      	; 0x446c <prvCheckTasksWaitingTermination+0x6>
    446c:	0f 92       	push	r0
    446e:	cd b7       	in	r28, 0x3d	; 61
    4470:	de b7       	in	r29, 0x3e	; 62
    4472:	2e c0       	rjmp	.+92     	; 0x44d0 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    4474:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4478:	80 91 e7 05 	lds	r24, 0x05E7
    447c:	1b 82       	std	Y+3, r1	; 0x03
    447e:	88 23       	and	r24, r24
    4480:	11 f4       	brne	.+4      	; 0x4486 <prvCheckTasksWaitingTermination+0x20>
    4482:	81 e0       	ldi	r24, 0x01	; 1
    4484:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    4486:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    448a:	8b 81       	ldd	r24, Y+3	; 0x03
    448c:	88 23       	and	r24, r24
    448e:	01 f5       	brne	.+64     	; 0x44d0 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    4490:	0f b6       	in	r0, 0x3f	; 63
    4492:	f8 94       	cli
    4494:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    4496:	e0 91 ec 05 	lds	r30, 0x05EC
    449a:	f0 91 ed 05 	lds	r31, 0x05ED
    449e:	86 81       	ldd	r24, Z+6	; 0x06
    44a0:	97 81       	ldd	r25, Z+7	; 0x07
    44a2:	9a 83       	std	Y+2, r25	; 0x02
    44a4:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    44a6:	89 81       	ldd	r24, Y+1	; 0x01
    44a8:	9a 81       	ldd	r25, Y+2	; 0x02
    44aa:	02 96       	adiw	r24, 0x02	; 2
    44ac:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					--uxCurrentNumberOfTasks;
    44b0:	80 91 9a 05 	lds	r24, 0x059A
    44b4:	81 50       	subi	r24, 0x01	; 1
    44b6:	80 93 9a 05 	sts	0x059A, r24
					--uxTasksDeleted;
    44ba:	80 91 99 05 	lds	r24, 0x0599
    44be:	81 50       	subi	r24, 0x01	; 1
    44c0:	80 93 99 05 	sts	0x0599, r24
				}
				taskEXIT_CRITICAL();
    44c4:	0f 90       	pop	r0
    44c6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    44c8:	89 81       	ldd	r24, Y+1	; 0x01
    44ca:	9a 81       	ldd	r25, Y+2	; 0x02
    44cc:	0e 94 ff 22 	call	0x45fe	; 0x45fe <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    44d0:	80 91 99 05 	lds	r24, 0x0599
    44d4:	88 23       	and	r24, r24
    44d6:	71 f6       	brne	.-100    	; 0x4474 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    44d8:	0f 90       	pop	r0
    44da:	0f 90       	pop	r0
    44dc:	0f 90       	pop	r0
    44de:	cf 91       	pop	r28
    44e0:	df 91       	pop	r29
    44e2:	08 95       	ret

000044e4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    44e4:	df 93       	push	r29
    44e6:	cf 93       	push	r28
    44e8:	00 d0       	rcall	.+0      	; 0x44ea <prvAddCurrentTaskToDelayedList+0x6>
    44ea:	cd b7       	in	r28, 0x3d	; 61
    44ec:	de b7       	in	r29, 0x3e	; 62
    44ee:	9a 83       	std	Y+2, r25	; 0x02
    44f0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    44f2:	e0 91 97 05 	lds	r30, 0x0597
    44f6:	f0 91 98 05 	lds	r31, 0x0598
    44fa:	89 81       	ldd	r24, Y+1	; 0x01
    44fc:	9a 81       	ldd	r25, Y+2	; 0x02
    44fe:	93 83       	std	Z+3, r25	; 0x03
    4500:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4502:	20 91 9b 05 	lds	r18, 0x059B
    4506:	30 91 9c 05 	lds	r19, 0x059C
    450a:	89 81       	ldd	r24, Y+1	; 0x01
    450c:	9a 81       	ldd	r25, Y+2	; 0x02
    450e:	82 17       	cp	r24, r18
    4510:	93 07       	cpc	r25, r19
    4512:	70 f4       	brcc	.+28     	; 0x4530 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4514:	80 91 dc 05 	lds	r24, 0x05DC
    4518:	90 91 dd 05 	lds	r25, 0x05DD
    451c:	20 91 97 05 	lds	r18, 0x0597
    4520:	30 91 98 05 	lds	r19, 0x0598
    4524:	2e 5f       	subi	r18, 0xFE	; 254
    4526:	3f 4f       	sbci	r19, 0xFF	; 255
    4528:	b9 01       	movw	r22, r18
    452a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>
    452e:	1e c0       	rjmp	.+60     	; 0x456c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4530:	40 91 da 05 	lds	r20, 0x05DA
    4534:	50 91 db 05 	lds	r21, 0x05DB
    4538:	80 91 97 05 	lds	r24, 0x0597
    453c:	90 91 98 05 	lds	r25, 0x0598
    4540:	9c 01       	movw	r18, r24
    4542:	2e 5f       	subi	r18, 0xFE	; 254
    4544:	3f 4f       	sbci	r19, 0xFF	; 255
    4546:	ca 01       	movw	r24, r20
    4548:	b9 01       	movw	r22, r18
    454a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    454e:	20 91 ca 00 	lds	r18, 0x00CA
    4552:	30 91 cb 00 	lds	r19, 0x00CB
    4556:	89 81       	ldd	r24, Y+1	; 0x01
    4558:	9a 81       	ldd	r25, Y+2	; 0x02
    455a:	82 17       	cp	r24, r18
    455c:	93 07       	cpc	r25, r19
    455e:	30 f4       	brcc	.+12     	; 0x456c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4560:	89 81       	ldd	r24, Y+1	; 0x01
    4562:	9a 81       	ldd	r25, Y+2	; 0x02
    4564:	90 93 cb 00 	sts	0x00CB, r25
    4568:	80 93 ca 00 	sts	0x00CA, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    456c:	0f 90       	pop	r0
    456e:	0f 90       	pop	r0
    4570:	cf 91       	pop	r28
    4572:	df 91       	pop	r29
    4574:	08 95       	ret

00004576 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4576:	df 93       	push	r29
    4578:	cf 93       	push	r28
    457a:	cd b7       	in	r28, 0x3d	; 61
    457c:	de b7       	in	r29, 0x3e	; 62
    457e:	28 97       	sbiw	r28, 0x08	; 8
    4580:	0f b6       	in	r0, 0x3f	; 63
    4582:	f8 94       	cli
    4584:	de bf       	out	0x3e, r29	; 62
    4586:	0f be       	out	0x3f, r0	; 63
    4588:	cd bf       	out	0x3d, r28	; 61
    458a:	9c 83       	std	Y+4, r25	; 0x04
    458c:	8b 83       	std	Y+3, r24	; 0x03
    458e:	7e 83       	std	Y+6, r23	; 0x06
    4590:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    4592:	8f e2       	ldi	r24, 0x2F	; 47
    4594:	90 e0       	ldi	r25, 0x00	; 0
    4596:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    459a:	9a 83       	std	Y+2, r25	; 0x02
    459c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    459e:	89 81       	ldd	r24, Y+1	; 0x01
    45a0:	9a 81       	ldd	r25, Y+2	; 0x02
    45a2:	00 97       	sbiw	r24, 0x00	; 0
    45a4:	09 f1       	breq	.+66     	; 0x45e8 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    45a6:	8d 81       	ldd	r24, Y+5	; 0x05
    45a8:	9e 81       	ldd	r25, Y+6	; 0x06
    45aa:	00 97       	sbiw	r24, 0x00	; 0
    45ac:	39 f4       	brne	.+14     	; 0x45bc <prvAllocateTCBAndStack+0x46>
    45ae:	8b 81       	ldd	r24, Y+3	; 0x03
    45b0:	9c 81       	ldd	r25, Y+4	; 0x04
    45b2:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <pvPortMalloc>
    45b6:	98 87       	std	Y+8, r25	; 0x08
    45b8:	8f 83       	std	Y+7, r24	; 0x07
    45ba:	04 c0       	rjmp	.+8      	; 0x45c4 <prvAllocateTCBAndStack+0x4e>
    45bc:	8d 81       	ldd	r24, Y+5	; 0x05
    45be:	9e 81       	ldd	r25, Y+6	; 0x06
    45c0:	98 87       	std	Y+8, r25	; 0x08
    45c2:	8f 83       	std	Y+7, r24	; 0x07
    45c4:	e9 81       	ldd	r30, Y+1	; 0x01
    45c6:	fa 81       	ldd	r31, Y+2	; 0x02
    45c8:	8f 81       	ldd	r24, Y+7	; 0x07
    45ca:	98 85       	ldd	r25, Y+8	; 0x08
    45cc:	90 8f       	std	Z+24, r25	; 0x18
    45ce:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    45d0:	e9 81       	ldd	r30, Y+1	; 0x01
    45d2:	fa 81       	ldd	r31, Y+2	; 0x02
    45d4:	87 89       	ldd	r24, Z+23	; 0x17
    45d6:	90 8d       	ldd	r25, Z+24	; 0x18
    45d8:	00 97       	sbiw	r24, 0x00	; 0
    45da:	31 f4       	brne	.+12     	; 0x45e8 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    45dc:	89 81       	ldd	r24, Y+1	; 0x01
    45de:	9a 81       	ldd	r25, Y+2	; 0x02
    45e0:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
			pxNewTCB = NULL;
    45e4:	1a 82       	std	Y+2, r1	; 0x02
    45e6:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    45e8:	89 81       	ldd	r24, Y+1	; 0x01
    45ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    45ec:	28 96       	adiw	r28, 0x08	; 8
    45ee:	0f b6       	in	r0, 0x3f	; 63
    45f0:	f8 94       	cli
    45f2:	de bf       	out	0x3e, r29	; 62
    45f4:	0f be       	out	0x3f, r0	; 63
    45f6:	cd bf       	out	0x3d, r28	; 61
    45f8:	cf 91       	pop	r28
    45fa:	df 91       	pop	r29
    45fc:	08 95       	ret

000045fe <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    45fe:	df 93       	push	r29
    4600:	cf 93       	push	r28
    4602:	00 d0       	rcall	.+0      	; 0x4604 <prvDeleteTCB+0x6>
    4604:	cd b7       	in	r28, 0x3d	; 61
    4606:	de b7       	in	r29, 0x3e	; 62
    4608:	9a 83       	std	Y+2, r25	; 0x02
    460a:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    460c:	e9 81       	ldd	r30, Y+1	; 0x01
    460e:	fa 81       	ldd	r31, Y+2	; 0x02
    4610:	87 89       	ldd	r24, Z+23	; 0x17
    4612:	90 8d       	ldd	r25, Z+24	; 0x18
    4614:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
		vPortFree( pxTCB );
    4618:	89 81       	ldd	r24, Y+1	; 0x01
    461a:	9a 81       	ldd	r25, Y+2	; 0x02
    461c:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vPortFree>
	}
    4620:	0f 90       	pop	r0
    4622:	0f 90       	pop	r0
    4624:	cf 91       	pop	r28
    4626:	df 91       	pop	r29
    4628:	08 95       	ret

0000462a <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    462a:	df 93       	push	r29
    462c:	cf 93       	push	r28
    462e:	00 d0       	rcall	.+0      	; 0x4630 <prvResetNextTaskUnblockTime+0x6>
    4630:	cd b7       	in	r28, 0x3d	; 61
    4632:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4634:	e0 91 da 05 	lds	r30, 0x05DA
    4638:	f0 91 db 05 	lds	r31, 0x05DB
    463c:	80 81       	ld	r24, Z
    463e:	88 23       	and	r24, r24
    4640:	39 f4       	brne	.+14     	; 0x4650 <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4642:	8f ef       	ldi	r24, 0xFF	; 255
    4644:	9f ef       	ldi	r25, 0xFF	; 255
    4646:	90 93 cb 00 	sts	0x00CB, r25
    464a:	80 93 ca 00 	sts	0x00CA, r24
    464e:	13 c0       	rjmp	.+38     	; 0x4676 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4650:	e0 91 da 05 	lds	r30, 0x05DA
    4654:	f0 91 db 05 	lds	r31, 0x05DB
    4658:	05 80       	ldd	r0, Z+5	; 0x05
    465a:	f6 81       	ldd	r31, Z+6	; 0x06
    465c:	e0 2d       	mov	r30, r0
    465e:	86 81       	ldd	r24, Z+6	; 0x06
    4660:	97 81       	ldd	r25, Z+7	; 0x07
    4662:	9a 83       	std	Y+2, r25	; 0x02
    4664:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4666:	e9 81       	ldd	r30, Y+1	; 0x01
    4668:	fa 81       	ldd	r31, Y+2	; 0x02
    466a:	82 81       	ldd	r24, Z+2	; 0x02
    466c:	93 81       	ldd	r25, Z+3	; 0x03
    466e:	90 93 cb 00 	sts	0x00CB, r25
    4672:	80 93 ca 00 	sts	0x00CA, r24
	}
}
    4676:	0f 90       	pop	r0
    4678:	0f 90       	pop	r0
    467a:	cf 91       	pop	r28
    467c:	df 91       	pop	r29
    467e:	08 95       	ret

00004680 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4680:	df 93       	push	r29
    4682:	cf 93       	push	r28
    4684:	00 d0       	rcall	.+0      	; 0x4686 <xTaskGetCurrentTaskHandle+0x6>
    4686:	cd b7       	in	r28, 0x3d	; 61
    4688:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    468a:	80 91 97 05 	lds	r24, 0x0597
    468e:	90 91 98 05 	lds	r25, 0x0598
    4692:	9a 83       	std	Y+2, r25	; 0x02
    4694:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4696:	89 81       	ldd	r24, Y+1	; 0x01
    4698:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    469a:	0f 90       	pop	r0
    469c:	0f 90       	pop	r0
    469e:	cf 91       	pop	r28
    46a0:	df 91       	pop	r29
    46a2:	08 95       	ret

000046a4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    46a4:	df 93       	push	r29
    46a6:	cf 93       	push	r28
    46a8:	00 d0       	rcall	.+0      	; 0x46aa <vTaskPriorityInherit+0x6>
    46aa:	00 d0       	rcall	.+0      	; 0x46ac <vTaskPriorityInherit+0x8>
    46ac:	cd b7       	in	r28, 0x3d	; 61
    46ae:	de b7       	in	r29, 0x3e	; 62
    46b0:	9c 83       	std	Y+4, r25	; 0x04
    46b2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    46b4:	8b 81       	ldd	r24, Y+3	; 0x03
    46b6:	9c 81       	ldd	r25, Y+4	; 0x04
    46b8:	9a 83       	std	Y+2, r25	; 0x02
    46ba:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    46bc:	8b 81       	ldd	r24, Y+3	; 0x03
    46be:	9c 81       	ldd	r25, Y+4	; 0x04
    46c0:	00 97       	sbiw	r24, 0x00	; 0
    46c2:	09 f4       	brne	.+2      	; 0x46c6 <vTaskPriorityInherit+0x22>
    46c4:	73 c0       	rjmp	.+230    	; 0x47ac <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    46c6:	e9 81       	ldd	r30, Y+1	; 0x01
    46c8:	fa 81       	ldd	r31, Y+2	; 0x02
    46ca:	96 89       	ldd	r25, Z+22	; 0x16
    46cc:	e0 91 97 05 	lds	r30, 0x0597
    46d0:	f0 91 98 05 	lds	r31, 0x0598
    46d4:	86 89       	ldd	r24, Z+22	; 0x16
    46d6:	98 17       	cp	r25, r24
    46d8:	08 f0       	brcs	.+2      	; 0x46dc <vTaskPriorityInherit+0x38>
    46da:	68 c0       	rjmp	.+208    	; 0x47ac <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    46dc:	e9 81       	ldd	r30, Y+1	; 0x01
    46de:	fa 81       	ldd	r31, Y+2	; 0x02
    46e0:	84 85       	ldd	r24, Z+12	; 0x0c
    46e2:	95 85       	ldd	r25, Z+13	; 0x0d
    46e4:	99 23       	and	r25, r25
    46e6:	7c f0       	brlt	.+30     	; 0x4706 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46e8:	e0 91 97 05 	lds	r30, 0x0597
    46ec:	f0 91 98 05 	lds	r31, 0x0598
    46f0:	86 89       	ldd	r24, Z+22	; 0x16
    46f2:	28 2f       	mov	r18, r24
    46f4:	30 e0       	ldi	r19, 0x00	; 0
    46f6:	84 e0       	ldi	r24, 0x04	; 4
    46f8:	90 e0       	ldi	r25, 0x00	; 0
    46fa:	82 1b       	sub	r24, r18
    46fc:	93 0b       	sbc	r25, r19
    46fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4700:	fa 81       	ldd	r31, Y+2	; 0x02
    4702:	95 87       	std	Z+13, r25	; 0x0d
    4704:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4706:	e9 81       	ldd	r30, Y+1	; 0x01
    4708:	fa 81       	ldd	r31, Y+2	; 0x02
    470a:	42 85       	ldd	r20, Z+10	; 0x0a
    470c:	53 85       	ldd	r21, Z+11	; 0x0b
    470e:	e9 81       	ldd	r30, Y+1	; 0x01
    4710:	fa 81       	ldd	r31, Y+2	; 0x02
    4712:	86 89       	ldd	r24, Z+22	; 0x16
    4714:	28 2f       	mov	r18, r24
    4716:	30 e0       	ldi	r19, 0x00	; 0
    4718:	c9 01       	movw	r24, r18
    471a:	88 0f       	add	r24, r24
    471c:	99 1f       	adc	r25, r25
    471e:	88 0f       	add	r24, r24
    4720:	99 1f       	adc	r25, r25
    4722:	88 0f       	add	r24, r24
    4724:	99 1f       	adc	r25, r25
    4726:	82 0f       	add	r24, r18
    4728:	93 1f       	adc	r25, r19
    472a:	8c 55       	subi	r24, 0x5C	; 92
    472c:	9a 4f       	sbci	r25, 0xFA	; 250
    472e:	48 17       	cp	r20, r24
    4730:	59 07       	cpc	r21, r25
    4732:	a1 f5       	brne	.+104    	; 0x479c <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4734:	89 81       	ldd	r24, Y+1	; 0x01
    4736:	9a 81       	ldd	r25, Y+2	; 0x02
    4738:	02 96       	adiw	r24, 0x02	; 2
    473a:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    473e:	e0 91 97 05 	lds	r30, 0x0597
    4742:	f0 91 98 05 	lds	r31, 0x0598
    4746:	86 89       	ldd	r24, Z+22	; 0x16
    4748:	e9 81       	ldd	r30, Y+1	; 0x01
    474a:	fa 81       	ldd	r31, Y+2	; 0x02
    474c:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    474e:	e9 81       	ldd	r30, Y+1	; 0x01
    4750:	fa 81       	ldd	r31, Y+2	; 0x02
    4752:	96 89       	ldd	r25, Z+22	; 0x16
    4754:	80 91 9d 05 	lds	r24, 0x059D
    4758:	89 17       	cp	r24, r25
    475a:	28 f4       	brcc	.+10     	; 0x4766 <vTaskPriorityInherit+0xc2>
    475c:	e9 81       	ldd	r30, Y+1	; 0x01
    475e:	fa 81       	ldd	r31, Y+2	; 0x02
    4760:	86 89       	ldd	r24, Z+22	; 0x16
    4762:	80 93 9d 05 	sts	0x059D, r24
    4766:	e9 81       	ldd	r30, Y+1	; 0x01
    4768:	fa 81       	ldd	r31, Y+2	; 0x02
    476a:	86 89       	ldd	r24, Z+22	; 0x16
    476c:	28 2f       	mov	r18, r24
    476e:	30 e0       	ldi	r19, 0x00	; 0
    4770:	c9 01       	movw	r24, r18
    4772:	88 0f       	add	r24, r24
    4774:	99 1f       	adc	r25, r25
    4776:	88 0f       	add	r24, r24
    4778:	99 1f       	adc	r25, r25
    477a:	88 0f       	add	r24, r24
    477c:	99 1f       	adc	r25, r25
    477e:	82 0f       	add	r24, r18
    4780:	93 1f       	adc	r25, r19
    4782:	ac 01       	movw	r20, r24
    4784:	4c 55       	subi	r20, 0x5C	; 92
    4786:	5a 4f       	sbci	r21, 0xFA	; 250
    4788:	89 81       	ldd	r24, Y+1	; 0x01
    478a:	9a 81       	ldd	r25, Y+2	; 0x02
    478c:	9c 01       	movw	r18, r24
    478e:	2e 5f       	subi	r18, 0xFE	; 254
    4790:	3f 4f       	sbci	r19, 0xFF	; 255
    4792:	ca 01       	movw	r24, r20
    4794:	b9 01       	movw	r22, r18
    4796:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>
    479a:	08 c0       	rjmp	.+16     	; 0x47ac <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    479c:	e0 91 97 05 	lds	r30, 0x0597
    47a0:	f0 91 98 05 	lds	r31, 0x0598
    47a4:	86 89       	ldd	r24, Z+22	; 0x16
    47a6:	e9 81       	ldd	r30, Y+1	; 0x01
    47a8:	fa 81       	ldd	r31, Y+2	; 0x02
    47aa:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    47ac:	0f 90       	pop	r0
    47ae:	0f 90       	pop	r0
    47b0:	0f 90       	pop	r0
    47b2:	0f 90       	pop	r0
    47b4:	cf 91       	pop	r28
    47b6:	df 91       	pop	r29
    47b8:	08 95       	ret

000047ba <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    47ba:	df 93       	push	r29
    47bc:	cf 93       	push	r28
    47be:	00 d0       	rcall	.+0      	; 0x47c0 <xTaskPriorityDisinherit+0x6>
    47c0:	00 d0       	rcall	.+0      	; 0x47c2 <xTaskPriorityDisinherit+0x8>
    47c2:	0f 92       	push	r0
    47c4:	cd b7       	in	r28, 0x3d	; 61
    47c6:	de b7       	in	r29, 0x3e	; 62
    47c8:	9d 83       	std	Y+5, r25	; 0x05
    47ca:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    47cc:	8c 81       	ldd	r24, Y+4	; 0x04
    47ce:	9d 81       	ldd	r25, Y+5	; 0x05
    47d0:	9b 83       	std	Y+3, r25	; 0x03
    47d2:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    47d4:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    47d6:	8c 81       	ldd	r24, Y+4	; 0x04
    47d8:	9d 81       	ldd	r25, Y+5	; 0x05
    47da:	00 97       	sbiw	r24, 0x00	; 0
    47dc:	09 f4       	brne	.+2      	; 0x47e0 <xTaskPriorityDisinherit+0x26>
    47de:	56 c0       	rjmp	.+172    	; 0x488c <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    47e0:	ea 81       	ldd	r30, Y+2	; 0x02
    47e2:	fb 81       	ldd	r31, Y+3	; 0x03
    47e4:	86 a5       	ldd	r24, Z+46	; 0x2e
    47e6:	81 50       	subi	r24, 0x01	; 1
    47e8:	ea 81       	ldd	r30, Y+2	; 0x02
    47ea:	fb 81       	ldd	r31, Y+3	; 0x03
    47ec:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    47ee:	ea 81       	ldd	r30, Y+2	; 0x02
    47f0:	fb 81       	ldd	r31, Y+3	; 0x03
    47f2:	96 89       	ldd	r25, Z+22	; 0x16
    47f4:	ea 81       	ldd	r30, Y+2	; 0x02
    47f6:	fb 81       	ldd	r31, Y+3	; 0x03
    47f8:	85 a5       	ldd	r24, Z+45	; 0x2d
    47fa:	98 17       	cp	r25, r24
    47fc:	09 f4       	brne	.+2      	; 0x4800 <xTaskPriorityDisinherit+0x46>
    47fe:	46 c0       	rjmp	.+140    	; 0x488c <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4800:	ea 81       	ldd	r30, Y+2	; 0x02
    4802:	fb 81       	ldd	r31, Y+3	; 0x03
    4804:	86 a5       	ldd	r24, Z+46	; 0x2e
    4806:	88 23       	and	r24, r24
    4808:	09 f0       	breq	.+2      	; 0x480c <xTaskPriorityDisinherit+0x52>
    480a:	40 c0       	rjmp	.+128    	; 0x488c <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    480c:	8a 81       	ldd	r24, Y+2	; 0x02
    480e:	9b 81       	ldd	r25, Y+3	; 0x03
    4810:	02 96       	adiw	r24, 0x02	; 2
    4812:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4816:	ea 81       	ldd	r30, Y+2	; 0x02
    4818:	fb 81       	ldd	r31, Y+3	; 0x03
    481a:	85 a5       	ldd	r24, Z+45	; 0x2d
    481c:	ea 81       	ldd	r30, Y+2	; 0x02
    481e:	fb 81       	ldd	r31, Y+3	; 0x03
    4820:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4822:	ea 81       	ldd	r30, Y+2	; 0x02
    4824:	fb 81       	ldd	r31, Y+3	; 0x03
    4826:	86 89       	ldd	r24, Z+22	; 0x16
    4828:	28 2f       	mov	r18, r24
    482a:	30 e0       	ldi	r19, 0x00	; 0
    482c:	84 e0       	ldi	r24, 0x04	; 4
    482e:	90 e0       	ldi	r25, 0x00	; 0
    4830:	82 1b       	sub	r24, r18
    4832:	93 0b       	sbc	r25, r19
    4834:	ea 81       	ldd	r30, Y+2	; 0x02
    4836:	fb 81       	ldd	r31, Y+3	; 0x03
    4838:	95 87       	std	Z+13, r25	; 0x0d
    483a:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    483c:	ea 81       	ldd	r30, Y+2	; 0x02
    483e:	fb 81       	ldd	r31, Y+3	; 0x03
    4840:	96 89       	ldd	r25, Z+22	; 0x16
    4842:	80 91 9d 05 	lds	r24, 0x059D
    4846:	89 17       	cp	r24, r25
    4848:	28 f4       	brcc	.+10     	; 0x4854 <xTaskPriorityDisinherit+0x9a>
    484a:	ea 81       	ldd	r30, Y+2	; 0x02
    484c:	fb 81       	ldd	r31, Y+3	; 0x03
    484e:	86 89       	ldd	r24, Z+22	; 0x16
    4850:	80 93 9d 05 	sts	0x059D, r24
    4854:	ea 81       	ldd	r30, Y+2	; 0x02
    4856:	fb 81       	ldd	r31, Y+3	; 0x03
    4858:	86 89       	ldd	r24, Z+22	; 0x16
    485a:	28 2f       	mov	r18, r24
    485c:	30 e0       	ldi	r19, 0x00	; 0
    485e:	c9 01       	movw	r24, r18
    4860:	88 0f       	add	r24, r24
    4862:	99 1f       	adc	r25, r25
    4864:	88 0f       	add	r24, r24
    4866:	99 1f       	adc	r25, r25
    4868:	88 0f       	add	r24, r24
    486a:	99 1f       	adc	r25, r25
    486c:	82 0f       	add	r24, r18
    486e:	93 1f       	adc	r25, r19
    4870:	ac 01       	movw	r20, r24
    4872:	4c 55       	subi	r20, 0x5C	; 92
    4874:	5a 4f       	sbci	r21, 0xFA	; 250
    4876:	8a 81       	ldd	r24, Y+2	; 0x02
    4878:	9b 81       	ldd	r25, Y+3	; 0x03
    487a:	9c 01       	movw	r18, r24
    487c:	2e 5f       	subi	r18, 0xFE	; 254
    487e:	3f 4f       	sbci	r19, 0xFF	; 255
    4880:	ca 01       	movw	r24, r20
    4882:	b9 01       	movw	r22, r18
    4884:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    4888:	81 e0       	ldi	r24, 0x01	; 1
    488a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    488c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    488e:	0f 90       	pop	r0
    4890:	0f 90       	pop	r0
    4892:	0f 90       	pop	r0
    4894:	0f 90       	pop	r0
    4896:	0f 90       	pop	r0
    4898:	cf 91       	pop	r28
    489a:	df 91       	pop	r29
    489c:	08 95       	ret

0000489e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    489e:	df 93       	push	r29
    48a0:	cf 93       	push	r28
    48a2:	00 d0       	rcall	.+0      	; 0x48a4 <uxTaskResetEventItemValue+0x6>
    48a4:	cd b7       	in	r28, 0x3d	; 61
    48a6:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    48a8:	e0 91 97 05 	lds	r30, 0x0597
    48ac:	f0 91 98 05 	lds	r31, 0x0598
    48b0:	84 85       	ldd	r24, Z+12	; 0x0c
    48b2:	95 85       	ldd	r25, Z+13	; 0x0d
    48b4:	9a 83       	std	Y+2, r25	; 0x02
    48b6:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    48b8:	a0 91 97 05 	lds	r26, 0x0597
    48bc:	b0 91 98 05 	lds	r27, 0x0598
    48c0:	e0 91 97 05 	lds	r30, 0x0597
    48c4:	f0 91 98 05 	lds	r31, 0x0598
    48c8:	86 89       	ldd	r24, Z+22	; 0x16
    48ca:	28 2f       	mov	r18, r24
    48cc:	30 e0       	ldi	r19, 0x00	; 0
    48ce:	84 e0       	ldi	r24, 0x04	; 4
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	82 1b       	sub	r24, r18
    48d4:	93 0b       	sbc	r25, r19
    48d6:	1d 96       	adiw	r26, 0x0d	; 13
    48d8:	9c 93       	st	X, r25
    48da:	8e 93       	st	-X, r24
    48dc:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    48de:	89 81       	ldd	r24, Y+1	; 0x01
    48e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    48e2:	0f 90       	pop	r0
    48e4:	0f 90       	pop	r0
    48e6:	cf 91       	pop	r28
    48e8:	df 91       	pop	r29
    48ea:	08 95       	ret

000048ec <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    48ec:	df 93       	push	r29
    48ee:	cf 93       	push	r28
    48f0:	cd b7       	in	r28, 0x3d	; 61
    48f2:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    48f4:	80 91 97 05 	lds	r24, 0x0597
    48f8:	90 91 98 05 	lds	r25, 0x0598
    48fc:	00 97       	sbiw	r24, 0x00	; 0
    48fe:	39 f0       	breq	.+14     	; 0x490e <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4900:	e0 91 97 05 	lds	r30, 0x0597
    4904:	f0 91 98 05 	lds	r31, 0x0598
    4908:	86 a5       	ldd	r24, Z+46	; 0x2e
    490a:	8f 5f       	subi	r24, 0xFF	; 255
    490c:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    490e:	80 91 97 05 	lds	r24, 0x0597
    4912:	90 91 98 05 	lds	r25, 0x0598
	}
    4916:	cf 91       	pop	r28
    4918:	df 91       	pop	r29
    491a:	08 95       	ret

0000491c <ADC_Init>:
 *  Author: MahmoudH
 */ 

#include "ADC.h"

void	ADC_Init(void){
    491c:	df 93       	push	r29
    491e:	cf 93       	push	r28
    4920:	cd b7       	in	r28, 0x3d	; 61
    4922:	de b7       	in	r29, 0x3e	; 62
	/*
		Clock/128 - Vref = AVcc - Enable - 
	*/
	/* Clock/128 */
	setBit(ADCSRA,ADPS0);
    4924:	a6 e2       	ldi	r26, 0x26	; 38
    4926:	b0 e0       	ldi	r27, 0x00	; 0
    4928:	e6 e2       	ldi	r30, 0x26	; 38
    492a:	f0 e0       	ldi	r31, 0x00	; 0
    492c:	80 81       	ld	r24, Z
    492e:	81 60       	ori	r24, 0x01	; 1
    4930:	8c 93       	st	X, r24
	setBit(ADCSRA,ADPS1);
    4932:	a6 e2       	ldi	r26, 0x26	; 38
    4934:	b0 e0       	ldi	r27, 0x00	; 0
    4936:	e6 e2       	ldi	r30, 0x26	; 38
    4938:	f0 e0       	ldi	r31, 0x00	; 0
    493a:	80 81       	ld	r24, Z
    493c:	82 60       	ori	r24, 0x02	; 2
    493e:	8c 93       	st	X, r24
	setBit(ADCSRA,ADPS2);
    4940:	a6 e2       	ldi	r26, 0x26	; 38
    4942:	b0 e0       	ldi	r27, 0x00	; 0
    4944:	e6 e2       	ldi	r30, 0x26	; 38
    4946:	f0 e0       	ldi	r31, 0x00	; 0
    4948:	80 81       	ld	r24, Z
    494a:	84 60       	ori	r24, 0x04	; 4
    494c:	8c 93       	st	X, r24
	/* Vref = AVcc */
	setBit(ADMUX, REFS0);
    494e:	a7 e2       	ldi	r26, 0x27	; 39
    4950:	b0 e0       	ldi	r27, 0x00	; 0
    4952:	e7 e2       	ldi	r30, 0x27	; 39
    4954:	f0 e0       	ldi	r31, 0x00	; 0
    4956:	80 81       	ld	r24, Z
    4958:	80 64       	ori	r24, 0x40	; 64
    495a:	8c 93       	st	X, r24
	clearBit(ADMUX, REFS1);
    495c:	a7 e2       	ldi	r26, 0x27	; 39
    495e:	b0 e0       	ldi	r27, 0x00	; 0
    4960:	e7 e2       	ldi	r30, 0x27	; 39
    4962:	f0 e0       	ldi	r31, 0x00	; 0
    4964:	80 81       	ld	r24, Z
    4966:	8f 77       	andi	r24, 0x7F	; 127
    4968:	8c 93       	st	X, r24
	/* Enable */
	setBit(ADCSRA,ADEN);
    496a:	a6 e2       	ldi	r26, 0x26	; 38
    496c:	b0 e0       	ldi	r27, 0x00	; 0
    496e:	e6 e2       	ldi	r30, 0x26	; 38
    4970:	f0 e0       	ldi	r31, 0x00	; 0
    4972:	80 81       	ld	r24, Z
    4974:	80 68       	ori	r24, 0x80	; 128
    4976:	8c 93       	st	X, r24
}
    4978:	cf 91       	pop	r28
    497a:	df 91       	pop	r29
    497c:	08 95       	ret

0000497e <ADC_Read>:
/* 0 - > 7 */
u16		ADC_Read(ADC_CH channelNo){
    497e:	df 93       	push	r29
    4980:	cf 93       	push	r28
    4982:	0f 92       	push	r0
    4984:	cd b7       	in	r28, 0x3d	; 61
    4986:	de b7       	in	r29, 0x3e	; 62
    4988:	89 83       	std	Y+1, r24	; 0x01
	/* Select Channel */
	clearBits(ADMUX, 0x1F);
    498a:	a7 e2       	ldi	r26, 0x27	; 39
    498c:	b0 e0       	ldi	r27, 0x00	; 0
    498e:	e7 e2       	ldi	r30, 0x27	; 39
    4990:	f0 e0       	ldi	r31, 0x00	; 0
    4992:	80 81       	ld	r24, Z
    4994:	80 7e       	andi	r24, 0xE0	; 224
    4996:	8c 93       	st	X, r24
	setBits(ADMUX, channelNo);
    4998:	a7 e2       	ldi	r26, 0x27	; 39
    499a:	b0 e0       	ldi	r27, 0x00	; 0
    499c:	e7 e2       	ldi	r30, 0x27	; 39
    499e:	f0 e0       	ldi	r31, 0x00	; 0
    49a0:	90 81       	ld	r25, Z
    49a2:	89 81       	ldd	r24, Y+1	; 0x01
    49a4:	89 2b       	or	r24, r25
    49a6:	8c 93       	st	X, r24
	/* Start Conversion */
	setBit(ADCSRA,ADSC);
    49a8:	a6 e2       	ldi	r26, 0x26	; 38
    49aa:	b0 e0       	ldi	r27, 0x00	; 0
    49ac:	e6 e2       	ldi	r30, 0x26	; 38
    49ae:	f0 e0       	ldi	r31, 0x00	; 0
    49b0:	80 81       	ld	r24, Z
    49b2:	80 64       	ori	r24, 0x40	; 64
    49b4:	8c 93       	st	X, r24
	/* Wait for conversion to complete */
	//while(readBit(ADCSRA,ADSC));
	while(readBit(ADCSRA,ADIF));
    49b6:	e6 e2       	ldi	r30, 0x26	; 38
    49b8:	f0 e0       	ldi	r31, 0x00	; 0
    49ba:	80 81       	ld	r24, Z
    49bc:	82 95       	swap	r24
    49be:	8f 70       	andi	r24, 0x0F	; 15
    49c0:	88 2f       	mov	r24, r24
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	81 70       	andi	r24, 0x01	; 1
    49c6:	90 70       	andi	r25, 0x00	; 0
    49c8:	88 23       	and	r24, r24
    49ca:	a9 f7       	brne	.-22     	; 0x49b6 <ADC_Read+0x38>
	setBit(ADCSRA,ADIF);
    49cc:	a6 e2       	ldi	r26, 0x26	; 38
    49ce:	b0 e0       	ldi	r27, 0x00	; 0
    49d0:	e6 e2       	ldi	r30, 0x26	; 38
    49d2:	f0 e0       	ldi	r31, 0x00	; 0
    49d4:	80 81       	ld	r24, Z
    49d6:	80 61       	ori	r24, 0x10	; 16
    49d8:	8c 93       	st	X, r24
	/* return data */
	return ADC;
    49da:	e4 e2       	ldi	r30, 0x24	; 36
    49dc:	f0 e0       	ldi	r31, 0x00	; 0
    49de:	80 81       	ld	r24, Z
    49e0:	91 81       	ldd	r25, Z+1	; 0x01
}
    49e2:	0f 90       	pop	r0
    49e4:	cf 91       	pop	r28
    49e6:	df 91       	pop	r29
    49e8:	08 95       	ret

000049ea <Key_Init>:
		{6,5,4},
		{3,2,1}
};

/* Routines */
void	Key_Init(void){
    49ea:	df 93       	push	r29
    49ec:	cf 93       	push	r28
    49ee:	cd b7       	in	r28, 0x3d	; 61
    49f0:	de b7       	in	r29, 0x3e	; 62
	/* Rows */
	setBits(KEY_ROW_DDR, KEY_ROWS_MSK);		/* Out */
    49f2:	a4 e3       	ldi	r26, 0x34	; 52
    49f4:	b0 e0       	ldi	r27, 0x00	; 0
    49f6:	e4 e3       	ldi	r30, 0x34	; 52
    49f8:	f0 e0       	ldi	r31, 0x00	; 0
    49fa:	80 81       	ld	r24, Z
    49fc:	8c 61       	ori	r24, 0x1C	; 28
    49fe:	8c 93       	st	X, r24
	setBits(KEY_ROW_PORT, KEY_ROWS_MSK);	/* High Default */
    4a00:	a5 e3       	ldi	r26, 0x35	; 53
    4a02:	b0 e0       	ldi	r27, 0x00	; 0
    4a04:	e5 e3       	ldi	r30, 0x35	; 53
    4a06:	f0 e0       	ldi	r31, 0x00	; 0
    4a08:	80 81       	ld	r24, Z
    4a0a:	8c 61       	ori	r24, 0x1C	; 28
    4a0c:	8c 93       	st	X, r24
	/* Cols */
	clearBits(KEY_COL_DDR, KEY_COLS_MSK);	/* In */
    4a0e:	a1 e3       	ldi	r26, 0x31	; 49
    4a10:	b0 e0       	ldi	r27, 0x00	; 0
    4a12:	e1 e3       	ldi	r30, 0x31	; 49
    4a14:	f0 e0       	ldi	r31, 0x00	; 0
    4a16:	80 81       	ld	r24, Z
    4a18:	8f 71       	andi	r24, 0x1F	; 31
    4a1a:	8c 93       	st	X, r24
	setBits(KEY_COL_PORT, KEY_COLS_MSK);	/* Pullup */
    4a1c:	a2 e3       	ldi	r26, 0x32	; 50
    4a1e:	b0 e0       	ldi	r27, 0x00	; 0
    4a20:	e2 e3       	ldi	r30, 0x32	; 50
    4a22:	f0 e0       	ldi	r31, 0x00	; 0
    4a24:	80 81       	ld	r24, Z
    4a26:	80 6e       	ori	r24, 0xE0	; 224
    4a28:	8c 93       	st	X, r24
}
    4a2a:	cf 91       	pop	r28
    4a2c:	df 91       	pop	r29
    4a2e:	08 95       	ret

00004a30 <Key_GetKey>:
u8		Key_GetKey(void){
    4a30:	df 93       	push	r29
    4a32:	cf 93       	push	r28
    4a34:	00 d0       	rcall	.+0      	; 0x4a36 <Key_GetKey+0x6>
    4a36:	0f 92       	push	r0
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
	end
	de-activate this row r
	end
	return 0 for no pressed key
	 */
	u8 row = 0;
    4a3c:	1a 82       	std	Y+2, r1	; 0x02
	u8 col = 0;
    4a3e:	19 82       	std	Y+1, r1	; 0x01
	setBits(KEY_ROW_PORT, KEY_ROWS_MSK);	/* High Default */
    4a40:	a5 e3       	ldi	r26, 0x35	; 53
    4a42:	b0 e0       	ldi	r27, 0x00	; 0
    4a44:	e5 e3       	ldi	r30, 0x35	; 53
    4a46:	f0 e0       	ldi	r31, 0x00	; 0
    4a48:	80 81       	ld	r24, Z
    4a4a:	8c 61       	ori	r24, 0x1C	; 28
    4a4c:	8c 93       	st	X, r24
	for (row = 0; row < KEY_ROWS_NUM; row++)
    4a4e:	1a 82       	std	Y+2, r1	; 0x02
    4a50:	79 c0       	rjmp	.+242    	; 0x4b44 <Key_GetKey+0x114>
	{
		clearBit(KEY_ROW_PORT,row+2);
    4a52:	a5 e3       	ldi	r26, 0x35	; 53
    4a54:	b0 e0       	ldi	r27, 0x00	; 0
    4a56:	e5 e3       	ldi	r30, 0x35	; 53
    4a58:	f0 e0       	ldi	r31, 0x00	; 0
    4a5a:	80 81       	ld	r24, Z
    4a5c:	48 2f       	mov	r20, r24
    4a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a60:	88 2f       	mov	r24, r24
    4a62:	90 e0       	ldi	r25, 0x00	; 0
    4a64:	9c 01       	movw	r18, r24
    4a66:	2e 5f       	subi	r18, 0xFE	; 254
    4a68:	3f 4f       	sbci	r19, 0xFF	; 255
    4a6a:	81 e0       	ldi	r24, 0x01	; 1
    4a6c:	90 e0       	ldi	r25, 0x00	; 0
    4a6e:	02 2e       	mov	r0, r18
    4a70:	02 c0       	rjmp	.+4      	; 0x4a76 <Key_GetKey+0x46>
    4a72:	88 0f       	add	r24, r24
    4a74:	99 1f       	adc	r25, r25
    4a76:	0a 94       	dec	r0
    4a78:	e2 f7       	brpl	.-8      	; 0x4a72 <Key_GetKey+0x42>
    4a7a:	80 95       	com	r24
    4a7c:	84 23       	and	r24, r20
    4a7e:	8c 93       	st	X, r24
		for (col = 0; col < (KEY_COLS_NUM); col++)
    4a80:	19 82       	std	Y+1, r1	; 0x01
    4a82:	43 c0       	rjmp	.+134    	; 0x4b0a <Key_GetKey+0xda>
		{
			if(!readBit(KEY_COL_PINR, col + 5 )){
    4a84:	e0 e3       	ldi	r30, 0x30	; 48
    4a86:	f0 e0       	ldi	r31, 0x00	; 0
    4a88:	80 81       	ld	r24, Z
    4a8a:	28 2f       	mov	r18, r24
    4a8c:	30 e0       	ldi	r19, 0x00	; 0
    4a8e:	89 81       	ldd	r24, Y+1	; 0x01
    4a90:	88 2f       	mov	r24, r24
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	05 96       	adiw	r24, 0x05	; 5
    4a96:	a9 01       	movw	r20, r18
    4a98:	02 c0       	rjmp	.+4      	; 0x4a9e <Key_GetKey+0x6e>
    4a9a:	55 95       	asr	r21
    4a9c:	47 95       	ror	r20
    4a9e:	8a 95       	dec	r24
    4aa0:	e2 f7       	brpl	.-8      	; 0x4a9a <Key_GetKey+0x6a>
    4aa2:	ca 01       	movw	r24, r20
    4aa4:	81 70       	andi	r24, 0x01	; 1
    4aa6:	90 70       	andi	r25, 0x00	; 0
    4aa8:	00 97       	sbiw	r24, 0x00	; 0
    4aaa:	61 f5       	brne	.+88     	; 0x4b04 <Key_GetKey+0xd4>
    4aac:	04 c0       	rjmp	.+8      	; 0x4ab6 <Key_GetKey+0x86>
				while(!readBit(KEY_COL_PINR, col + 5))
				{
					vTaskDelay(50);
    4aae:	82 e3       	ldi	r24, 0x32	; 50
    4ab0:	90 e0       	ldi	r25, 0x00	; 0
    4ab2:	0e 94 0f 1c 	call	0x381e	; 0x381e <vTaskDelay>
	{
		clearBit(KEY_ROW_PORT,row+2);
		for (col = 0; col < (KEY_COLS_NUM); col++)
		{
			if(!readBit(KEY_COL_PINR, col + 5 )){
				while(!readBit(KEY_COL_PINR, col + 5))
    4ab6:	e0 e3       	ldi	r30, 0x30	; 48
    4ab8:	f0 e0       	ldi	r31, 0x00	; 0
    4aba:	80 81       	ld	r24, Z
    4abc:	28 2f       	mov	r18, r24
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	89 81       	ldd	r24, Y+1	; 0x01
    4ac2:	88 2f       	mov	r24, r24
    4ac4:	90 e0       	ldi	r25, 0x00	; 0
    4ac6:	05 96       	adiw	r24, 0x05	; 5
    4ac8:	a9 01       	movw	r20, r18
    4aca:	02 c0       	rjmp	.+4      	; 0x4ad0 <Key_GetKey+0xa0>
    4acc:	55 95       	asr	r21
    4ace:	47 95       	ror	r20
    4ad0:	8a 95       	dec	r24
    4ad2:	e2 f7       	brpl	.-8      	; 0x4acc <Key_GetKey+0x9c>
    4ad4:	ca 01       	movw	r24, r20
    4ad6:	81 70       	andi	r24, 0x01	; 1
    4ad8:	90 70       	andi	r25, 0x00	; 0
    4ada:	00 97       	sbiw	r24, 0x00	; 0
    4adc:	41 f3       	breq	.-48     	; 0x4aae <Key_GetKey+0x7e>
				{
					vTaskDelay(50);
				}
				return keys[row][col];
    4ade:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae0:	28 2f       	mov	r18, r24
    4ae2:	30 e0       	ldi	r19, 0x00	; 0
    4ae4:	89 81       	ldd	r24, Y+1	; 0x01
    4ae6:	48 2f       	mov	r20, r24
    4ae8:	50 e0       	ldi	r21, 0x00	; 0
    4aea:	c9 01       	movw	r24, r18
    4aec:	88 0f       	add	r24, r24
    4aee:	99 1f       	adc	r25, r25
    4af0:	82 0f       	add	r24, r18
    4af2:	93 1f       	adc	r25, r19
    4af4:	84 0f       	add	r24, r20
    4af6:	95 1f       	adc	r25, r21
    4af8:	fc 01       	movw	r30, r24
    4afa:	e4 53       	subi	r30, 0x34	; 52
    4afc:	ff 4f       	sbci	r31, 0xFF	; 255
    4afe:	50 81       	ld	r21, Z
    4b00:	5b 83       	std	Y+3, r21	; 0x03
    4b02:	25 c0       	rjmp	.+74     	; 0x4b4e <Key_GetKey+0x11e>
	u8 col = 0;
	setBits(KEY_ROW_PORT, KEY_ROWS_MSK);	/* High Default */
	for (row = 0; row < KEY_ROWS_NUM; row++)
	{
		clearBit(KEY_ROW_PORT,row+2);
		for (col = 0; col < (KEY_COLS_NUM); col++)
    4b04:	89 81       	ldd	r24, Y+1	; 0x01
    4b06:	8f 5f       	subi	r24, 0xFF	; 255
    4b08:	89 83       	std	Y+1, r24	; 0x01
    4b0a:	89 81       	ldd	r24, Y+1	; 0x01
    4b0c:	83 30       	cpi	r24, 0x03	; 3
    4b0e:	08 f4       	brcc	.+2      	; 0x4b12 <Key_GetKey+0xe2>
    4b10:	b9 cf       	rjmp	.-142    	; 0x4a84 <Key_GetKey+0x54>
					vTaskDelay(50);
				}
				return keys[row][col];
			}
		}
		setBit(KEY_ROW_PORT,row+2);
    4b12:	a5 e3       	ldi	r26, 0x35	; 53
    4b14:	b0 e0       	ldi	r27, 0x00	; 0
    4b16:	e5 e3       	ldi	r30, 0x35	; 53
    4b18:	f0 e0       	ldi	r31, 0x00	; 0
    4b1a:	80 81       	ld	r24, Z
    4b1c:	48 2f       	mov	r20, r24
    4b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b20:	88 2f       	mov	r24, r24
    4b22:	90 e0       	ldi	r25, 0x00	; 0
    4b24:	9c 01       	movw	r18, r24
    4b26:	2e 5f       	subi	r18, 0xFE	; 254
    4b28:	3f 4f       	sbci	r19, 0xFF	; 255
    4b2a:	81 e0       	ldi	r24, 0x01	; 1
    4b2c:	90 e0       	ldi	r25, 0x00	; 0
    4b2e:	02 2e       	mov	r0, r18
    4b30:	02 c0       	rjmp	.+4      	; 0x4b36 <Key_GetKey+0x106>
    4b32:	88 0f       	add	r24, r24
    4b34:	99 1f       	adc	r25, r25
    4b36:	0a 94       	dec	r0
    4b38:	e2 f7       	brpl	.-8      	; 0x4b32 <Key_GetKey+0x102>
    4b3a:	84 2b       	or	r24, r20
    4b3c:	8c 93       	st	X, r24
	return 0 for no pressed key
	 */
	u8 row = 0;
	u8 col = 0;
	setBits(KEY_ROW_PORT, KEY_ROWS_MSK);	/* High Default */
	for (row = 0; row < KEY_ROWS_NUM; row++)
    4b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b40:	8f 5f       	subi	r24, 0xFF	; 255
    4b42:	8a 83       	std	Y+2, r24	; 0x02
    4b44:	8a 81       	ldd	r24, Y+2	; 0x02
    4b46:	83 30       	cpi	r24, 0x03	; 3
    4b48:	08 f4       	brcc	.+2      	; 0x4b4c <Key_GetKey+0x11c>
    4b4a:	83 cf       	rjmp	.-250    	; 0x4a52 <Key_GetKey+0x22>
				return keys[row][col];
			}
		}
		setBit(KEY_ROW_PORT,row+2);
	}
	return 0;
    4b4c:	1b 82       	std	Y+3, r1	; 0x03
    4b4e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4b50:	0f 90       	pop	r0
    4b52:	0f 90       	pop	r0
    4b54:	0f 90       	pop	r0
    4b56:	cf 91       	pop	r28
    4b58:	df 91       	pop	r29
    4b5a:	08 95       	ret

00004b5c <Key_Scan>:

u16		Key_Scan(void){
    4b5c:	df 93       	push	r29
    4b5e:	cf 93       	push	r28
    4b60:	00 d0       	rcall	.+0      	; 0x4b62 <Key_Scan+0x6>
    4b62:	00 d0       	rcall	.+0      	; 0x4b64 <Key_Scan+0x8>
    4b64:	cd b7       	in	r28, 0x3d	; 61
    4b66:	de b7       	in	r29, 0x3e	; 62
	u16 keys = 0x00;
    4b68:	1c 82       	std	Y+4, r1	; 0x04
    4b6a:	1b 82       	std	Y+3, r1	; 0x03
	u8 row = 0;
    4b6c:	1a 82       	std	Y+2, r1	; 0x02
	u8 col = 0;
    4b6e:	19 82       	std	Y+1, r1	; 0x01
	for (row = 0; row < KEY_ROWS_NUM; row++)
    4b70:	1a 82       	std	Y+2, r1	; 0x02
    4b72:	60 c0       	rjmp	.+192    	; 0x4c34 <Key_Scan+0xd8>
	{
		clearBit(KEY_ROW_PORT,row);
    4b74:	a5 e3       	ldi	r26, 0x35	; 53
    4b76:	b0 e0       	ldi	r27, 0x00	; 0
    4b78:	e5 e3       	ldi	r30, 0x35	; 53
    4b7a:	f0 e0       	ldi	r31, 0x00	; 0
    4b7c:	80 81       	ld	r24, Z
    4b7e:	48 2f       	mov	r20, r24
    4b80:	8a 81       	ldd	r24, Y+2	; 0x02
    4b82:	28 2f       	mov	r18, r24
    4b84:	30 e0       	ldi	r19, 0x00	; 0
    4b86:	81 e0       	ldi	r24, 0x01	; 1
    4b88:	90 e0       	ldi	r25, 0x00	; 0
    4b8a:	02 2e       	mov	r0, r18
    4b8c:	02 c0       	rjmp	.+4      	; 0x4b92 <Key_Scan+0x36>
    4b8e:	88 0f       	add	r24, r24
    4b90:	99 1f       	adc	r25, r25
    4b92:	0a 94       	dec	r0
    4b94:	e2 f7       	brpl	.-8      	; 0x4b8e <Key_Scan+0x32>
    4b96:	80 95       	com	r24
    4b98:	84 23       	and	r24, r20
    4b9a:	8c 93       	st	X, r24
		for (col = 0; col < KEY_COLS_NUM; col++)
    4b9c:	19 82       	std	Y+1, r1	; 0x01
    4b9e:	31 c0       	rjmp	.+98     	; 0x4c02 <Key_Scan+0xa6>
		{
			if(!readBit(KEY_COL_PINR, col + KEY_ROWS_NUM )){
    4ba0:	e0 e3       	ldi	r30, 0x30	; 48
    4ba2:	f0 e0       	ldi	r31, 0x00	; 0
    4ba4:	80 81       	ld	r24, Z
    4ba6:	28 2f       	mov	r18, r24
    4ba8:	30 e0       	ldi	r19, 0x00	; 0
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	88 2f       	mov	r24, r24
    4bae:	90 e0       	ldi	r25, 0x00	; 0
    4bb0:	03 96       	adiw	r24, 0x03	; 3
    4bb2:	a9 01       	movw	r20, r18
    4bb4:	02 c0       	rjmp	.+4      	; 0x4bba <Key_Scan+0x5e>
    4bb6:	55 95       	asr	r21
    4bb8:	47 95       	ror	r20
    4bba:	8a 95       	dec	r24
    4bbc:	e2 f7       	brpl	.-8      	; 0x4bb6 <Key_Scan+0x5a>
    4bbe:	ca 01       	movw	r24, r20
    4bc0:	81 70       	andi	r24, 0x01	; 1
    4bc2:	90 70       	andi	r25, 0x00	; 0
    4bc4:	00 97       	sbiw	r24, 0x00	; 0
    4bc6:	d1 f4       	brne	.+52     	; 0x4bfc <Key_Scan+0xa0>
				//while(!readBit(KEY_PINR, col + KEY_ROWS_NUM )); // Blocking
				//return keys[row][col];
				keys |= (1<<(col + row*4));
    4bc8:	89 81       	ldd	r24, Y+1	; 0x01
    4bca:	28 2f       	mov	r18, r24
    4bcc:	30 e0       	ldi	r19, 0x00	; 0
    4bce:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd0:	88 2f       	mov	r24, r24
    4bd2:	90 e0       	ldi	r25, 0x00	; 0
    4bd4:	88 0f       	add	r24, r24
    4bd6:	99 1f       	adc	r25, r25
    4bd8:	88 0f       	add	r24, r24
    4bda:	99 1f       	adc	r25, r25
    4bdc:	28 0f       	add	r18, r24
    4bde:	39 1f       	adc	r19, r25
    4be0:	81 e0       	ldi	r24, 0x01	; 1
    4be2:	90 e0       	ldi	r25, 0x00	; 0
    4be4:	02 c0       	rjmp	.+4      	; 0x4bea <Key_Scan+0x8e>
    4be6:	88 0f       	add	r24, r24
    4be8:	99 1f       	adc	r25, r25
    4bea:	2a 95       	dec	r18
    4bec:	e2 f7       	brpl	.-8      	; 0x4be6 <Key_Scan+0x8a>
    4bee:	9c 01       	movw	r18, r24
    4bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bf4:	82 2b       	or	r24, r18
    4bf6:	93 2b       	or	r25, r19
    4bf8:	9c 83       	std	Y+4, r25	; 0x04
    4bfa:	8b 83       	std	Y+3, r24	; 0x03
	u8 row = 0;
	u8 col = 0;
	for (row = 0; row < KEY_ROWS_NUM; row++)
	{
		clearBit(KEY_ROW_PORT,row);
		for (col = 0; col < KEY_COLS_NUM; col++)
    4bfc:	89 81       	ldd	r24, Y+1	; 0x01
    4bfe:	8f 5f       	subi	r24, 0xFF	; 255
    4c00:	89 83       	std	Y+1, r24	; 0x01
    4c02:	89 81       	ldd	r24, Y+1	; 0x01
    4c04:	83 30       	cpi	r24, 0x03	; 3
    4c06:	60 f2       	brcs	.-104    	; 0x4ba0 <Key_Scan+0x44>
				//while(!readBit(KEY_PINR, col + KEY_ROWS_NUM )); // Blocking
				//return keys[row][col];
				keys |= (1<<(col + row*4));
			}
		}
		setBit(KEY_ROW_PORT,row);
    4c08:	a5 e3       	ldi	r26, 0x35	; 53
    4c0a:	b0 e0       	ldi	r27, 0x00	; 0
    4c0c:	e5 e3       	ldi	r30, 0x35	; 53
    4c0e:	f0 e0       	ldi	r31, 0x00	; 0
    4c10:	80 81       	ld	r24, Z
    4c12:	48 2f       	mov	r20, r24
    4c14:	8a 81       	ldd	r24, Y+2	; 0x02
    4c16:	28 2f       	mov	r18, r24
    4c18:	30 e0       	ldi	r19, 0x00	; 0
    4c1a:	81 e0       	ldi	r24, 0x01	; 1
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	02 2e       	mov	r0, r18
    4c20:	02 c0       	rjmp	.+4      	; 0x4c26 <Key_Scan+0xca>
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	0a 94       	dec	r0
    4c28:	e2 f7       	brpl	.-8      	; 0x4c22 <Key_Scan+0xc6>
    4c2a:	84 2b       	or	r24, r20
    4c2c:	8c 93       	st	X, r24

u16		Key_Scan(void){
	u16 keys = 0x00;
	u8 row = 0;
	u8 col = 0;
	for (row = 0; row < KEY_ROWS_NUM; row++)
    4c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c30:	8f 5f       	subi	r24, 0xFF	; 255
    4c32:	8a 83       	std	Y+2, r24	; 0x02
    4c34:	8a 81       	ldd	r24, Y+2	; 0x02
    4c36:	83 30       	cpi	r24, 0x03	; 3
    4c38:	08 f4       	brcc	.+2      	; 0x4c3c <Key_Scan+0xe0>
    4c3a:	9c cf       	rjmp	.-200    	; 0x4b74 <Key_Scan+0x18>
				keys |= (1<<(col + row*4));
			}
		}
		setBit(KEY_ROW_PORT,row);
	}
	return keys;
    4c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c3e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4c40:	0f 90       	pop	r0
    4c42:	0f 90       	pop	r0
    4c44:	0f 90       	pop	r0
    4c46:	0f 90       	pop	r0
    4c48:	cf 91       	pop	r28
    4c4a:	df 91       	pop	r29
    4c4c:	08 95       	ret

00004c4e <LCD_Latch>:
static void LCD_SendCMD(u8 cmd);
static void LCD_SendData(u8 data);
static void LCD_GotoXY(u8 row, u8 col);
static void LCD_Latch(void);

static void LCD_Latch(void){
    4c4e:	df 93       	push	r29
    4c50:	cf 93       	push	r28
    4c52:	cd b7       	in	r28, 0x3d	; 61
    4c54:	de b7       	in	r29, 0x3e	; 62
    4c56:	68 97       	sbiw	r28, 0x18	; 24
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	de bf       	out	0x3e, r29	; 62
    4c5e:	0f be       	out	0x3f, r0	; 63
    4c60:	cd bf       	out	0x3d, r28	; 61
	/* set and clear EN */
	setBit(LCD_CTRL_PORT,LCD_CTRL_EN);
    4c62:	ab e3       	ldi	r26, 0x3B	; 59
    4c64:	b0 e0       	ldi	r27, 0x00	; 0
    4c66:	eb e3       	ldi	r30, 0x3B	; 59
    4c68:	f0 e0       	ldi	r31, 0x00	; 0
    4c6a:	80 81       	ld	r24, Z
    4c6c:	84 60       	ori	r24, 0x04	; 4
    4c6e:	8c 93       	st	X, r24
    4c70:	80 e0       	ldi	r24, 0x00	; 0
    4c72:	90 e0       	ldi	r25, 0x00	; 0
    4c74:	a0 e8       	ldi	r26, 0x80	; 128
    4c76:	bf e3       	ldi	r27, 0x3F	; 63
    4c78:	8d 8b       	std	Y+21, r24	; 0x15
    4c7a:	9e 8b       	std	Y+22, r25	; 0x16
    4c7c:	af 8b       	std	Y+23, r26	; 0x17
    4c7e:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4c80:	6d 89       	ldd	r22, Y+21	; 0x15
    4c82:	7e 89       	ldd	r23, Y+22	; 0x16
    4c84:	8f 89       	ldd	r24, Y+23	; 0x17
    4c86:	98 8d       	ldd	r25, Y+24	; 0x18
    4c88:	2b ea       	ldi	r18, 0xAB	; 171
    4c8a:	3a ea       	ldi	r19, 0xAA	; 170
    4c8c:	4a ea       	ldi	r20, 0xAA	; 170
    4c8e:	50 e4       	ldi	r21, 0x40	; 64
    4c90:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c94:	dc 01       	movw	r26, r24
    4c96:	cb 01       	movw	r24, r22
    4c98:	89 8b       	std	Y+17, r24	; 0x11
    4c9a:	9a 8b       	std	Y+18, r25	; 0x12
    4c9c:	ab 8b       	std	Y+19, r26	; 0x13
    4c9e:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    4ca0:	69 89       	ldd	r22, Y+17	; 0x11
    4ca2:	7a 89       	ldd	r23, Y+18	; 0x12
    4ca4:	8b 89       	ldd	r24, Y+19	; 0x13
    4ca6:	9c 89       	ldd	r25, Y+20	; 0x14
    4ca8:	20 e0       	ldi	r18, 0x00	; 0
    4caa:	30 e0       	ldi	r19, 0x00	; 0
    4cac:	40 e8       	ldi	r20, 0x80	; 128
    4cae:	5f e3       	ldi	r21, 0x3F	; 63
    4cb0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4cb4:	88 23       	and	r24, r24
    4cb6:	1c f4       	brge	.+6      	; 0x4cbe <LCD_Latch+0x70>
		__ticks = 1;
    4cb8:	81 e0       	ldi	r24, 0x01	; 1
    4cba:	88 8b       	std	Y+16, r24	; 0x10
    4cbc:	91 c0       	rjmp	.+290    	; 0x4de0 <LCD_Latch+0x192>
	else if (__tmp > 255)
    4cbe:	69 89       	ldd	r22, Y+17	; 0x11
    4cc0:	7a 89       	ldd	r23, Y+18	; 0x12
    4cc2:	8b 89       	ldd	r24, Y+19	; 0x13
    4cc4:	9c 89       	ldd	r25, Y+20	; 0x14
    4cc6:	20 e0       	ldi	r18, 0x00	; 0
    4cc8:	30 e0       	ldi	r19, 0x00	; 0
    4cca:	4f e7       	ldi	r20, 0x7F	; 127
    4ccc:	53 e4       	ldi	r21, 0x43	; 67
    4cce:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4cd2:	18 16       	cp	r1, r24
    4cd4:	0c f0       	brlt	.+2      	; 0x4cd8 <LCD_Latch+0x8a>
    4cd6:	7b c0       	rjmp	.+246    	; 0x4dce <LCD_Latch+0x180>
	{
		_delay_ms(__us / 1000.0);
    4cd8:	6d 89       	ldd	r22, Y+21	; 0x15
    4cda:	7e 89       	ldd	r23, Y+22	; 0x16
    4cdc:	8f 89       	ldd	r24, Y+23	; 0x17
    4cde:	98 8d       	ldd	r25, Y+24	; 0x18
    4ce0:	20 e0       	ldi	r18, 0x00	; 0
    4ce2:	30 e0       	ldi	r19, 0x00	; 0
    4ce4:	4a e7       	ldi	r20, 0x7A	; 122
    4ce6:	54 e4       	ldi	r21, 0x44	; 68
    4ce8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4cec:	dc 01       	movw	r26, r24
    4cee:	cb 01       	movw	r24, r22
    4cf0:	8c 87       	std	Y+12, r24	; 0x0c
    4cf2:	9d 87       	std	Y+13, r25	; 0x0d
    4cf4:	ae 87       	std	Y+14, r26	; 0x0e
    4cf6:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4cf8:	6c 85       	ldd	r22, Y+12	; 0x0c
    4cfa:	7d 85       	ldd	r23, Y+13	; 0x0d
    4cfc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4cfe:	9f 85       	ldd	r25, Y+15	; 0x0f
    4d00:	20 e0       	ldi	r18, 0x00	; 0
    4d02:	30 e0       	ldi	r19, 0x00	; 0
    4d04:	4a e7       	ldi	r20, 0x7A	; 122
    4d06:	55 e4       	ldi	r21, 0x45	; 69
    4d08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d0c:	dc 01       	movw	r26, r24
    4d0e:	cb 01       	movw	r24, r22
    4d10:	88 87       	std	Y+8, r24	; 0x08
    4d12:	99 87       	std	Y+9, r25	; 0x09
    4d14:	aa 87       	std	Y+10, r26	; 0x0a
    4d16:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4d18:	68 85       	ldd	r22, Y+8	; 0x08
    4d1a:	79 85       	ldd	r23, Y+9	; 0x09
    4d1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d20:	20 e0       	ldi	r18, 0x00	; 0
    4d22:	30 e0       	ldi	r19, 0x00	; 0
    4d24:	40 e8       	ldi	r20, 0x80	; 128
    4d26:	5f e3       	ldi	r21, 0x3F	; 63
    4d28:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4d2c:	88 23       	and	r24, r24
    4d2e:	2c f4       	brge	.+10     	; 0x4d3a <LCD_Latch+0xec>
		__ticks = 1;
    4d30:	81 e0       	ldi	r24, 0x01	; 1
    4d32:	90 e0       	ldi	r25, 0x00	; 0
    4d34:	9f 83       	std	Y+7, r25	; 0x07
    4d36:	8e 83       	std	Y+6, r24	; 0x06
    4d38:	3f c0       	rjmp	.+126    	; 0x4db8 <LCD_Latch+0x16a>
	else if (__tmp > 65535)
    4d3a:	68 85       	ldd	r22, Y+8	; 0x08
    4d3c:	79 85       	ldd	r23, Y+9	; 0x09
    4d3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d40:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d42:	20 e0       	ldi	r18, 0x00	; 0
    4d44:	3f ef       	ldi	r19, 0xFF	; 255
    4d46:	4f e7       	ldi	r20, 0x7F	; 127
    4d48:	57 e4       	ldi	r21, 0x47	; 71
    4d4a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4d4e:	18 16       	cp	r1, r24
    4d50:	4c f5       	brge	.+82     	; 0x4da4 <LCD_Latch+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d52:	6c 85       	ldd	r22, Y+12	; 0x0c
    4d54:	7d 85       	ldd	r23, Y+13	; 0x0d
    4d56:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d58:	9f 85       	ldd	r25, Y+15	; 0x0f
    4d5a:	20 e0       	ldi	r18, 0x00	; 0
    4d5c:	30 e0       	ldi	r19, 0x00	; 0
    4d5e:	40 e2       	ldi	r20, 0x20	; 32
    4d60:	51 e4       	ldi	r21, 0x41	; 65
    4d62:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d66:	dc 01       	movw	r26, r24
    4d68:	cb 01       	movw	r24, r22
    4d6a:	bc 01       	movw	r22, r24
    4d6c:	cd 01       	movw	r24, r26
    4d6e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d72:	dc 01       	movw	r26, r24
    4d74:	cb 01       	movw	r24, r22
    4d76:	9f 83       	std	Y+7, r25	; 0x07
    4d78:	8e 83       	std	Y+6, r24	; 0x06
    4d7a:	0f c0       	rjmp	.+30     	; 0x4d9a <LCD_Latch+0x14c>
    4d7c:	80 e9       	ldi	r24, 0x90	; 144
    4d7e:	91 e0       	ldi	r25, 0x01	; 1
    4d80:	9d 83       	std	Y+5, r25	; 0x05
    4d82:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4d84:	8c 81       	ldd	r24, Y+4	; 0x04
    4d86:	9d 81       	ldd	r25, Y+5	; 0x05
    4d88:	01 97       	sbiw	r24, 0x01	; 1
    4d8a:	f1 f7       	brne	.-4      	; 0x4d88 <LCD_Latch+0x13a>
    4d8c:	9d 83       	std	Y+5, r25	; 0x05
    4d8e:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d90:	8e 81       	ldd	r24, Y+6	; 0x06
    4d92:	9f 81       	ldd	r25, Y+7	; 0x07
    4d94:	01 97       	sbiw	r24, 0x01	; 1
    4d96:	9f 83       	std	Y+7, r25	; 0x07
    4d98:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d9a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d9c:	9f 81       	ldd	r25, Y+7	; 0x07
    4d9e:	00 97       	sbiw	r24, 0x00	; 0
    4da0:	69 f7       	brne	.-38     	; 0x4d7c <LCD_Latch+0x12e>
    4da2:	24 c0       	rjmp	.+72     	; 0x4dec <LCD_Latch+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4da4:	68 85       	ldd	r22, Y+8	; 0x08
    4da6:	79 85       	ldd	r23, Y+9	; 0x09
    4da8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4daa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4db0:	dc 01       	movw	r26, r24
    4db2:	cb 01       	movw	r24, r22
    4db4:	9f 83       	std	Y+7, r25	; 0x07
    4db6:	8e 83       	std	Y+6, r24	; 0x06
    4db8:	8e 81       	ldd	r24, Y+6	; 0x06
    4dba:	9f 81       	ldd	r25, Y+7	; 0x07
    4dbc:	9b 83       	std	Y+3, r25	; 0x03
    4dbe:	8a 83       	std	Y+2, r24	; 0x02
    4dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc2:	9b 81       	ldd	r25, Y+3	; 0x03
    4dc4:	01 97       	sbiw	r24, 0x01	; 1
    4dc6:	f1 f7       	brne	.-4      	; 0x4dc4 <LCD_Latch+0x176>
    4dc8:	9b 83       	std	Y+3, r25	; 0x03
    4dca:	8a 83       	std	Y+2, r24	; 0x02
    4dcc:	0f c0       	rjmp	.+30     	; 0x4dec <LCD_Latch+0x19e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4dce:	69 89       	ldd	r22, Y+17	; 0x11
    4dd0:	7a 89       	ldd	r23, Y+18	; 0x12
    4dd2:	8b 89       	ldd	r24, Y+19	; 0x13
    4dd4:	9c 89       	ldd	r25, Y+20	; 0x14
    4dd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4dda:	dc 01       	movw	r26, r24
    4ddc:	cb 01       	movw	r24, r22
    4dde:	88 8b       	std	Y+16, r24	; 0x10
    4de0:	88 89       	ldd	r24, Y+16	; 0x10
    4de2:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4de4:	89 81       	ldd	r24, Y+1	; 0x01
    4de6:	8a 95       	dec	r24
    4de8:	f1 f7       	brne	.-4      	; 0x4de6 <LCD_Latch+0x198>
    4dea:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	clearBit(LCD_CTRL_PORT,LCD_CTRL_EN);
    4dec:	ab e3       	ldi	r26, 0x3B	; 59
    4dee:	b0 e0       	ldi	r27, 0x00	; 0
    4df0:	eb e3       	ldi	r30, 0x3B	; 59
    4df2:	f0 e0       	ldi	r31, 0x00	; 0
    4df4:	80 81       	ld	r24, Z
    4df6:	8b 7f       	andi	r24, 0xFB	; 251
    4df8:	8c 93       	st	X, r24
}
    4dfa:	68 96       	adiw	r28, 0x18	; 24
    4dfc:	0f b6       	in	r0, 0x3f	; 63
    4dfe:	f8 94       	cli
    4e00:	de bf       	out	0x3e, r29	; 62
    4e02:	0f be       	out	0x3f, r0	; 63
    4e04:	cd bf       	out	0x3d, r28	; 61
    4e06:	cf 91       	pop	r28
    4e08:	df 91       	pop	r29
    4e0a:	08 95       	ret

00004e0c <LCD_SendCMD>:

static void LCD_SendCMD(u8 cmd){
    4e0c:	df 93       	push	r29
    4e0e:	cf 93       	push	r28
    4e10:	cd b7       	in	r28, 0x3d	; 61
    4e12:	de b7       	in	r29, 0x3e	; 62
    4e14:	69 97       	sbiw	r28, 0x19	; 25
    4e16:	0f b6       	in	r0, 0x3f	; 63
    4e18:	f8 94       	cli
    4e1a:	de bf       	out	0x3e, r29	; 62
    4e1c:	0f be       	out	0x3f, r0	; 63
    4e1e:	cd bf       	out	0x3d, r28	; 61
    4e20:	89 8f       	std	Y+25, r24	; 0x19
	clearBit(LCD_CTRL_PORT,LCD_CTRL_RS); /* select instruction mode */
    4e22:	ab e3       	ldi	r26, 0x3B	; 59
    4e24:	b0 e0       	ldi	r27, 0x00	; 0
    4e26:	eb e3       	ldi	r30, 0x3B	; 59
    4e28:	f0 e0       	ldi	r31, 0x00	; 0
    4e2a:	80 81       	ld	r24, Z
    4e2c:	87 7f       	andi	r24, 0xF7	; 247
    4e2e:	8c 93       	st	X, r24
	/* send high N -> set most 4 bit and (set and clear enable) */
	clearBits(LCD_DATA_PORT, LCD_DATA_MSK1);
    4e30:	a8 e3       	ldi	r26, 0x38	; 56
    4e32:	b0 e0       	ldi	r27, 0x00	; 0
    4e34:	e8 e3       	ldi	r30, 0x38	; 56
    4e36:	f0 e0       	ldi	r31, 0x00	; 0
    4e38:	80 81       	ld	r24, Z
    4e3a:	88 7f       	andi	r24, 0xF8	; 248
    4e3c:	8c 93       	st	X, r24
	setBits(LCD_DATA_PORT, ((cmd>>4)&LCD_DATA_MSK1));
    4e3e:	a8 e3       	ldi	r26, 0x38	; 56
    4e40:	b0 e0       	ldi	r27, 0x00	; 0
    4e42:	e8 e3       	ldi	r30, 0x38	; 56
    4e44:	f0 e0       	ldi	r31, 0x00	; 0
    4e46:	80 81       	ld	r24, Z
    4e48:	98 2f       	mov	r25, r24
    4e4a:	89 8d       	ldd	r24, Y+25	; 0x19
    4e4c:	82 95       	swap	r24
    4e4e:	8f 70       	andi	r24, 0x0F	; 15
    4e50:	87 70       	andi	r24, 0x07	; 7
    4e52:	89 2b       	or	r24, r25
    4e54:	8c 93       	st	X, r24
	clearBits(LCD_DATA_PORT, LCD_DATA_MSK2);
    4e56:	a8 e3       	ldi	r26, 0x38	; 56
    4e58:	b0 e0       	ldi	r27, 0x00	; 0
    4e5a:	e8 e3       	ldi	r30, 0x38	; 56
    4e5c:	f0 e0       	ldi	r31, 0x00	; 0
    4e5e:	80 81       	ld	r24, Z
    4e60:	8f 7e       	andi	r24, 0xEF	; 239
    4e62:	8c 93       	st	X, r24
	setBits(LCD_DATA_PORT, (((cmd>>4)<<1)&LCD_DATA_MSK2));
    4e64:	a8 e3       	ldi	r26, 0x38	; 56
    4e66:	b0 e0       	ldi	r27, 0x00	; 0
    4e68:	e8 e3       	ldi	r30, 0x38	; 56
    4e6a:	f0 e0       	ldi	r31, 0x00	; 0
    4e6c:	80 81       	ld	r24, Z
    4e6e:	28 2f       	mov	r18, r24
    4e70:	89 8d       	ldd	r24, Y+25	; 0x19
    4e72:	82 95       	swap	r24
    4e74:	8f 70       	andi	r24, 0x0F	; 15
    4e76:	88 2f       	mov	r24, r24
    4e78:	90 e0       	ldi	r25, 0x00	; 0
    4e7a:	88 0f       	add	r24, r24
    4e7c:	99 1f       	adc	r25, r25
    4e7e:	80 71       	andi	r24, 0x10	; 16
    4e80:	82 2b       	or	r24, r18
    4e82:	8c 93       	st	X, r24
	LCD_Latch();
    4e84:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <LCD_Latch>
	/* send low N -> set least 4 bit and (set and clear enable) */
	clearBits(LCD_DATA_PORT, LCD_DATA_MSK1);
    4e88:	a8 e3       	ldi	r26, 0x38	; 56
    4e8a:	b0 e0       	ldi	r27, 0x00	; 0
    4e8c:	e8 e3       	ldi	r30, 0x38	; 56
    4e8e:	f0 e0       	ldi	r31, 0x00	; 0
    4e90:	80 81       	ld	r24, Z
    4e92:	88 7f       	andi	r24, 0xF8	; 248
    4e94:	8c 93       	st	X, r24
	setBits(LCD_DATA_PORT, ((cmd)&LCD_DATA_MSK1));
    4e96:	a8 e3       	ldi	r26, 0x38	; 56
    4e98:	b0 e0       	ldi	r27, 0x00	; 0
    4e9a:	e8 e3       	ldi	r30, 0x38	; 56
    4e9c:	f0 e0       	ldi	r31, 0x00	; 0
    4e9e:	80 81       	ld	r24, Z
    4ea0:	98 2f       	mov	r25, r24
    4ea2:	89 8d       	ldd	r24, Y+25	; 0x19
    4ea4:	87 70       	andi	r24, 0x07	; 7
    4ea6:	89 2b       	or	r24, r25
    4ea8:	8c 93       	st	X, r24
	clearBits(LCD_DATA_PORT, LCD_DATA_MSK2);
    4eaa:	a8 e3       	ldi	r26, 0x38	; 56
    4eac:	b0 e0       	ldi	r27, 0x00	; 0
    4eae:	e8 e3       	ldi	r30, 0x38	; 56
    4eb0:	f0 e0       	ldi	r31, 0x00	; 0
    4eb2:	80 81       	ld	r24, Z
    4eb4:	8f 7e       	andi	r24, 0xEF	; 239
    4eb6:	8c 93       	st	X, r24
	setBits(LCD_DATA_PORT, (((cmd) << 1 )&LCD_DATA_MSK2));
    4eb8:	a8 e3       	ldi	r26, 0x38	; 56
    4eba:	b0 e0       	ldi	r27, 0x00	; 0
    4ebc:	e8 e3       	ldi	r30, 0x38	; 56
    4ebe:	f0 e0       	ldi	r31, 0x00	; 0
    4ec0:	80 81       	ld	r24, Z
    4ec2:	28 2f       	mov	r18, r24
    4ec4:	89 8d       	ldd	r24, Y+25	; 0x19
    4ec6:	88 2f       	mov	r24, r24
    4ec8:	90 e0       	ldi	r25, 0x00	; 0
    4eca:	88 0f       	add	r24, r24
    4ecc:	99 1f       	adc	r25, r25
    4ece:	80 71       	andi	r24, 0x10	; 16
    4ed0:	82 2b       	or	r24, r18
    4ed2:	8c 93       	st	X, r24
	LCD_Latch();
    4ed4:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <LCD_Latch>
    4ed8:	80 e0       	ldi	r24, 0x00	; 0
    4eda:	90 e0       	ldi	r25, 0x00	; 0
    4edc:	a0 e2       	ldi	r26, 0x20	; 32
    4ede:	b2 e4       	ldi	r27, 0x42	; 66
    4ee0:	8d 8b       	std	Y+21, r24	; 0x15
    4ee2:	9e 8b       	std	Y+22, r25	; 0x16
    4ee4:	af 8b       	std	Y+23, r26	; 0x17
    4ee6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4ee8:	6d 89       	ldd	r22, Y+21	; 0x15
    4eea:	7e 89       	ldd	r23, Y+22	; 0x16
    4eec:	8f 89       	ldd	r24, Y+23	; 0x17
    4eee:	98 8d       	ldd	r25, Y+24	; 0x18
    4ef0:	2b ea       	ldi	r18, 0xAB	; 171
    4ef2:	3a ea       	ldi	r19, 0xAA	; 170
    4ef4:	4a ea       	ldi	r20, 0xAA	; 170
    4ef6:	50 e4       	ldi	r21, 0x40	; 64
    4ef8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4efc:	dc 01       	movw	r26, r24
    4efe:	cb 01       	movw	r24, r22
    4f00:	89 8b       	std	Y+17, r24	; 0x11
    4f02:	9a 8b       	std	Y+18, r25	; 0x12
    4f04:	ab 8b       	std	Y+19, r26	; 0x13
    4f06:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    4f08:	69 89       	ldd	r22, Y+17	; 0x11
    4f0a:	7a 89       	ldd	r23, Y+18	; 0x12
    4f0c:	8b 89       	ldd	r24, Y+19	; 0x13
    4f0e:	9c 89       	ldd	r25, Y+20	; 0x14
    4f10:	20 e0       	ldi	r18, 0x00	; 0
    4f12:	30 e0       	ldi	r19, 0x00	; 0
    4f14:	40 e8       	ldi	r20, 0x80	; 128
    4f16:	5f e3       	ldi	r21, 0x3F	; 63
    4f18:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4f1c:	88 23       	and	r24, r24
    4f1e:	1c f4       	brge	.+6      	; 0x4f26 <LCD_SendCMD+0x11a>
		__ticks = 1;
    4f20:	81 e0       	ldi	r24, 0x01	; 1
    4f22:	88 8b       	std	Y+16, r24	; 0x10
    4f24:	91 c0       	rjmp	.+290    	; 0x5048 <LCD_SendCMD+0x23c>
	else if (__tmp > 255)
    4f26:	69 89       	ldd	r22, Y+17	; 0x11
    4f28:	7a 89       	ldd	r23, Y+18	; 0x12
    4f2a:	8b 89       	ldd	r24, Y+19	; 0x13
    4f2c:	9c 89       	ldd	r25, Y+20	; 0x14
    4f2e:	20 e0       	ldi	r18, 0x00	; 0
    4f30:	30 e0       	ldi	r19, 0x00	; 0
    4f32:	4f e7       	ldi	r20, 0x7F	; 127
    4f34:	53 e4       	ldi	r21, 0x43	; 67
    4f36:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4f3a:	18 16       	cp	r1, r24
    4f3c:	0c f0       	brlt	.+2      	; 0x4f40 <LCD_SendCMD+0x134>
    4f3e:	7b c0       	rjmp	.+246    	; 0x5036 <LCD_SendCMD+0x22a>
	{
		_delay_ms(__us / 1000.0);
    4f40:	6d 89       	ldd	r22, Y+21	; 0x15
    4f42:	7e 89       	ldd	r23, Y+22	; 0x16
    4f44:	8f 89       	ldd	r24, Y+23	; 0x17
    4f46:	98 8d       	ldd	r25, Y+24	; 0x18
    4f48:	20 e0       	ldi	r18, 0x00	; 0
    4f4a:	30 e0       	ldi	r19, 0x00	; 0
    4f4c:	4a e7       	ldi	r20, 0x7A	; 122
    4f4e:	54 e4       	ldi	r21, 0x44	; 68
    4f50:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4f54:	dc 01       	movw	r26, r24
    4f56:	cb 01       	movw	r24, r22
    4f58:	8c 87       	std	Y+12, r24	; 0x0c
    4f5a:	9d 87       	std	Y+13, r25	; 0x0d
    4f5c:	ae 87       	std	Y+14, r26	; 0x0e
    4f5e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4f60:	6c 85       	ldd	r22, Y+12	; 0x0c
    4f62:	7d 85       	ldd	r23, Y+13	; 0x0d
    4f64:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f66:	9f 85       	ldd	r25, Y+15	; 0x0f
    4f68:	20 e0       	ldi	r18, 0x00	; 0
    4f6a:	30 e0       	ldi	r19, 0x00	; 0
    4f6c:	4a e7       	ldi	r20, 0x7A	; 122
    4f6e:	55 e4       	ldi	r21, 0x45	; 69
    4f70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f74:	dc 01       	movw	r26, r24
    4f76:	cb 01       	movw	r24, r22
    4f78:	88 87       	std	Y+8, r24	; 0x08
    4f7a:	99 87       	std	Y+9, r25	; 0x09
    4f7c:	aa 87       	std	Y+10, r26	; 0x0a
    4f7e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4f80:	68 85       	ldd	r22, Y+8	; 0x08
    4f82:	79 85       	ldd	r23, Y+9	; 0x09
    4f84:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f86:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f88:	20 e0       	ldi	r18, 0x00	; 0
    4f8a:	30 e0       	ldi	r19, 0x00	; 0
    4f8c:	40 e8       	ldi	r20, 0x80	; 128
    4f8e:	5f e3       	ldi	r21, 0x3F	; 63
    4f90:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4f94:	88 23       	and	r24, r24
    4f96:	2c f4       	brge	.+10     	; 0x4fa2 <LCD_SendCMD+0x196>
		__ticks = 1;
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	90 e0       	ldi	r25, 0x00	; 0
    4f9c:	9f 83       	std	Y+7, r25	; 0x07
    4f9e:	8e 83       	std	Y+6, r24	; 0x06
    4fa0:	3f c0       	rjmp	.+126    	; 0x5020 <LCD_SendCMD+0x214>
	else if (__tmp > 65535)
    4fa2:	68 85       	ldd	r22, Y+8	; 0x08
    4fa4:	79 85       	ldd	r23, Y+9	; 0x09
    4fa6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fa8:	9b 85       	ldd	r25, Y+11	; 0x0b
    4faa:	20 e0       	ldi	r18, 0x00	; 0
    4fac:	3f ef       	ldi	r19, 0xFF	; 255
    4fae:	4f e7       	ldi	r20, 0x7F	; 127
    4fb0:	57 e4       	ldi	r21, 0x47	; 71
    4fb2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4fb6:	18 16       	cp	r1, r24
    4fb8:	4c f5       	brge	.+82     	; 0x500c <LCD_SendCMD+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4fba:	6c 85       	ldd	r22, Y+12	; 0x0c
    4fbc:	7d 85       	ldd	r23, Y+13	; 0x0d
    4fbe:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fc0:	9f 85       	ldd	r25, Y+15	; 0x0f
    4fc2:	20 e0       	ldi	r18, 0x00	; 0
    4fc4:	30 e0       	ldi	r19, 0x00	; 0
    4fc6:	40 e2       	ldi	r20, 0x20	; 32
    4fc8:	51 e4       	ldi	r21, 0x41	; 65
    4fca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4fce:	dc 01       	movw	r26, r24
    4fd0:	cb 01       	movw	r24, r22
    4fd2:	bc 01       	movw	r22, r24
    4fd4:	cd 01       	movw	r24, r26
    4fd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4fda:	dc 01       	movw	r26, r24
    4fdc:	cb 01       	movw	r24, r22
    4fde:	9f 83       	std	Y+7, r25	; 0x07
    4fe0:	8e 83       	std	Y+6, r24	; 0x06
    4fe2:	0f c0       	rjmp	.+30     	; 0x5002 <LCD_SendCMD+0x1f6>
    4fe4:	80 e9       	ldi	r24, 0x90	; 144
    4fe6:	91 e0       	ldi	r25, 0x01	; 1
    4fe8:	9d 83       	std	Y+5, r25	; 0x05
    4fea:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4fec:	8c 81       	ldd	r24, Y+4	; 0x04
    4fee:	9d 81       	ldd	r25, Y+5	; 0x05
    4ff0:	01 97       	sbiw	r24, 0x01	; 1
    4ff2:	f1 f7       	brne	.-4      	; 0x4ff0 <LCD_SendCMD+0x1e4>
    4ff4:	9d 83       	std	Y+5, r25	; 0x05
    4ff6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ff8:	8e 81       	ldd	r24, Y+6	; 0x06
    4ffa:	9f 81       	ldd	r25, Y+7	; 0x07
    4ffc:	01 97       	sbiw	r24, 0x01	; 1
    4ffe:	9f 83       	std	Y+7, r25	; 0x07
    5000:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5002:	8e 81       	ldd	r24, Y+6	; 0x06
    5004:	9f 81       	ldd	r25, Y+7	; 0x07
    5006:	00 97       	sbiw	r24, 0x00	; 0
    5008:	69 f7       	brne	.-38     	; 0x4fe4 <LCD_SendCMD+0x1d8>
    500a:	24 c0       	rjmp	.+72     	; 0x5054 <LCD_SendCMD+0x248>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    500c:	68 85       	ldd	r22, Y+8	; 0x08
    500e:	79 85       	ldd	r23, Y+9	; 0x09
    5010:	8a 85       	ldd	r24, Y+10	; 0x0a
    5012:	9b 85       	ldd	r25, Y+11	; 0x0b
    5014:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5018:	dc 01       	movw	r26, r24
    501a:	cb 01       	movw	r24, r22
    501c:	9f 83       	std	Y+7, r25	; 0x07
    501e:	8e 83       	std	Y+6, r24	; 0x06
    5020:	8e 81       	ldd	r24, Y+6	; 0x06
    5022:	9f 81       	ldd	r25, Y+7	; 0x07
    5024:	9b 83       	std	Y+3, r25	; 0x03
    5026:	8a 83       	std	Y+2, r24	; 0x02
    5028:	8a 81       	ldd	r24, Y+2	; 0x02
    502a:	9b 81       	ldd	r25, Y+3	; 0x03
    502c:	01 97       	sbiw	r24, 0x01	; 1
    502e:	f1 f7       	brne	.-4      	; 0x502c <LCD_SendCMD+0x220>
    5030:	9b 83       	std	Y+3, r25	; 0x03
    5032:	8a 83       	std	Y+2, r24	; 0x02
    5034:	0f c0       	rjmp	.+30     	; 0x5054 <LCD_SendCMD+0x248>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5036:	69 89       	ldd	r22, Y+17	; 0x11
    5038:	7a 89       	ldd	r23, Y+18	; 0x12
    503a:	8b 89       	ldd	r24, Y+19	; 0x13
    503c:	9c 89       	ldd	r25, Y+20	; 0x14
    503e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5042:	dc 01       	movw	r26, r24
    5044:	cb 01       	movw	r24, r22
    5046:	88 8b       	std	Y+16, r24	; 0x10
    5048:	88 89       	ldd	r24, Y+16	; 0x10
    504a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    504c:	89 81       	ldd	r24, Y+1	; 0x01
    504e:	8a 95       	dec	r24
    5050:	f1 f7       	brne	.-4      	; 0x504e <LCD_SendCMD+0x242>
    5052:	89 83       	std	Y+1, r24	; 0x01
	
	_delay_us(40);/* wait for command to be executed - 40 us */
}
    5054:	69 96       	adiw	r28, 0x19	; 25
    5056:	0f b6       	in	r0, 0x3f	; 63
    5058:	f8 94       	cli
    505a:	de bf       	out	0x3e, r29	; 62
    505c:	0f be       	out	0x3f, r0	; 63
    505e:	cd bf       	out	0x3d, r28	; 61
    5060:	cf 91       	pop	r28
    5062:	df 91       	pop	r29
    5064:	08 95       	ret

00005066 <LCD_SendData>:
static void LCD_SendData(u8 data){
    5066:	df 93       	push	r29
    5068:	cf 93       	push	r28
    506a:	cd b7       	in	r28, 0x3d	; 61
    506c:	de b7       	in	r29, 0x3e	; 62
    506e:	69 97       	sbiw	r28, 0x19	; 25
    5070:	0f b6       	in	r0, 0x3f	; 63
    5072:	f8 94       	cli
    5074:	de bf       	out	0x3e, r29	; 62
    5076:	0f be       	out	0x3f, r0	; 63
    5078:	cd bf       	out	0x3d, r28	; 61
    507a:	89 8f       	std	Y+25, r24	; 0x19
		setBit(LCD_CTRL_PORT,LCD_CTRL_RS); /* select data mode */
    507c:	ab e3       	ldi	r26, 0x3B	; 59
    507e:	b0 e0       	ldi	r27, 0x00	; 0
    5080:	eb e3       	ldi	r30, 0x3B	; 59
    5082:	f0 e0       	ldi	r31, 0x00	; 0
    5084:	80 81       	ld	r24, Z
    5086:	88 60       	ori	r24, 0x08	; 8
    5088:	8c 93       	st	X, r24
		/* send high N -> set most 4 bit and (set and clear enable) */
		clearBits(LCD_DATA_PORT, LCD_DATA_MSK1);
    508a:	a8 e3       	ldi	r26, 0x38	; 56
    508c:	b0 e0       	ldi	r27, 0x00	; 0
    508e:	e8 e3       	ldi	r30, 0x38	; 56
    5090:	f0 e0       	ldi	r31, 0x00	; 0
    5092:	80 81       	ld	r24, Z
    5094:	88 7f       	andi	r24, 0xF8	; 248
    5096:	8c 93       	st	X, r24
		setBits(LCD_DATA_PORT, ((data>>4)&LCD_DATA_MSK1));
    5098:	a8 e3       	ldi	r26, 0x38	; 56
    509a:	b0 e0       	ldi	r27, 0x00	; 0
    509c:	e8 e3       	ldi	r30, 0x38	; 56
    509e:	f0 e0       	ldi	r31, 0x00	; 0
    50a0:	80 81       	ld	r24, Z
    50a2:	98 2f       	mov	r25, r24
    50a4:	89 8d       	ldd	r24, Y+25	; 0x19
    50a6:	82 95       	swap	r24
    50a8:	8f 70       	andi	r24, 0x0F	; 15
    50aa:	87 70       	andi	r24, 0x07	; 7
    50ac:	89 2b       	or	r24, r25
    50ae:	8c 93       	st	X, r24
		clearBits(LCD_DATA_PORT, LCD_DATA_MSK2);
    50b0:	a8 e3       	ldi	r26, 0x38	; 56
    50b2:	b0 e0       	ldi	r27, 0x00	; 0
    50b4:	e8 e3       	ldi	r30, 0x38	; 56
    50b6:	f0 e0       	ldi	r31, 0x00	; 0
    50b8:	80 81       	ld	r24, Z
    50ba:	8f 7e       	andi	r24, 0xEF	; 239
    50bc:	8c 93       	st	X, r24
		setBits(LCD_DATA_PORT, (((data>>4)<<1)&LCD_DATA_MSK2));
    50be:	a8 e3       	ldi	r26, 0x38	; 56
    50c0:	b0 e0       	ldi	r27, 0x00	; 0
    50c2:	e8 e3       	ldi	r30, 0x38	; 56
    50c4:	f0 e0       	ldi	r31, 0x00	; 0
    50c6:	80 81       	ld	r24, Z
    50c8:	28 2f       	mov	r18, r24
    50ca:	89 8d       	ldd	r24, Y+25	; 0x19
    50cc:	82 95       	swap	r24
    50ce:	8f 70       	andi	r24, 0x0F	; 15
    50d0:	88 2f       	mov	r24, r24
    50d2:	90 e0       	ldi	r25, 0x00	; 0
    50d4:	88 0f       	add	r24, r24
    50d6:	99 1f       	adc	r25, r25
    50d8:	80 71       	andi	r24, 0x10	; 16
    50da:	82 2b       	or	r24, r18
    50dc:	8c 93       	st	X, r24
		LCD_Latch();
    50de:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <LCD_Latch>
		/* send low N -> set least 4 bit and (set and clear enable) */
		clearBits(LCD_DATA_PORT, LCD_DATA_MSK1);
    50e2:	a8 e3       	ldi	r26, 0x38	; 56
    50e4:	b0 e0       	ldi	r27, 0x00	; 0
    50e6:	e8 e3       	ldi	r30, 0x38	; 56
    50e8:	f0 e0       	ldi	r31, 0x00	; 0
    50ea:	80 81       	ld	r24, Z
    50ec:	88 7f       	andi	r24, 0xF8	; 248
    50ee:	8c 93       	st	X, r24
		setBits(LCD_DATA_PORT, ((data)&LCD_DATA_MSK1));
    50f0:	a8 e3       	ldi	r26, 0x38	; 56
    50f2:	b0 e0       	ldi	r27, 0x00	; 0
    50f4:	e8 e3       	ldi	r30, 0x38	; 56
    50f6:	f0 e0       	ldi	r31, 0x00	; 0
    50f8:	80 81       	ld	r24, Z
    50fa:	98 2f       	mov	r25, r24
    50fc:	89 8d       	ldd	r24, Y+25	; 0x19
    50fe:	87 70       	andi	r24, 0x07	; 7
    5100:	89 2b       	or	r24, r25
    5102:	8c 93       	st	X, r24
		clearBits(LCD_DATA_PORT, LCD_DATA_MSK2);
    5104:	a8 e3       	ldi	r26, 0x38	; 56
    5106:	b0 e0       	ldi	r27, 0x00	; 0
    5108:	e8 e3       	ldi	r30, 0x38	; 56
    510a:	f0 e0       	ldi	r31, 0x00	; 0
    510c:	80 81       	ld	r24, Z
    510e:	8f 7e       	andi	r24, 0xEF	; 239
    5110:	8c 93       	st	X, r24
		setBits(LCD_DATA_PORT, (((data) << 1 )&LCD_DATA_MSK2));
    5112:	a8 e3       	ldi	r26, 0x38	; 56
    5114:	b0 e0       	ldi	r27, 0x00	; 0
    5116:	e8 e3       	ldi	r30, 0x38	; 56
    5118:	f0 e0       	ldi	r31, 0x00	; 0
    511a:	80 81       	ld	r24, Z
    511c:	28 2f       	mov	r18, r24
    511e:	89 8d       	ldd	r24, Y+25	; 0x19
    5120:	88 2f       	mov	r24, r24
    5122:	90 e0       	ldi	r25, 0x00	; 0
    5124:	88 0f       	add	r24, r24
    5126:	99 1f       	adc	r25, r25
    5128:	80 71       	andi	r24, 0x10	; 16
    512a:	82 2b       	or	r24, r18
    512c:	8c 93       	st	X, r24
		LCD_Latch();
    512e:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <LCD_Latch>
    5132:	80 e0       	ldi	r24, 0x00	; 0
    5134:	90 e0       	ldi	r25, 0x00	; 0
    5136:	a0 e2       	ldi	r26, 0x20	; 32
    5138:	b2 e4       	ldi	r27, 0x42	; 66
    513a:	8d 8b       	std	Y+21, r24	; 0x15
    513c:	9e 8b       	std	Y+22, r25	; 0x16
    513e:	af 8b       	std	Y+23, r26	; 0x17
    5140:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5142:	6d 89       	ldd	r22, Y+21	; 0x15
    5144:	7e 89       	ldd	r23, Y+22	; 0x16
    5146:	8f 89       	ldd	r24, Y+23	; 0x17
    5148:	98 8d       	ldd	r25, Y+24	; 0x18
    514a:	2b ea       	ldi	r18, 0xAB	; 171
    514c:	3a ea       	ldi	r19, 0xAA	; 170
    514e:	4a ea       	ldi	r20, 0xAA	; 170
    5150:	50 e4       	ldi	r21, 0x40	; 64
    5152:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5156:	dc 01       	movw	r26, r24
    5158:	cb 01       	movw	r24, r22
    515a:	89 8b       	std	Y+17, r24	; 0x11
    515c:	9a 8b       	std	Y+18, r25	; 0x12
    515e:	ab 8b       	std	Y+19, r26	; 0x13
    5160:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5162:	69 89       	ldd	r22, Y+17	; 0x11
    5164:	7a 89       	ldd	r23, Y+18	; 0x12
    5166:	8b 89       	ldd	r24, Y+19	; 0x13
    5168:	9c 89       	ldd	r25, Y+20	; 0x14
    516a:	20 e0       	ldi	r18, 0x00	; 0
    516c:	30 e0       	ldi	r19, 0x00	; 0
    516e:	40 e8       	ldi	r20, 0x80	; 128
    5170:	5f e3       	ldi	r21, 0x3F	; 63
    5172:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5176:	88 23       	and	r24, r24
    5178:	1c f4       	brge	.+6      	; 0x5180 <LCD_SendData+0x11a>
		__ticks = 1;
    517a:	81 e0       	ldi	r24, 0x01	; 1
    517c:	88 8b       	std	Y+16, r24	; 0x10
    517e:	91 c0       	rjmp	.+290    	; 0x52a2 <LCD_SendData+0x23c>
	else if (__tmp > 255)
    5180:	69 89       	ldd	r22, Y+17	; 0x11
    5182:	7a 89       	ldd	r23, Y+18	; 0x12
    5184:	8b 89       	ldd	r24, Y+19	; 0x13
    5186:	9c 89       	ldd	r25, Y+20	; 0x14
    5188:	20 e0       	ldi	r18, 0x00	; 0
    518a:	30 e0       	ldi	r19, 0x00	; 0
    518c:	4f e7       	ldi	r20, 0x7F	; 127
    518e:	53 e4       	ldi	r21, 0x43	; 67
    5190:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5194:	18 16       	cp	r1, r24
    5196:	0c f0       	brlt	.+2      	; 0x519a <LCD_SendData+0x134>
    5198:	7b c0       	rjmp	.+246    	; 0x5290 <LCD_SendData+0x22a>
	{
		_delay_ms(__us / 1000.0);
    519a:	6d 89       	ldd	r22, Y+21	; 0x15
    519c:	7e 89       	ldd	r23, Y+22	; 0x16
    519e:	8f 89       	ldd	r24, Y+23	; 0x17
    51a0:	98 8d       	ldd	r25, Y+24	; 0x18
    51a2:	20 e0       	ldi	r18, 0x00	; 0
    51a4:	30 e0       	ldi	r19, 0x00	; 0
    51a6:	4a e7       	ldi	r20, 0x7A	; 122
    51a8:	54 e4       	ldi	r21, 0x44	; 68
    51aa:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    51ae:	dc 01       	movw	r26, r24
    51b0:	cb 01       	movw	r24, r22
    51b2:	8c 87       	std	Y+12, r24	; 0x0c
    51b4:	9d 87       	std	Y+13, r25	; 0x0d
    51b6:	ae 87       	std	Y+14, r26	; 0x0e
    51b8:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    51ba:	6c 85       	ldd	r22, Y+12	; 0x0c
    51bc:	7d 85       	ldd	r23, Y+13	; 0x0d
    51be:	8e 85       	ldd	r24, Y+14	; 0x0e
    51c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    51c2:	20 e0       	ldi	r18, 0x00	; 0
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	4a e7       	ldi	r20, 0x7A	; 122
    51c8:	55 e4       	ldi	r21, 0x45	; 69
    51ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    51ce:	dc 01       	movw	r26, r24
    51d0:	cb 01       	movw	r24, r22
    51d2:	88 87       	std	Y+8, r24	; 0x08
    51d4:	99 87       	std	Y+9, r25	; 0x09
    51d6:	aa 87       	std	Y+10, r26	; 0x0a
    51d8:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    51da:	68 85       	ldd	r22, Y+8	; 0x08
    51dc:	79 85       	ldd	r23, Y+9	; 0x09
    51de:	8a 85       	ldd	r24, Y+10	; 0x0a
    51e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    51e2:	20 e0       	ldi	r18, 0x00	; 0
    51e4:	30 e0       	ldi	r19, 0x00	; 0
    51e6:	40 e8       	ldi	r20, 0x80	; 128
    51e8:	5f e3       	ldi	r21, 0x3F	; 63
    51ea:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    51ee:	88 23       	and	r24, r24
    51f0:	2c f4       	brge	.+10     	; 0x51fc <LCD_SendData+0x196>
		__ticks = 1;
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	90 e0       	ldi	r25, 0x00	; 0
    51f6:	9f 83       	std	Y+7, r25	; 0x07
    51f8:	8e 83       	std	Y+6, r24	; 0x06
    51fa:	3f c0       	rjmp	.+126    	; 0x527a <LCD_SendData+0x214>
	else if (__tmp > 65535)
    51fc:	68 85       	ldd	r22, Y+8	; 0x08
    51fe:	79 85       	ldd	r23, Y+9	; 0x09
    5200:	8a 85       	ldd	r24, Y+10	; 0x0a
    5202:	9b 85       	ldd	r25, Y+11	; 0x0b
    5204:	20 e0       	ldi	r18, 0x00	; 0
    5206:	3f ef       	ldi	r19, 0xFF	; 255
    5208:	4f e7       	ldi	r20, 0x7F	; 127
    520a:	57 e4       	ldi	r21, 0x47	; 71
    520c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5210:	18 16       	cp	r1, r24
    5212:	4c f5       	brge	.+82     	; 0x5266 <LCD_SendData+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5214:	6c 85       	ldd	r22, Y+12	; 0x0c
    5216:	7d 85       	ldd	r23, Y+13	; 0x0d
    5218:	8e 85       	ldd	r24, Y+14	; 0x0e
    521a:	9f 85       	ldd	r25, Y+15	; 0x0f
    521c:	20 e0       	ldi	r18, 0x00	; 0
    521e:	30 e0       	ldi	r19, 0x00	; 0
    5220:	40 e2       	ldi	r20, 0x20	; 32
    5222:	51 e4       	ldi	r21, 0x41	; 65
    5224:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5228:	dc 01       	movw	r26, r24
    522a:	cb 01       	movw	r24, r22
    522c:	bc 01       	movw	r22, r24
    522e:	cd 01       	movw	r24, r26
    5230:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5234:	dc 01       	movw	r26, r24
    5236:	cb 01       	movw	r24, r22
    5238:	9f 83       	std	Y+7, r25	; 0x07
    523a:	8e 83       	std	Y+6, r24	; 0x06
    523c:	0f c0       	rjmp	.+30     	; 0x525c <LCD_SendData+0x1f6>
    523e:	80 e9       	ldi	r24, 0x90	; 144
    5240:	91 e0       	ldi	r25, 0x01	; 1
    5242:	9d 83       	std	Y+5, r25	; 0x05
    5244:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5246:	8c 81       	ldd	r24, Y+4	; 0x04
    5248:	9d 81       	ldd	r25, Y+5	; 0x05
    524a:	01 97       	sbiw	r24, 0x01	; 1
    524c:	f1 f7       	brne	.-4      	; 0x524a <LCD_SendData+0x1e4>
    524e:	9d 83       	std	Y+5, r25	; 0x05
    5250:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5252:	8e 81       	ldd	r24, Y+6	; 0x06
    5254:	9f 81       	ldd	r25, Y+7	; 0x07
    5256:	01 97       	sbiw	r24, 0x01	; 1
    5258:	9f 83       	std	Y+7, r25	; 0x07
    525a:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    525c:	8e 81       	ldd	r24, Y+6	; 0x06
    525e:	9f 81       	ldd	r25, Y+7	; 0x07
    5260:	00 97       	sbiw	r24, 0x00	; 0
    5262:	69 f7       	brne	.-38     	; 0x523e <LCD_SendData+0x1d8>
    5264:	24 c0       	rjmp	.+72     	; 0x52ae <LCD_SendData+0x248>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5266:	68 85       	ldd	r22, Y+8	; 0x08
    5268:	79 85       	ldd	r23, Y+9	; 0x09
    526a:	8a 85       	ldd	r24, Y+10	; 0x0a
    526c:	9b 85       	ldd	r25, Y+11	; 0x0b
    526e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5272:	dc 01       	movw	r26, r24
    5274:	cb 01       	movw	r24, r22
    5276:	9f 83       	std	Y+7, r25	; 0x07
    5278:	8e 83       	std	Y+6, r24	; 0x06
    527a:	8e 81       	ldd	r24, Y+6	; 0x06
    527c:	9f 81       	ldd	r25, Y+7	; 0x07
    527e:	9b 83       	std	Y+3, r25	; 0x03
    5280:	8a 83       	std	Y+2, r24	; 0x02
    5282:	8a 81       	ldd	r24, Y+2	; 0x02
    5284:	9b 81       	ldd	r25, Y+3	; 0x03
    5286:	01 97       	sbiw	r24, 0x01	; 1
    5288:	f1 f7       	brne	.-4      	; 0x5286 <LCD_SendData+0x220>
    528a:	9b 83       	std	Y+3, r25	; 0x03
    528c:	8a 83       	std	Y+2, r24	; 0x02
    528e:	0f c0       	rjmp	.+30     	; 0x52ae <LCD_SendData+0x248>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5290:	69 89       	ldd	r22, Y+17	; 0x11
    5292:	7a 89       	ldd	r23, Y+18	; 0x12
    5294:	8b 89       	ldd	r24, Y+19	; 0x13
    5296:	9c 89       	ldd	r25, Y+20	; 0x14
    5298:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    529c:	dc 01       	movw	r26, r24
    529e:	cb 01       	movw	r24, r22
    52a0:	88 8b       	std	Y+16, r24	; 0x10
    52a2:	88 89       	ldd	r24, Y+16	; 0x10
    52a4:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    52a6:	89 81       	ldd	r24, Y+1	; 0x01
    52a8:	8a 95       	dec	r24
    52aa:	f1 f7       	brne	.-4      	; 0x52a8 <LCD_SendData+0x242>
    52ac:	89 83       	std	Y+1, r24	; 0x01
		
		_delay_us(40);/* wait for write data command to be executed - 40 us */
}
    52ae:	69 96       	adiw	r28, 0x19	; 25
    52b0:	0f b6       	in	r0, 0x3f	; 63
    52b2:	f8 94       	cli
    52b4:	de bf       	out	0x3e, r29	; 62
    52b6:	0f be       	out	0x3f, r0	; 63
    52b8:	cd bf       	out	0x3d, r28	; 61
    52ba:	cf 91       	pop	r28
    52bc:	df 91       	pop	r29
    52be:	08 95       	ret

000052c0 <LCD_GotoXY>:
/* row: 1:2, col:1:16  */
static void LCD_GotoXY(u8 row, u8 col){
    52c0:	df 93       	push	r29
    52c2:	cf 93       	push	r28
    52c4:	00 d0       	rcall	.+0      	; 0x52c6 <LCD_GotoXY+0x6>
    52c6:	cd b7       	in	r28, 0x3d	; 61
    52c8:	de b7       	in	r29, 0x3e	; 62
    52ca:	89 83       	std	Y+1, r24	; 0x01
    52cc:	6a 83       	std	Y+2, r22	; 0x02
		LCD_SendCMD(CMD_SET_DDRAM_ADD_MSK + 0x00 + col - 1);
	}
	else if(row == 2){
		LCD_SendCMD(CMD_SET_DDRAM_ADD_MSK + 0x40 + col - 1);
	}*/
		LCD_SendCMD(CMD_SET_DDRAM_ADD_MSK + (row-1)*0x40 + col - 1);
    52ce:	89 81       	ldd	r24, Y+1	; 0x01
    52d0:	88 2f       	mov	r24, r24
    52d2:	90 e0       	ldi	r25, 0x00	; 0
    52d4:	01 96       	adiw	r24, 0x01	; 1
    52d6:	00 24       	eor	r0, r0
    52d8:	96 95       	lsr	r25
    52da:	87 95       	ror	r24
    52dc:	07 94       	ror	r0
    52de:	96 95       	lsr	r25
    52e0:	87 95       	ror	r24
    52e2:	07 94       	ror	r0
    52e4:	98 2f       	mov	r25, r24
    52e6:	80 2d       	mov	r24, r0
    52e8:	98 2f       	mov	r25, r24
    52ea:	8a 81       	ldd	r24, Y+2	; 0x02
    52ec:	89 0f       	add	r24, r25
    52ee:	81 50       	subi	r24, 0x01	; 1
    52f0:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>

}
    52f4:	0f 90       	pop	r0
    52f6:	0f 90       	pop	r0
    52f8:	cf 91       	pop	r28
    52fa:	df 91       	pop	r29
    52fc:	08 95       	ret

000052fe <LCD_RetHome>:
void LCD_RetHome(void){
    52fe:	df 93       	push	r29
    5300:	cf 93       	push	r28
    5302:	cd b7       	in	r28, 0x3d	; 61
    5304:	de b7       	in	r29, 0x3e	; 62
    5306:	2e 97       	sbiw	r28, 0x0e	; 14
    5308:	0f b6       	in	r0, 0x3f	; 63
    530a:	f8 94       	cli
    530c:	de bf       	out	0x3e, r29	; 62
    530e:	0f be       	out	0x3f, r0	; 63
    5310:	cd bf       	out	0x3d, r28	; 61
	LCD_SendCMD(CMD_RET_HOME);
    5312:	82 e0       	ldi	r24, 0x02	; 2
    5314:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>
    5318:	80 e0       	ldi	r24, 0x00	; 0
    531a:	90 e0       	ldi	r25, 0x00	; 0
    531c:	a0 ea       	ldi	r26, 0xA0	; 160
    531e:	b0 e4       	ldi	r27, 0x40	; 64
    5320:	8b 87       	std	Y+11, r24	; 0x0b
    5322:	9c 87       	std	Y+12, r25	; 0x0c
    5324:	ad 87       	std	Y+13, r26	; 0x0d
    5326:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5328:	6b 85       	ldd	r22, Y+11	; 0x0b
    532a:	7c 85       	ldd	r23, Y+12	; 0x0c
    532c:	8d 85       	ldd	r24, Y+13	; 0x0d
    532e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5330:	20 e0       	ldi	r18, 0x00	; 0
    5332:	30 e0       	ldi	r19, 0x00	; 0
    5334:	4a e7       	ldi	r20, 0x7A	; 122
    5336:	55 e4       	ldi	r21, 0x45	; 69
    5338:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    533c:	dc 01       	movw	r26, r24
    533e:	cb 01       	movw	r24, r22
    5340:	8f 83       	std	Y+7, r24	; 0x07
    5342:	98 87       	std	Y+8, r25	; 0x08
    5344:	a9 87       	std	Y+9, r26	; 0x09
    5346:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5348:	6f 81       	ldd	r22, Y+7	; 0x07
    534a:	78 85       	ldd	r23, Y+8	; 0x08
    534c:	89 85       	ldd	r24, Y+9	; 0x09
    534e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5350:	20 e0       	ldi	r18, 0x00	; 0
    5352:	30 e0       	ldi	r19, 0x00	; 0
    5354:	40 e8       	ldi	r20, 0x80	; 128
    5356:	5f e3       	ldi	r21, 0x3F	; 63
    5358:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    535c:	88 23       	and	r24, r24
    535e:	2c f4       	brge	.+10     	; 0x536a <LCD_RetHome+0x6c>
		__ticks = 1;
    5360:	81 e0       	ldi	r24, 0x01	; 1
    5362:	90 e0       	ldi	r25, 0x00	; 0
    5364:	9e 83       	std	Y+6, r25	; 0x06
    5366:	8d 83       	std	Y+5, r24	; 0x05
    5368:	3f c0       	rjmp	.+126    	; 0x53e8 <LCD_RetHome+0xea>
	else if (__tmp > 65535)
    536a:	6f 81       	ldd	r22, Y+7	; 0x07
    536c:	78 85       	ldd	r23, Y+8	; 0x08
    536e:	89 85       	ldd	r24, Y+9	; 0x09
    5370:	9a 85       	ldd	r25, Y+10	; 0x0a
    5372:	20 e0       	ldi	r18, 0x00	; 0
    5374:	3f ef       	ldi	r19, 0xFF	; 255
    5376:	4f e7       	ldi	r20, 0x7F	; 127
    5378:	57 e4       	ldi	r21, 0x47	; 71
    537a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    537e:	18 16       	cp	r1, r24
    5380:	4c f5       	brge	.+82     	; 0x53d4 <LCD_RetHome+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5382:	6b 85       	ldd	r22, Y+11	; 0x0b
    5384:	7c 85       	ldd	r23, Y+12	; 0x0c
    5386:	8d 85       	ldd	r24, Y+13	; 0x0d
    5388:	9e 85       	ldd	r25, Y+14	; 0x0e
    538a:	20 e0       	ldi	r18, 0x00	; 0
    538c:	30 e0       	ldi	r19, 0x00	; 0
    538e:	40 e2       	ldi	r20, 0x20	; 32
    5390:	51 e4       	ldi	r21, 0x41	; 65
    5392:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5396:	dc 01       	movw	r26, r24
    5398:	cb 01       	movw	r24, r22
    539a:	bc 01       	movw	r22, r24
    539c:	cd 01       	movw	r24, r26
    539e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53a2:	dc 01       	movw	r26, r24
    53a4:	cb 01       	movw	r24, r22
    53a6:	9e 83       	std	Y+6, r25	; 0x06
    53a8:	8d 83       	std	Y+5, r24	; 0x05
    53aa:	0f c0       	rjmp	.+30     	; 0x53ca <LCD_RetHome+0xcc>
    53ac:	80 e9       	ldi	r24, 0x90	; 144
    53ae:	91 e0       	ldi	r25, 0x01	; 1
    53b0:	9c 83       	std	Y+4, r25	; 0x04
    53b2:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53b4:	8b 81       	ldd	r24, Y+3	; 0x03
    53b6:	9c 81       	ldd	r25, Y+4	; 0x04
    53b8:	01 97       	sbiw	r24, 0x01	; 1
    53ba:	f1 f7       	brne	.-4      	; 0x53b8 <LCD_RetHome+0xba>
    53bc:	9c 83       	std	Y+4, r25	; 0x04
    53be:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53c0:	8d 81       	ldd	r24, Y+5	; 0x05
    53c2:	9e 81       	ldd	r25, Y+6	; 0x06
    53c4:	01 97       	sbiw	r24, 0x01	; 1
    53c6:	9e 83       	std	Y+6, r25	; 0x06
    53c8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53ca:	8d 81       	ldd	r24, Y+5	; 0x05
    53cc:	9e 81       	ldd	r25, Y+6	; 0x06
    53ce:	00 97       	sbiw	r24, 0x00	; 0
    53d0:	69 f7       	brne	.-38     	; 0x53ac <LCD_RetHome+0xae>
    53d2:	14 c0       	rjmp	.+40     	; 0x53fc <LCD_RetHome+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53d4:	6f 81       	ldd	r22, Y+7	; 0x07
    53d6:	78 85       	ldd	r23, Y+8	; 0x08
    53d8:	89 85       	ldd	r24, Y+9	; 0x09
    53da:	9a 85       	ldd	r25, Y+10	; 0x0a
    53dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53e0:	dc 01       	movw	r26, r24
    53e2:	cb 01       	movw	r24, r22
    53e4:	9e 83       	std	Y+6, r25	; 0x06
    53e6:	8d 83       	std	Y+5, r24	; 0x05
    53e8:	8d 81       	ldd	r24, Y+5	; 0x05
    53ea:	9e 81       	ldd	r25, Y+6	; 0x06
    53ec:	9a 83       	std	Y+2, r25	; 0x02
    53ee:	89 83       	std	Y+1, r24	; 0x01
    53f0:	89 81       	ldd	r24, Y+1	; 0x01
    53f2:	9a 81       	ldd	r25, Y+2	; 0x02
    53f4:	01 97       	sbiw	r24, 0x01	; 1
    53f6:	f1 f7       	brne	.-4      	; 0x53f4 <LCD_RetHome+0xf6>
    53f8:	9a 83       	std	Y+2, r25	; 0x02
    53fa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
}
    53fc:	2e 96       	adiw	r28, 0x0e	; 14
    53fe:	0f b6       	in	r0, 0x3f	; 63
    5400:	f8 94       	cli
    5402:	de bf       	out	0x3e, r29	; 62
    5404:	0f be       	out	0x3f, r0	; 63
    5406:	cd bf       	out	0x3d, r28	; 61
    5408:	cf 91       	pop	r28
    540a:	df 91       	pop	r29
    540c:	08 95       	ret

0000540e <LCD_Clear>:
void LCD_Clear(void){
    540e:	df 93       	push	r29
    5410:	cf 93       	push	r28
    5412:	cd b7       	in	r28, 0x3d	; 61
    5414:	de b7       	in	r29, 0x3e	; 62
    5416:	2e 97       	sbiw	r28, 0x0e	; 14
    5418:	0f b6       	in	r0, 0x3f	; 63
    541a:	f8 94       	cli
    541c:	de bf       	out	0x3e, r29	; 62
    541e:	0f be       	out	0x3f, r0	; 63
    5420:	cd bf       	out	0x3d, r28	; 61
	LCD_SendCMD(CMD_CLEAR);
    5422:	81 e0       	ldi	r24, 0x01	; 1
    5424:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>
    5428:	80 e0       	ldi	r24, 0x00	; 0
    542a:	90 e0       	ldi	r25, 0x00	; 0
    542c:	a0 ea       	ldi	r26, 0xA0	; 160
    542e:	b0 e4       	ldi	r27, 0x40	; 64
    5430:	8b 87       	std	Y+11, r24	; 0x0b
    5432:	9c 87       	std	Y+12, r25	; 0x0c
    5434:	ad 87       	std	Y+13, r26	; 0x0d
    5436:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5438:	6b 85       	ldd	r22, Y+11	; 0x0b
    543a:	7c 85       	ldd	r23, Y+12	; 0x0c
    543c:	8d 85       	ldd	r24, Y+13	; 0x0d
    543e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5440:	20 e0       	ldi	r18, 0x00	; 0
    5442:	30 e0       	ldi	r19, 0x00	; 0
    5444:	4a e7       	ldi	r20, 0x7A	; 122
    5446:	55 e4       	ldi	r21, 0x45	; 69
    5448:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    544c:	dc 01       	movw	r26, r24
    544e:	cb 01       	movw	r24, r22
    5450:	8f 83       	std	Y+7, r24	; 0x07
    5452:	98 87       	std	Y+8, r25	; 0x08
    5454:	a9 87       	std	Y+9, r26	; 0x09
    5456:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5458:	6f 81       	ldd	r22, Y+7	; 0x07
    545a:	78 85       	ldd	r23, Y+8	; 0x08
    545c:	89 85       	ldd	r24, Y+9	; 0x09
    545e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5460:	20 e0       	ldi	r18, 0x00	; 0
    5462:	30 e0       	ldi	r19, 0x00	; 0
    5464:	40 e8       	ldi	r20, 0x80	; 128
    5466:	5f e3       	ldi	r21, 0x3F	; 63
    5468:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    546c:	88 23       	and	r24, r24
    546e:	2c f4       	brge	.+10     	; 0x547a <LCD_Clear+0x6c>
		__ticks = 1;
    5470:	81 e0       	ldi	r24, 0x01	; 1
    5472:	90 e0       	ldi	r25, 0x00	; 0
    5474:	9e 83       	std	Y+6, r25	; 0x06
    5476:	8d 83       	std	Y+5, r24	; 0x05
    5478:	3f c0       	rjmp	.+126    	; 0x54f8 <LCD_Clear+0xea>
	else if (__tmp > 65535)
    547a:	6f 81       	ldd	r22, Y+7	; 0x07
    547c:	78 85       	ldd	r23, Y+8	; 0x08
    547e:	89 85       	ldd	r24, Y+9	; 0x09
    5480:	9a 85       	ldd	r25, Y+10	; 0x0a
    5482:	20 e0       	ldi	r18, 0x00	; 0
    5484:	3f ef       	ldi	r19, 0xFF	; 255
    5486:	4f e7       	ldi	r20, 0x7F	; 127
    5488:	57 e4       	ldi	r21, 0x47	; 71
    548a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    548e:	18 16       	cp	r1, r24
    5490:	4c f5       	brge	.+82     	; 0x54e4 <LCD_Clear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5492:	6b 85       	ldd	r22, Y+11	; 0x0b
    5494:	7c 85       	ldd	r23, Y+12	; 0x0c
    5496:	8d 85       	ldd	r24, Y+13	; 0x0d
    5498:	9e 85       	ldd	r25, Y+14	; 0x0e
    549a:	20 e0       	ldi	r18, 0x00	; 0
    549c:	30 e0       	ldi	r19, 0x00	; 0
    549e:	40 e2       	ldi	r20, 0x20	; 32
    54a0:	51 e4       	ldi	r21, 0x41	; 65
    54a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54a6:	dc 01       	movw	r26, r24
    54a8:	cb 01       	movw	r24, r22
    54aa:	bc 01       	movw	r22, r24
    54ac:	cd 01       	movw	r24, r26
    54ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54b2:	dc 01       	movw	r26, r24
    54b4:	cb 01       	movw	r24, r22
    54b6:	9e 83       	std	Y+6, r25	; 0x06
    54b8:	8d 83       	std	Y+5, r24	; 0x05
    54ba:	0f c0       	rjmp	.+30     	; 0x54da <LCD_Clear+0xcc>
    54bc:	80 e9       	ldi	r24, 0x90	; 144
    54be:	91 e0       	ldi	r25, 0x01	; 1
    54c0:	9c 83       	std	Y+4, r25	; 0x04
    54c2:	8b 83       	std	Y+3, r24	; 0x03
    54c4:	8b 81       	ldd	r24, Y+3	; 0x03
    54c6:	9c 81       	ldd	r25, Y+4	; 0x04
    54c8:	01 97       	sbiw	r24, 0x01	; 1
    54ca:	f1 f7       	brne	.-4      	; 0x54c8 <LCD_Clear+0xba>
    54cc:	9c 83       	std	Y+4, r25	; 0x04
    54ce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54d0:	8d 81       	ldd	r24, Y+5	; 0x05
    54d2:	9e 81       	ldd	r25, Y+6	; 0x06
    54d4:	01 97       	sbiw	r24, 0x01	; 1
    54d6:	9e 83       	std	Y+6, r25	; 0x06
    54d8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54da:	8d 81       	ldd	r24, Y+5	; 0x05
    54dc:	9e 81       	ldd	r25, Y+6	; 0x06
    54de:	00 97       	sbiw	r24, 0x00	; 0
    54e0:	69 f7       	brne	.-38     	; 0x54bc <LCD_Clear+0xae>
    54e2:	14 c0       	rjmp	.+40     	; 0x550c <LCD_Clear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54e4:	6f 81       	ldd	r22, Y+7	; 0x07
    54e6:	78 85       	ldd	r23, Y+8	; 0x08
    54e8:	89 85       	ldd	r24, Y+9	; 0x09
    54ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54f0:	dc 01       	movw	r26, r24
    54f2:	cb 01       	movw	r24, r22
    54f4:	9e 83       	std	Y+6, r25	; 0x06
    54f6:	8d 83       	std	Y+5, r24	; 0x05
    54f8:	8d 81       	ldd	r24, Y+5	; 0x05
    54fa:	9e 81       	ldd	r25, Y+6	; 0x06
    54fc:	9a 83       	std	Y+2, r25	; 0x02
    54fe:	89 83       	std	Y+1, r24	; 0x01
    5500:	89 81       	ldd	r24, Y+1	; 0x01
    5502:	9a 81       	ldd	r25, Y+2	; 0x02
    5504:	01 97       	sbiw	r24, 0x01	; 1
    5506:	f1 f7       	brne	.-4      	; 0x5504 <LCD_Clear+0xf6>
    5508:	9a 83       	std	Y+2, r25	; 0x02
    550a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);	
}
    550c:	2e 96       	adiw	r28, 0x0e	; 14
    550e:	0f b6       	in	r0, 0x3f	; 63
    5510:	f8 94       	cli
    5512:	de bf       	out	0x3e, r29	; 62
    5514:	0f be       	out	0x3f, r0	; 63
    5516:	cd bf       	out	0x3d, r28	; 61
    5518:	cf 91       	pop	r28
    551a:	df 91       	pop	r29
    551c:	08 95       	ret

0000551e <LCD_Init>:
void LCD_Init(void){
    551e:	df 93       	push	r29
    5520:	cf 93       	push	r28
    5522:	cd b7       	in	r28, 0x3d	; 61
    5524:	de b7       	in	r29, 0x3e	; 62
    5526:	2e 97       	sbiw	r28, 0x0e	; 14
    5528:	0f b6       	in	r0, 0x3f	; 63
    552a:	f8 94       	cli
    552c:	de bf       	out	0x3e, r29	; 62
    552e:	0f be       	out	0x3f, r0	; 63
    5530:	cd bf       	out	0x3d, r28	; 61
	/* LCD Pins -> Out */
	setBits(LCD_DATA_DDR,LCD_DATA_MSK1);
    5532:	a7 e3       	ldi	r26, 0x37	; 55
    5534:	b0 e0       	ldi	r27, 0x00	; 0
    5536:	e7 e3       	ldi	r30, 0x37	; 55
    5538:	f0 e0       	ldi	r31, 0x00	; 0
    553a:	80 81       	ld	r24, Z
    553c:	87 60       	ori	r24, 0x07	; 7
    553e:	8c 93       	st	X, r24
	setBits(LCD_DATA_DDR,LCD_DATA_MSK2);
    5540:	a7 e3       	ldi	r26, 0x37	; 55
    5542:	b0 e0       	ldi	r27, 0x00	; 0
    5544:	e7 e3       	ldi	r30, 0x37	; 55
    5546:	f0 e0       	ldi	r31, 0x00	; 0
    5548:	80 81       	ld	r24, Z
    554a:	80 61       	ori	r24, 0x10	; 16
    554c:	8c 93       	st	X, r24
	setBit(LCD_CTRL_DDR,LCD_CTRL_RS);
    554e:	aa e3       	ldi	r26, 0x3A	; 58
    5550:	b0 e0       	ldi	r27, 0x00	; 0
    5552:	ea e3       	ldi	r30, 0x3A	; 58
    5554:	f0 e0       	ldi	r31, 0x00	; 0
    5556:	80 81       	ld	r24, Z
    5558:	88 60       	ori	r24, 0x08	; 8
    555a:	8c 93       	st	X, r24
	setBit(LCD_CTRL_DDR,LCD_CTRL_EN);
    555c:	aa e3       	ldi	r26, 0x3A	; 58
    555e:	b0 e0       	ldi	r27, 0x00	; 0
    5560:	ea e3       	ldi	r30, 0x3A	; 58
    5562:	f0 e0       	ldi	r31, 0x00	; 0
    5564:	80 81       	ld	r24, Z
    5566:	84 60       	ori	r24, 0x04	; 4
    5568:	8c 93       	st	X, r24
    556a:	80 e0       	ldi	r24, 0x00	; 0
    556c:	90 e0       	ldi	r25, 0x00	; 0
    556e:	a0 ea       	ldi	r26, 0xA0	; 160
    5570:	b1 e4       	ldi	r27, 0x41	; 65
    5572:	8b 87       	std	Y+11, r24	; 0x0b
    5574:	9c 87       	std	Y+12, r25	; 0x0c
    5576:	ad 87       	std	Y+13, r26	; 0x0d
    5578:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    557a:	6b 85       	ldd	r22, Y+11	; 0x0b
    557c:	7c 85       	ldd	r23, Y+12	; 0x0c
    557e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5580:	9e 85       	ldd	r25, Y+14	; 0x0e
    5582:	20 e0       	ldi	r18, 0x00	; 0
    5584:	30 e0       	ldi	r19, 0x00	; 0
    5586:	4a e7       	ldi	r20, 0x7A	; 122
    5588:	55 e4       	ldi	r21, 0x45	; 69
    558a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    558e:	dc 01       	movw	r26, r24
    5590:	cb 01       	movw	r24, r22
    5592:	8f 83       	std	Y+7, r24	; 0x07
    5594:	98 87       	std	Y+8, r25	; 0x08
    5596:	a9 87       	std	Y+9, r26	; 0x09
    5598:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    559a:	6f 81       	ldd	r22, Y+7	; 0x07
    559c:	78 85       	ldd	r23, Y+8	; 0x08
    559e:	89 85       	ldd	r24, Y+9	; 0x09
    55a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    55a2:	20 e0       	ldi	r18, 0x00	; 0
    55a4:	30 e0       	ldi	r19, 0x00	; 0
    55a6:	40 e8       	ldi	r20, 0x80	; 128
    55a8:	5f e3       	ldi	r21, 0x3F	; 63
    55aa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    55ae:	88 23       	and	r24, r24
    55b0:	2c f4       	brge	.+10     	; 0x55bc <LCD_Init+0x9e>
		__ticks = 1;
    55b2:	81 e0       	ldi	r24, 0x01	; 1
    55b4:	90 e0       	ldi	r25, 0x00	; 0
    55b6:	9e 83       	std	Y+6, r25	; 0x06
    55b8:	8d 83       	std	Y+5, r24	; 0x05
    55ba:	3f c0       	rjmp	.+126    	; 0x563a <LCD_Init+0x11c>
	else if (__tmp > 65535)
    55bc:	6f 81       	ldd	r22, Y+7	; 0x07
    55be:	78 85       	ldd	r23, Y+8	; 0x08
    55c0:	89 85       	ldd	r24, Y+9	; 0x09
    55c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    55c4:	20 e0       	ldi	r18, 0x00	; 0
    55c6:	3f ef       	ldi	r19, 0xFF	; 255
    55c8:	4f e7       	ldi	r20, 0x7F	; 127
    55ca:	57 e4       	ldi	r21, 0x47	; 71
    55cc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    55d0:	18 16       	cp	r1, r24
    55d2:	4c f5       	brge	.+82     	; 0x5626 <LCD_Init+0x108>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    55d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    55d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    55d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    55da:	9e 85       	ldd	r25, Y+14	; 0x0e
    55dc:	20 e0       	ldi	r18, 0x00	; 0
    55de:	30 e0       	ldi	r19, 0x00	; 0
    55e0:	40 e2       	ldi	r20, 0x20	; 32
    55e2:	51 e4       	ldi	r21, 0x41	; 65
    55e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    55e8:	dc 01       	movw	r26, r24
    55ea:	cb 01       	movw	r24, r22
    55ec:	bc 01       	movw	r22, r24
    55ee:	cd 01       	movw	r24, r26
    55f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55f4:	dc 01       	movw	r26, r24
    55f6:	cb 01       	movw	r24, r22
    55f8:	9e 83       	std	Y+6, r25	; 0x06
    55fa:	8d 83       	std	Y+5, r24	; 0x05
    55fc:	0f c0       	rjmp	.+30     	; 0x561c <LCD_Init+0xfe>
    55fe:	80 e9       	ldi	r24, 0x90	; 144
    5600:	91 e0       	ldi	r25, 0x01	; 1
    5602:	9c 83       	std	Y+4, r25	; 0x04
    5604:	8b 83       	std	Y+3, r24	; 0x03
    5606:	8b 81       	ldd	r24, Y+3	; 0x03
    5608:	9c 81       	ldd	r25, Y+4	; 0x04
    560a:	01 97       	sbiw	r24, 0x01	; 1
    560c:	f1 f7       	brne	.-4      	; 0x560a <LCD_Init+0xec>
    560e:	9c 83       	std	Y+4, r25	; 0x04
    5610:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5612:	8d 81       	ldd	r24, Y+5	; 0x05
    5614:	9e 81       	ldd	r25, Y+6	; 0x06
    5616:	01 97       	sbiw	r24, 0x01	; 1
    5618:	9e 83       	std	Y+6, r25	; 0x06
    561a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    561c:	8d 81       	ldd	r24, Y+5	; 0x05
    561e:	9e 81       	ldd	r25, Y+6	; 0x06
    5620:	00 97       	sbiw	r24, 0x00	; 0
    5622:	69 f7       	brne	.-38     	; 0x55fe <LCD_Init+0xe0>
    5624:	14 c0       	rjmp	.+40     	; 0x564e <LCD_Init+0x130>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5626:	6f 81       	ldd	r22, Y+7	; 0x07
    5628:	78 85       	ldd	r23, Y+8	; 0x08
    562a:	89 85       	ldd	r24, Y+9	; 0x09
    562c:	9a 85       	ldd	r25, Y+10	; 0x0a
    562e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5632:	dc 01       	movw	r26, r24
    5634:	cb 01       	movw	r24, r22
    5636:	9e 83       	std	Y+6, r25	; 0x06
    5638:	8d 83       	std	Y+5, r24	; 0x05
    563a:	8d 81       	ldd	r24, Y+5	; 0x05
    563c:	9e 81       	ldd	r25, Y+6	; 0x06
    563e:	9a 83       	std	Y+2, r25	; 0x02
    5640:	89 83       	std	Y+1, r24	; 0x01
    5642:	89 81       	ldd	r24, Y+1	; 0x01
    5644:	9a 81       	ldd	r25, Y+2	; 0x02
    5646:	01 97       	sbiw	r24, 0x01	; 1
    5648:	f1 f7       	brne	.-4      	; 0x5646 <LCD_Init+0x128>
    564a:	9a 83       	std	Y+2, r25	; 0x02
    564c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
	LCD_RetHome();
    564e:	0e 94 7f 29 	call	0x52fe	; 0x52fe <LCD_RetHome>
	LCD_SendCMD(CMD_FUN_SET);
    5652:	88 e2       	ldi	r24, 0x28	; 40
    5654:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>
	LCD_SendCMD(CMD_DISP_ON);
    5658:	8c e0       	ldi	r24, 0x0C	; 12
    565a:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>
	LCD_SendCMD(CMD_ENTRY_MODE);
    565e:	86 e0       	ldi	r24, 0x06	; 6
    5660:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>
	LCD_Clear();
    5664:	0e 94 07 2a 	call	0x540e	; 0x540e <LCD_Clear>
}
    5668:	2e 96       	adiw	r28, 0x0e	; 14
    566a:	0f b6       	in	r0, 0x3f	; 63
    566c:	f8 94       	cli
    566e:	de bf       	out	0x3e, r29	; 62
    5670:	0f be       	out	0x3f, r0	; 63
    5672:	cd bf       	out	0x3d, r28	; 61
    5674:	cf 91       	pop	r28
    5676:	df 91       	pop	r29
    5678:	08 95       	ret

0000567a <LCD_DispChar>:

void LCD_DispChar(u8 data){
    567a:	df 93       	push	r29
    567c:	cf 93       	push	r28
    567e:	0f 92       	push	r0
    5680:	cd b7       	in	r28, 0x3d	; 61
    5682:	de b7       	in	r29, 0x3e	; 62
    5684:	89 83       	std	Y+1, r24	; 0x01
	LCD_SendData(data);
    5686:	89 81       	ldd	r24, Y+1	; 0x01
    5688:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
}
    568c:	0f 90       	pop	r0
    568e:	cf 91       	pop	r28
    5690:	df 91       	pop	r29
    5692:	08 95       	ret

00005694 <LCD_DispCharXY>:
void LCD_DispCharXY(u8 row, u8 col, u8 data){
    5694:	df 93       	push	r29
    5696:	cf 93       	push	r28
    5698:	00 d0       	rcall	.+0      	; 0x569a <LCD_DispCharXY+0x6>
    569a:	0f 92       	push	r0
    569c:	cd b7       	in	r28, 0x3d	; 61
    569e:	de b7       	in	r29, 0x3e	; 62
    56a0:	89 83       	std	Y+1, r24	; 0x01
    56a2:	6a 83       	std	Y+2, r22	; 0x02
    56a4:	4b 83       	std	Y+3, r20	; 0x03
	LCD_GotoXY(row,col);
    56a6:	89 81       	ldd	r24, Y+1	; 0x01
    56a8:	6a 81       	ldd	r22, Y+2	; 0x02
    56aa:	0e 94 60 29 	call	0x52c0	; 0x52c0 <LCD_GotoXY>
	LCD_DispChar(data);
    56ae:	8b 81       	ldd	r24, Y+3	; 0x03
    56b0:	0e 94 3d 2b 	call	0x567a	; 0x567a <LCD_DispChar>
}
    56b4:	0f 90       	pop	r0
    56b6:	0f 90       	pop	r0
    56b8:	0f 90       	pop	r0
    56ba:	cf 91       	pop	r28
    56bc:	df 91       	pop	r29
    56be:	08 95       	ret

000056c0 <LCD_DispStr>:
void LCD_DispStr(u8* str){
    56c0:	df 93       	push	r29
    56c2:	cf 93       	push	r28
    56c4:	00 d0       	rcall	.+0      	; 0x56c6 <LCD_DispStr+0x6>
    56c6:	0f 92       	push	r0
    56c8:	cd b7       	in	r28, 0x3d	; 61
    56ca:	de b7       	in	r29, 0x3e	; 62
    56cc:	9b 83       	std	Y+3, r25	; 0x03
    56ce:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    56d0:	19 82       	std	Y+1, r1	; 0x01
    56d2:	0e c0       	rjmp	.+28     	; 0x56f0 <LCD_DispStr+0x30>
	while(str[i] != 0)
	{
		LCD_DispChar(str[i]);
    56d4:	89 81       	ldd	r24, Y+1	; 0x01
    56d6:	28 2f       	mov	r18, r24
    56d8:	30 e0       	ldi	r19, 0x00	; 0
    56da:	8a 81       	ldd	r24, Y+2	; 0x02
    56dc:	9b 81       	ldd	r25, Y+3	; 0x03
    56de:	fc 01       	movw	r30, r24
    56e0:	e2 0f       	add	r30, r18
    56e2:	f3 1f       	adc	r31, r19
    56e4:	80 81       	ld	r24, Z
    56e6:	0e 94 3d 2b 	call	0x567a	; 0x567a <LCD_DispChar>
		i++;
    56ea:	89 81       	ldd	r24, Y+1	; 0x01
    56ec:	8f 5f       	subi	r24, 0xFF	; 255
    56ee:	89 83       	std	Y+1, r24	; 0x01
	LCD_GotoXY(row,col);
	LCD_DispChar(data);
}
void LCD_DispStr(u8* str){
	u8 i = 0;
	while(str[i] != 0)
    56f0:	89 81       	ldd	r24, Y+1	; 0x01
    56f2:	28 2f       	mov	r18, r24
    56f4:	30 e0       	ldi	r19, 0x00	; 0
    56f6:	8a 81       	ldd	r24, Y+2	; 0x02
    56f8:	9b 81       	ldd	r25, Y+3	; 0x03
    56fa:	fc 01       	movw	r30, r24
    56fc:	e2 0f       	add	r30, r18
    56fe:	f3 1f       	adc	r31, r19
    5700:	80 81       	ld	r24, Z
    5702:	88 23       	and	r24, r24
    5704:	39 f7       	brne	.-50     	; 0x56d4 <LCD_DispStr+0x14>
	{
		LCD_DispChar(str[i]);
		i++;
	}
}
    5706:	0f 90       	pop	r0
    5708:	0f 90       	pop	r0
    570a:	0f 90       	pop	r0
    570c:	cf 91       	pop	r28
    570e:	df 91       	pop	r29
    5710:	08 95       	ret

00005712 <LCD_DispStrXY>:
void LCD_DispStrXY(u8 row, u8 col, u8* str){
    5712:	df 93       	push	r29
    5714:	cf 93       	push	r28
    5716:	00 d0       	rcall	.+0      	; 0x5718 <LCD_DispStrXY+0x6>
    5718:	00 d0       	rcall	.+0      	; 0x571a <LCD_DispStrXY+0x8>
    571a:	cd b7       	in	r28, 0x3d	; 61
    571c:	de b7       	in	r29, 0x3e	; 62
    571e:	89 83       	std	Y+1, r24	; 0x01
    5720:	6a 83       	std	Y+2, r22	; 0x02
    5722:	5c 83       	std	Y+4, r21	; 0x04
    5724:	4b 83       	std	Y+3, r20	; 0x03
		LCD_GotoXY(row,col);
    5726:	89 81       	ldd	r24, Y+1	; 0x01
    5728:	6a 81       	ldd	r22, Y+2	; 0x02
    572a:	0e 94 60 29 	call	0x52c0	; 0x52c0 <LCD_GotoXY>
		LCD_DispStr(str);
    572e:	8b 81       	ldd	r24, Y+3	; 0x03
    5730:	9c 81       	ldd	r25, Y+4	; 0x04
    5732:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <LCD_DispStr>
}
    5736:	0f 90       	pop	r0
    5738:	0f 90       	pop	r0
    573a:	0f 90       	pop	r0
    573c:	0f 90       	pop	r0
    573e:	cf 91       	pop	r28
    5740:	df 91       	pop	r29
    5742:	08 95       	ret

00005744 <LCD_DispInt>:

void LCD_DispInt(u32 intValue){
    5744:	df 93       	push	r29
    5746:	cf 93       	push	r28
    5748:	cd b7       	in	r28, 0x3d	; 61
    574a:	de b7       	in	r29, 0x3e	; 62
    574c:	2f 97       	sbiw	r28, 0x0f	; 15
    574e:	0f b6       	in	r0, 0x3f	; 63
    5750:	f8 94       	cli
    5752:	de bf       	out	0x3e, r29	; 62
    5754:	0f be       	out	0x3f, r0	; 63
    5756:	cd bf       	out	0x3d, r28	; 61
    5758:	6c 87       	std	Y+12, r22	; 0x0c
    575a:	7d 87       	std	Y+13, r23	; 0x0d
    575c:	8e 87       	std	Y+14, r24	; 0x0e
    575e:	9f 87       	std	Y+15, r25	; 0x0f
	u8 tempStr[11] = {0};
    5760:	8b e0       	ldi	r24, 0x0B	; 11
    5762:	fe 01       	movw	r30, r28
    5764:	31 96       	adiw	r30, 0x01	; 1
    5766:	df 01       	movw	r26, r30
    5768:	98 2f       	mov	r25, r24
    576a:	1d 92       	st	X+, r1
    576c:	9a 95       	dec	r25
    576e:	e9 f7       	brne	.-6      	; 0x576a <LCD_DispInt+0x26>
	sprintf(tempStr, "%u",intValue);
    5770:	ad b7       	in	r26, 0x3d	; 61
    5772:	be b7       	in	r27, 0x3e	; 62
    5774:	18 97       	sbiw	r26, 0x08	; 8
    5776:	0f b6       	in	r0, 0x3f	; 63
    5778:	f8 94       	cli
    577a:	be bf       	out	0x3e, r27	; 62
    577c:	0f be       	out	0x3f, r0	; 63
    577e:	ad bf       	out	0x3d, r26	; 61
    5780:	ed b7       	in	r30, 0x3d	; 61
    5782:	fe b7       	in	r31, 0x3e	; 62
    5784:	31 96       	adiw	r30, 0x01	; 1
    5786:	ce 01       	movw	r24, r28
    5788:	01 96       	adiw	r24, 0x01	; 1
    578a:	91 83       	std	Z+1, r25	; 0x01
    578c:	80 83       	st	Z, r24
    578e:	8d e7       	ldi	r24, 0x7D	; 125
    5790:	90 e0       	ldi	r25, 0x00	; 0
    5792:	93 83       	std	Z+3, r25	; 0x03
    5794:	82 83       	std	Z+2, r24	; 0x02
    5796:	8c 85       	ldd	r24, Y+12	; 0x0c
    5798:	9d 85       	ldd	r25, Y+13	; 0x0d
    579a:	ae 85       	ldd	r26, Y+14	; 0x0e
    579c:	bf 85       	ldd	r27, Y+15	; 0x0f
    579e:	84 83       	std	Z+4, r24	; 0x04
    57a0:	95 83       	std	Z+5, r25	; 0x05
    57a2:	a6 83       	std	Z+6, r26	; 0x06
    57a4:	b7 83       	std	Z+7, r27	; 0x07
    57a6:	0e 94 79 30 	call	0x60f2	; 0x60f2 <sprintf>
    57aa:	8d b7       	in	r24, 0x3d	; 61
    57ac:	9e b7       	in	r25, 0x3e	; 62
    57ae:	08 96       	adiw	r24, 0x08	; 8
    57b0:	0f b6       	in	r0, 0x3f	; 63
    57b2:	f8 94       	cli
    57b4:	9e bf       	out	0x3e, r25	; 62
    57b6:	0f be       	out	0x3f, r0	; 63
    57b8:	8d bf       	out	0x3d, r24	; 61
	LCD_DispStr(tempStr);
    57ba:	ce 01       	movw	r24, r28
    57bc:	01 96       	adiw	r24, 0x01	; 1
    57be:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <LCD_DispStr>
}
    57c2:	2f 96       	adiw	r28, 0x0f	; 15
    57c4:	0f b6       	in	r0, 0x3f	; 63
    57c6:	f8 94       	cli
    57c8:	de bf       	out	0x3e, r29	; 62
    57ca:	0f be       	out	0x3f, r0	; 63
    57cc:	cd bf       	out	0x3d, r28	; 61
    57ce:	cf 91       	pop	r28
    57d0:	df 91       	pop	r29
    57d2:	08 95       	ret

000057d4 <LCD_DispHex>:
void LCD_DispHex(u32 intValue){
    57d4:	df 93       	push	r29
    57d6:	cf 93       	push	r28
    57d8:	cd b7       	in	r28, 0x3d	; 61
    57da:	de b7       	in	r29, 0x3e	; 62
    57dc:	2f 97       	sbiw	r28, 0x0f	; 15
    57de:	0f b6       	in	r0, 0x3f	; 63
    57e0:	f8 94       	cli
    57e2:	de bf       	out	0x3e, r29	; 62
    57e4:	0f be       	out	0x3f, r0	; 63
    57e6:	cd bf       	out	0x3d, r28	; 61
    57e8:	6c 87       	std	Y+12, r22	; 0x0c
    57ea:	7d 87       	std	Y+13, r23	; 0x0d
    57ec:	8e 87       	std	Y+14, r24	; 0x0e
    57ee:	9f 87       	std	Y+15, r25	; 0x0f
	u8 tempStr[11] = {0};
    57f0:	8b e0       	ldi	r24, 0x0B	; 11
    57f2:	fe 01       	movw	r30, r28
    57f4:	31 96       	adiw	r30, 0x01	; 1
    57f6:	df 01       	movw	r26, r30
    57f8:	98 2f       	mov	r25, r24
    57fa:	1d 92       	st	X+, r1
    57fc:	9a 95       	dec	r25
    57fe:	e9 f7       	brne	.-6      	; 0x57fa <LCD_DispHex+0x26>
	sprintf(tempStr, "%x",intValue);
    5800:	ad b7       	in	r26, 0x3d	; 61
    5802:	be b7       	in	r27, 0x3e	; 62
    5804:	18 97       	sbiw	r26, 0x08	; 8
    5806:	0f b6       	in	r0, 0x3f	; 63
    5808:	f8 94       	cli
    580a:	be bf       	out	0x3e, r27	; 62
    580c:	0f be       	out	0x3f, r0	; 63
    580e:	ad bf       	out	0x3d, r26	; 61
    5810:	ed b7       	in	r30, 0x3d	; 61
    5812:	fe b7       	in	r31, 0x3e	; 62
    5814:	31 96       	adiw	r30, 0x01	; 1
    5816:	ce 01       	movw	r24, r28
    5818:	01 96       	adiw	r24, 0x01	; 1
    581a:	91 83       	std	Z+1, r25	; 0x01
    581c:	80 83       	st	Z, r24
    581e:	80 e8       	ldi	r24, 0x80	; 128
    5820:	90 e0       	ldi	r25, 0x00	; 0
    5822:	93 83       	std	Z+3, r25	; 0x03
    5824:	82 83       	std	Z+2, r24	; 0x02
    5826:	8c 85       	ldd	r24, Y+12	; 0x0c
    5828:	9d 85       	ldd	r25, Y+13	; 0x0d
    582a:	ae 85       	ldd	r26, Y+14	; 0x0e
    582c:	bf 85       	ldd	r27, Y+15	; 0x0f
    582e:	84 83       	std	Z+4, r24	; 0x04
    5830:	95 83       	std	Z+5, r25	; 0x05
    5832:	a6 83       	std	Z+6, r26	; 0x06
    5834:	b7 83       	std	Z+7, r27	; 0x07
    5836:	0e 94 79 30 	call	0x60f2	; 0x60f2 <sprintf>
    583a:	8d b7       	in	r24, 0x3d	; 61
    583c:	9e b7       	in	r25, 0x3e	; 62
    583e:	08 96       	adiw	r24, 0x08	; 8
    5840:	0f b6       	in	r0, 0x3f	; 63
    5842:	f8 94       	cli
    5844:	9e bf       	out	0x3e, r25	; 62
    5846:	0f be       	out	0x3f, r0	; 63
    5848:	8d bf       	out	0x3d, r24	; 61
	LCD_DispStr(tempStr);
    584a:	ce 01       	movw	r24, r28
    584c:	01 96       	adiw	r24, 0x01	; 1
    584e:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <LCD_DispStr>
}
    5852:	2f 96       	adiw	r28, 0x0f	; 15
    5854:	0f b6       	in	r0, 0x3f	; 63
    5856:	f8 94       	cli
    5858:	de bf       	out	0x3e, r29	; 62
    585a:	0f be       	out	0x3f, r0	; 63
    585c:	cd bf       	out	0x3d, r28	; 61
    585e:	cf 91       	pop	r28
    5860:	df 91       	pop	r29
    5862:	08 95       	ret

00005864 <LCD_DispHexXY>:
void LCD_DispHexXY(u8 row, u8 col, u32 intValue){
    5864:	df 93       	push	r29
    5866:	cf 93       	push	r28
    5868:	00 d0       	rcall	.+0      	; 0x586a <LCD_DispHexXY+0x6>
    586a:	00 d0       	rcall	.+0      	; 0x586c <LCD_DispHexXY+0x8>
    586c:	00 d0       	rcall	.+0      	; 0x586e <LCD_DispHexXY+0xa>
    586e:	cd b7       	in	r28, 0x3d	; 61
    5870:	de b7       	in	r29, 0x3e	; 62
    5872:	89 83       	std	Y+1, r24	; 0x01
    5874:	6a 83       	std	Y+2, r22	; 0x02
    5876:	2b 83       	std	Y+3, r18	; 0x03
    5878:	3c 83       	std	Y+4, r19	; 0x04
    587a:	4d 83       	std	Y+5, r20	; 0x05
    587c:	5e 83       	std	Y+6, r21	; 0x06
	LCD_GotoXY(row,col);
    587e:	89 81       	ldd	r24, Y+1	; 0x01
    5880:	6a 81       	ldd	r22, Y+2	; 0x02
    5882:	0e 94 60 29 	call	0x52c0	; 0x52c0 <LCD_GotoXY>
	LCD_DispHex(intValue);
    5886:	8b 81       	ldd	r24, Y+3	; 0x03
    5888:	9c 81       	ldd	r25, Y+4	; 0x04
    588a:	ad 81       	ldd	r26, Y+5	; 0x05
    588c:	be 81       	ldd	r27, Y+6	; 0x06
    588e:	bc 01       	movw	r22, r24
    5890:	cd 01       	movw	r24, r26
    5892:	0e 94 ea 2b 	call	0x57d4	; 0x57d4 <LCD_DispHex>
}
    5896:	26 96       	adiw	r28, 0x06	; 6
    5898:	0f b6       	in	r0, 0x3f	; 63
    589a:	f8 94       	cli
    589c:	de bf       	out	0x3e, r29	; 62
    589e:	0f be       	out	0x3f, r0	; 63
    58a0:	cd bf       	out	0x3d, r28	; 61
    58a2:	cf 91       	pop	r28
    58a4:	df 91       	pop	r29
    58a6:	08 95       	ret

000058a8 <LCD_DispIntXY>:
void LCD_DispIntXY(u8 row, u8 col, u32 intValue){
    58a8:	df 93       	push	r29
    58aa:	cf 93       	push	r28
    58ac:	00 d0       	rcall	.+0      	; 0x58ae <LCD_DispIntXY+0x6>
    58ae:	00 d0       	rcall	.+0      	; 0x58b0 <LCD_DispIntXY+0x8>
    58b0:	00 d0       	rcall	.+0      	; 0x58b2 <LCD_DispIntXY+0xa>
    58b2:	cd b7       	in	r28, 0x3d	; 61
    58b4:	de b7       	in	r29, 0x3e	; 62
    58b6:	89 83       	std	Y+1, r24	; 0x01
    58b8:	6a 83       	std	Y+2, r22	; 0x02
    58ba:	2b 83       	std	Y+3, r18	; 0x03
    58bc:	3c 83       	std	Y+4, r19	; 0x04
    58be:	4d 83       	std	Y+5, r20	; 0x05
    58c0:	5e 83       	std	Y+6, r21	; 0x06
		LCD_GotoXY(row,col);
    58c2:	89 81       	ldd	r24, Y+1	; 0x01
    58c4:	6a 81       	ldd	r22, Y+2	; 0x02
    58c6:	0e 94 60 29 	call	0x52c0	; 0x52c0 <LCD_GotoXY>
		LCD_DispInt(intValue);
    58ca:	8b 81       	ldd	r24, Y+3	; 0x03
    58cc:	9c 81       	ldd	r25, Y+4	; 0x04
    58ce:	ad 81       	ldd	r26, Y+5	; 0x05
    58d0:	be 81       	ldd	r27, Y+6	; 0x06
    58d2:	bc 01       	movw	r22, r24
    58d4:	cd 01       	movw	r24, r26
    58d6:	0e 94 a2 2b 	call	0x5744	; 0x5744 <LCD_DispInt>
}
    58da:	26 96       	adiw	r28, 0x06	; 6
    58dc:	0f b6       	in	r0, 0x3f	; 63
    58de:	f8 94       	cli
    58e0:	de bf       	out	0x3e, r29	; 62
    58e2:	0f be       	out	0x3f, r0	; 63
    58e4:	cd bf       	out	0x3d, r28	; 61
    58e6:	cf 91       	pop	r28
    58e8:	df 91       	pop	r29
    58ea:	08 95       	ret

000058ec <LCD_Fun>:
void LCD_Fun(void){
    58ec:	df 93       	push	r29
    58ee:	cf 93       	push	r28
    58f0:	cd b7       	in	r28, 0x3d	; 61
    58f2:	de b7       	in	r29, 0x3e	; 62
    58f4:	2e 97       	sbiw	r28, 0x0e	; 14
    58f6:	0f b6       	in	r0, 0x3f	; 63
    58f8:	f8 94       	cli
    58fa:	de bf       	out	0x3e, r29	; 62
    58fc:	0f be       	out	0x3f, r0	; 63
    58fe:	cd bf       	out	0x3d, r28	; 61
	LCD_SendCMD(CMD_SET_CGRAM_ADD_MSK + 7*8);
    5900:	88 e7       	ldi	r24, 0x78	; 120
    5902:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <LCD_SendCMD>


	LCD_SendData(0b00011111);
    5906:	8f e1       	ldi	r24, 0x1F	; 31
    5908:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00011111);
    590c:	8f e1       	ldi	r24, 0x1F	; 31
    590e:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00011111);
    5912:	8f e1       	ldi	r24, 0x1F	; 31
    5914:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00000000);
    5918:	80 e0       	ldi	r24, 0x00	; 0
    591a:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00011111);
    591e:	8f e1       	ldi	r24, 0x1F	; 31
    5920:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00011111);
    5924:	8f e1       	ldi	r24, 0x1F	; 31
    5926:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00011111);
    592a:	8f e1       	ldi	r24, 0x1F	; 31
    592c:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
	LCD_SendData(0b00000000);
    5930:	80 e0       	ldi	r24, 0x00	; 0
    5932:	0e 94 33 28 	call	0x5066	; 0x5066 <LCD_SendData>
    5936:	80 e0       	ldi	r24, 0x00	; 0
    5938:	90 e0       	ldi	r25, 0x00	; 0
    593a:	a0 e2       	ldi	r26, 0x20	; 32
    593c:	b1 e4       	ldi	r27, 0x41	; 65
    593e:	8b 87       	std	Y+11, r24	; 0x0b
    5940:	9c 87       	std	Y+12, r25	; 0x0c
    5942:	ad 87       	std	Y+13, r26	; 0x0d
    5944:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5946:	6b 85       	ldd	r22, Y+11	; 0x0b
    5948:	7c 85       	ldd	r23, Y+12	; 0x0c
    594a:	8d 85       	ldd	r24, Y+13	; 0x0d
    594c:	9e 85       	ldd	r25, Y+14	; 0x0e
    594e:	20 e0       	ldi	r18, 0x00	; 0
    5950:	30 e0       	ldi	r19, 0x00	; 0
    5952:	4a e7       	ldi	r20, 0x7A	; 122
    5954:	55 e4       	ldi	r21, 0x45	; 69
    5956:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    595a:	dc 01       	movw	r26, r24
    595c:	cb 01       	movw	r24, r22
    595e:	8f 83       	std	Y+7, r24	; 0x07
    5960:	98 87       	std	Y+8, r25	; 0x08
    5962:	a9 87       	std	Y+9, r26	; 0x09
    5964:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5966:	6f 81       	ldd	r22, Y+7	; 0x07
    5968:	78 85       	ldd	r23, Y+8	; 0x08
    596a:	89 85       	ldd	r24, Y+9	; 0x09
    596c:	9a 85       	ldd	r25, Y+10	; 0x0a
    596e:	20 e0       	ldi	r18, 0x00	; 0
    5970:	30 e0       	ldi	r19, 0x00	; 0
    5972:	40 e8       	ldi	r20, 0x80	; 128
    5974:	5f e3       	ldi	r21, 0x3F	; 63
    5976:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    597a:	88 23       	and	r24, r24
    597c:	2c f4       	brge	.+10     	; 0x5988 <LCD_Fun+0x9c>
		__ticks = 1;
    597e:	81 e0       	ldi	r24, 0x01	; 1
    5980:	90 e0       	ldi	r25, 0x00	; 0
    5982:	9e 83       	std	Y+6, r25	; 0x06
    5984:	8d 83       	std	Y+5, r24	; 0x05
    5986:	3f c0       	rjmp	.+126    	; 0x5a06 <LCD_Fun+0x11a>
	else if (__tmp > 65535)
    5988:	6f 81       	ldd	r22, Y+7	; 0x07
    598a:	78 85       	ldd	r23, Y+8	; 0x08
    598c:	89 85       	ldd	r24, Y+9	; 0x09
    598e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5990:	20 e0       	ldi	r18, 0x00	; 0
    5992:	3f ef       	ldi	r19, 0xFF	; 255
    5994:	4f e7       	ldi	r20, 0x7F	; 127
    5996:	57 e4       	ldi	r21, 0x47	; 71
    5998:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    599c:	18 16       	cp	r1, r24
    599e:	4c f5       	brge	.+82     	; 0x59f2 <LCD_Fun+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    59a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    59a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    59a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    59a8:	20 e0       	ldi	r18, 0x00	; 0
    59aa:	30 e0       	ldi	r19, 0x00	; 0
    59ac:	40 e2       	ldi	r20, 0x20	; 32
    59ae:	51 e4       	ldi	r21, 0x41	; 65
    59b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    59b4:	dc 01       	movw	r26, r24
    59b6:	cb 01       	movw	r24, r22
    59b8:	bc 01       	movw	r22, r24
    59ba:	cd 01       	movw	r24, r26
    59bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    59c0:	dc 01       	movw	r26, r24
    59c2:	cb 01       	movw	r24, r22
    59c4:	9e 83       	std	Y+6, r25	; 0x06
    59c6:	8d 83       	std	Y+5, r24	; 0x05
    59c8:	0f c0       	rjmp	.+30     	; 0x59e8 <LCD_Fun+0xfc>
    59ca:	80 e9       	ldi	r24, 0x90	; 144
    59cc:	91 e0       	ldi	r25, 0x01	; 1
    59ce:	9c 83       	std	Y+4, r25	; 0x04
    59d0:	8b 83       	std	Y+3, r24	; 0x03
    59d2:	8b 81       	ldd	r24, Y+3	; 0x03
    59d4:	9c 81       	ldd	r25, Y+4	; 0x04
    59d6:	01 97       	sbiw	r24, 0x01	; 1
    59d8:	f1 f7       	brne	.-4      	; 0x59d6 <LCD_Fun+0xea>
    59da:	9c 83       	std	Y+4, r25	; 0x04
    59dc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    59de:	8d 81       	ldd	r24, Y+5	; 0x05
    59e0:	9e 81       	ldd	r25, Y+6	; 0x06
    59e2:	01 97       	sbiw	r24, 0x01	; 1
    59e4:	9e 83       	std	Y+6, r25	; 0x06
    59e6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    59e8:	8d 81       	ldd	r24, Y+5	; 0x05
    59ea:	9e 81       	ldd	r25, Y+6	; 0x06
    59ec:	00 97       	sbiw	r24, 0x00	; 0
    59ee:	69 f7       	brne	.-38     	; 0x59ca <LCD_Fun+0xde>
    59f0:	14 c0       	rjmp	.+40     	; 0x5a1a <LCD_Fun+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    59f2:	6f 81       	ldd	r22, Y+7	; 0x07
    59f4:	78 85       	ldd	r23, Y+8	; 0x08
    59f6:	89 85       	ldd	r24, Y+9	; 0x09
    59f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    59fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    59fe:	dc 01       	movw	r26, r24
    5a00:	cb 01       	movw	r24, r22
    5a02:	9e 83       	std	Y+6, r25	; 0x06
    5a04:	8d 83       	std	Y+5, r24	; 0x05
    5a06:	8d 81       	ldd	r24, Y+5	; 0x05
    5a08:	9e 81       	ldd	r25, Y+6	; 0x06
    5a0a:	9a 83       	std	Y+2, r25	; 0x02
    5a0c:	89 83       	std	Y+1, r24	; 0x01
    5a0e:	89 81       	ldd	r24, Y+1	; 0x01
    5a10:	9a 81       	ldd	r25, Y+2	; 0x02
    5a12:	01 97       	sbiw	r24, 0x01	; 1
    5a14:	f1 f7       	brne	.-4      	; 0x5a12 <LCD_Fun+0x126>
    5a16:	9a 83       	std	Y+2, r25	; 0x02
    5a18:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(10);
	LCD_GotoXY(1,1);
    5a1a:	81 e0       	ldi	r24, 0x01	; 1
    5a1c:	61 e0       	ldi	r22, 0x01	; 1
    5a1e:	0e 94 60 29 	call	0x52c0	; 0x52c0 <LCD_GotoXY>
}
    5a22:	2e 96       	adiw	r28, 0x0e	; 14
    5a24:	0f b6       	in	r0, 0x3f	; 63
    5a26:	f8 94       	cli
    5a28:	de bf       	out	0x3e, r29	; 62
    5a2a:	0f be       	out	0x3f, r0	; 63
    5a2c:	cd bf       	out	0x3d, r28	; 61
    5a2e:	cf 91       	pop	r28
    5a30:	df 91       	pop	r29
    5a32:	08 95       	ret

00005a34 <Led_Init>:
*  Author: MahmoudH
*/
#include "board.h"

/* Led */
void Led_Init(Led_Num ledNo){
    5a34:	df 93       	push	r29
    5a36:	cf 93       	push	r28
    5a38:	0f 92       	push	r0
    5a3a:	cd b7       	in	r28, 0x3d	; 61
    5a3c:	de b7       	in	r29, 0x3e	; 62
    5a3e:	89 83       	std	Y+1, r24	; 0x01
	setBit(LEDS_DDR,ledNo);
    5a40:	aa e3       	ldi	r26, 0x3A	; 58
    5a42:	b0 e0       	ldi	r27, 0x00	; 0
    5a44:	ea e3       	ldi	r30, 0x3A	; 58
    5a46:	f0 e0       	ldi	r31, 0x00	; 0
    5a48:	80 81       	ld	r24, Z
    5a4a:	48 2f       	mov	r20, r24
    5a4c:	89 81       	ldd	r24, Y+1	; 0x01
    5a4e:	28 2f       	mov	r18, r24
    5a50:	30 e0       	ldi	r19, 0x00	; 0
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	90 e0       	ldi	r25, 0x00	; 0
    5a56:	02 c0       	rjmp	.+4      	; 0x5a5c <Led_Init+0x28>
    5a58:	88 0f       	add	r24, r24
    5a5a:	99 1f       	adc	r25, r25
    5a5c:	2a 95       	dec	r18
    5a5e:	e2 f7       	brpl	.-8      	; 0x5a58 <Led_Init+0x24>
    5a60:	84 2b       	or	r24, r20
    5a62:	8c 93       	st	X, r24
	Led_Off(ledNo);
    5a64:	89 81       	ldd	r24, Y+1	; 0x01
    5a66:	0e 94 56 2d 	call	0x5aac	; 0x5aac <Led_Off>
}
    5a6a:	0f 90       	pop	r0
    5a6c:	cf 91       	pop	r28
    5a6e:	df 91       	pop	r29
    5a70:	08 95       	ret

00005a72 <Led_On>:
void Led_On(Led_Num ledNo){
    5a72:	df 93       	push	r29
    5a74:	cf 93       	push	r28
    5a76:	0f 92       	push	r0
    5a78:	cd b7       	in	r28, 0x3d	; 61
    5a7a:	de b7       	in	r29, 0x3e	; 62
    5a7c:	89 83       	std	Y+1, r24	; 0x01
	setBit(LEDS_PORT,ledNo);
    5a7e:	ab e3       	ldi	r26, 0x3B	; 59
    5a80:	b0 e0       	ldi	r27, 0x00	; 0
    5a82:	eb e3       	ldi	r30, 0x3B	; 59
    5a84:	f0 e0       	ldi	r31, 0x00	; 0
    5a86:	80 81       	ld	r24, Z
    5a88:	48 2f       	mov	r20, r24
    5a8a:	89 81       	ldd	r24, Y+1	; 0x01
    5a8c:	28 2f       	mov	r18, r24
    5a8e:	30 e0       	ldi	r19, 0x00	; 0
    5a90:	81 e0       	ldi	r24, 0x01	; 1
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	02 2e       	mov	r0, r18
    5a96:	02 c0       	rjmp	.+4      	; 0x5a9c <Led_On+0x2a>
    5a98:	88 0f       	add	r24, r24
    5a9a:	99 1f       	adc	r25, r25
    5a9c:	0a 94       	dec	r0
    5a9e:	e2 f7       	brpl	.-8      	; 0x5a98 <Led_On+0x26>
    5aa0:	84 2b       	or	r24, r20
    5aa2:	8c 93       	st	X, r24
}
    5aa4:	0f 90       	pop	r0
    5aa6:	cf 91       	pop	r28
    5aa8:	df 91       	pop	r29
    5aaa:	08 95       	ret

00005aac <Led_Off>:
void Led_Off(Led_Num ledNo){
    5aac:	df 93       	push	r29
    5aae:	cf 93       	push	r28
    5ab0:	0f 92       	push	r0
    5ab2:	cd b7       	in	r28, 0x3d	; 61
    5ab4:	de b7       	in	r29, 0x3e	; 62
    5ab6:	89 83       	std	Y+1, r24	; 0x01
	clearBit(LEDS_PORT,ledNo);
    5ab8:	ab e3       	ldi	r26, 0x3B	; 59
    5aba:	b0 e0       	ldi	r27, 0x00	; 0
    5abc:	eb e3       	ldi	r30, 0x3B	; 59
    5abe:	f0 e0       	ldi	r31, 0x00	; 0
    5ac0:	80 81       	ld	r24, Z
    5ac2:	48 2f       	mov	r20, r24
    5ac4:	89 81       	ldd	r24, Y+1	; 0x01
    5ac6:	28 2f       	mov	r18, r24
    5ac8:	30 e0       	ldi	r19, 0x00	; 0
    5aca:	81 e0       	ldi	r24, 0x01	; 1
    5acc:	90 e0       	ldi	r25, 0x00	; 0
    5ace:	02 2e       	mov	r0, r18
    5ad0:	02 c0       	rjmp	.+4      	; 0x5ad6 <Led_Off+0x2a>
    5ad2:	88 0f       	add	r24, r24
    5ad4:	99 1f       	adc	r25, r25
    5ad6:	0a 94       	dec	r0
    5ad8:	e2 f7       	brpl	.-8      	; 0x5ad2 <Led_Off+0x26>
    5ada:	80 95       	com	r24
    5adc:	84 23       	and	r24, r20
    5ade:	8c 93       	st	X, r24
}
    5ae0:	0f 90       	pop	r0
    5ae2:	cf 91       	pop	r28
    5ae4:	df 91       	pop	r29
    5ae6:	08 95       	ret

00005ae8 <Led_Toggle>:
void Led_Toggle(Led_Num ledNo){
    5ae8:	df 93       	push	r29
    5aea:	cf 93       	push	r28
    5aec:	0f 92       	push	r0
    5aee:	cd b7       	in	r28, 0x3d	; 61
    5af0:	de b7       	in	r29, 0x3e	; 62
    5af2:	89 83       	std	Y+1, r24	; 0x01
	toggleBit(LEDS_PORT,ledNo);
    5af4:	ab e3       	ldi	r26, 0x3B	; 59
    5af6:	b0 e0       	ldi	r27, 0x00	; 0
    5af8:	eb e3       	ldi	r30, 0x3B	; 59
    5afa:	f0 e0       	ldi	r31, 0x00	; 0
    5afc:	80 81       	ld	r24, Z
    5afe:	48 2f       	mov	r20, r24
    5b00:	89 81       	ldd	r24, Y+1	; 0x01
    5b02:	28 2f       	mov	r18, r24
    5b04:	30 e0       	ldi	r19, 0x00	; 0
    5b06:	81 e0       	ldi	r24, 0x01	; 1
    5b08:	90 e0       	ldi	r25, 0x00	; 0
    5b0a:	02 2e       	mov	r0, r18
    5b0c:	02 c0       	rjmp	.+4      	; 0x5b12 <Led_Toggle+0x2a>
    5b0e:	88 0f       	add	r24, r24
    5b10:	99 1f       	adc	r25, r25
    5b12:	0a 94       	dec	r0
    5b14:	e2 f7       	brpl	.-8      	; 0x5b0e <Led_Toggle+0x26>
    5b16:	84 27       	eor	r24, r20
    5b18:	8c 93       	st	X, r24
}
    5b1a:	0f 90       	pop	r0
    5b1c:	cf 91       	pop	r28
    5b1e:	df 91       	pop	r29
    5b20:	08 95       	ret

00005b22 <Leds_Init>:

/* Leds */
void Leds_Init(u8 ledMask){
    5b22:	df 93       	push	r29
    5b24:	cf 93       	push	r28
    5b26:	0f 92       	push	r0
    5b28:	cd b7       	in	r28, 0x3d	; 61
    5b2a:	de b7       	in	r29, 0x3e	; 62
    5b2c:	89 83       	std	Y+1, r24	; 0x01
	setBits(LEDS_DDR,ledMask);
    5b2e:	aa e3       	ldi	r26, 0x3A	; 58
    5b30:	b0 e0       	ldi	r27, 0x00	; 0
    5b32:	ea e3       	ldi	r30, 0x3A	; 58
    5b34:	f0 e0       	ldi	r31, 0x00	; 0
    5b36:	90 81       	ld	r25, Z
    5b38:	89 81       	ldd	r24, Y+1	; 0x01
    5b3a:	89 2b       	or	r24, r25
    5b3c:	8c 93       	st	X, r24
	Leds_Off(ledMask);
    5b3e:	89 81       	ldd	r24, Y+1	; 0x01
    5b40:	0e 94 b8 2d 	call	0x5b70	; 0x5b70 <Leds_Off>
}
    5b44:	0f 90       	pop	r0
    5b46:	cf 91       	pop	r28
    5b48:	df 91       	pop	r29
    5b4a:	08 95       	ret

00005b4c <Leds_On>:
void Leds_On(u8 ledMask){
    5b4c:	df 93       	push	r29
    5b4e:	cf 93       	push	r28
    5b50:	0f 92       	push	r0
    5b52:	cd b7       	in	r28, 0x3d	; 61
    5b54:	de b7       	in	r29, 0x3e	; 62
    5b56:	89 83       	std	Y+1, r24	; 0x01
	setBits(LEDS_PORT,ledMask);
    5b58:	ab e3       	ldi	r26, 0x3B	; 59
    5b5a:	b0 e0       	ldi	r27, 0x00	; 0
    5b5c:	eb e3       	ldi	r30, 0x3B	; 59
    5b5e:	f0 e0       	ldi	r31, 0x00	; 0
    5b60:	90 81       	ld	r25, Z
    5b62:	89 81       	ldd	r24, Y+1	; 0x01
    5b64:	89 2b       	or	r24, r25
    5b66:	8c 93       	st	X, r24
}
    5b68:	0f 90       	pop	r0
    5b6a:	cf 91       	pop	r28
    5b6c:	df 91       	pop	r29
    5b6e:	08 95       	ret

00005b70 <Leds_Off>:
void Leds_Off(u8 ledMask){
    5b70:	df 93       	push	r29
    5b72:	cf 93       	push	r28
    5b74:	0f 92       	push	r0
    5b76:	cd b7       	in	r28, 0x3d	; 61
    5b78:	de b7       	in	r29, 0x3e	; 62
    5b7a:	89 83       	std	Y+1, r24	; 0x01
	clearBits(LEDS_PORT,ledMask);
    5b7c:	ab e3       	ldi	r26, 0x3B	; 59
    5b7e:	b0 e0       	ldi	r27, 0x00	; 0
    5b80:	eb e3       	ldi	r30, 0x3B	; 59
    5b82:	f0 e0       	ldi	r31, 0x00	; 0
    5b84:	80 81       	ld	r24, Z
    5b86:	98 2f       	mov	r25, r24
    5b88:	89 81       	ldd	r24, Y+1	; 0x01
    5b8a:	80 95       	com	r24
    5b8c:	89 23       	and	r24, r25
    5b8e:	8c 93       	st	X, r24
}
    5b90:	0f 90       	pop	r0
    5b92:	cf 91       	pop	r28
    5b94:	df 91       	pop	r29
    5b96:	08 95       	ret

00005b98 <Leds_Toggle>:
void Leds_Toggle(u8 ledMask){
    5b98:	df 93       	push	r29
    5b9a:	cf 93       	push	r28
    5b9c:	0f 92       	push	r0
    5b9e:	cd b7       	in	r28, 0x3d	; 61
    5ba0:	de b7       	in	r29, 0x3e	; 62
    5ba2:	89 83       	std	Y+1, r24	; 0x01
	toggleBits(LEDS_PORT,ledMask);
    5ba4:	ab e3       	ldi	r26, 0x3B	; 59
    5ba6:	b0 e0       	ldi	r27, 0x00	; 0
    5ba8:	eb e3       	ldi	r30, 0x3B	; 59
    5baa:	f0 e0       	ldi	r31, 0x00	; 0
    5bac:	90 81       	ld	r25, Z
    5bae:	89 81       	ldd	r24, Y+1	; 0x01
    5bb0:	89 27       	eor	r24, r25
    5bb2:	8c 93       	st	X, r24
}
    5bb4:	0f 90       	pop	r0
    5bb6:	cf 91       	pop	r28
    5bb8:	df 91       	pop	r29
    5bba:	08 95       	ret

00005bbc <Leds_AllInit>:

/* All leds */
void Leds_AllInit(void){
    5bbc:	df 93       	push	r29
    5bbe:	cf 93       	push	r28
    5bc0:	cd b7       	in	r28, 0x3d	; 61
    5bc2:	de b7       	in	r29, 0x3e	; 62
	Leds_Init(LEDS_MSK);
    5bc4:	80 e7       	ldi	r24, 0x70	; 112
    5bc6:	0e 94 91 2d 	call	0x5b22	; 0x5b22 <Leds_Init>
	Leds_AllOff();
    5bca:	0e 94 f4 2d 	call	0x5be8	; 0x5be8 <Leds_AllOff>
}
    5bce:	cf 91       	pop	r28
    5bd0:	df 91       	pop	r29
    5bd2:	08 95       	ret

00005bd4 <Leds_AllOn>:
void Leds_AllOn(void){
    5bd4:	df 93       	push	r29
    5bd6:	cf 93       	push	r28
    5bd8:	cd b7       	in	r28, 0x3d	; 61
    5bda:	de b7       	in	r29, 0x3e	; 62
	Leds_On(LEDS_MSK);
    5bdc:	80 e7       	ldi	r24, 0x70	; 112
    5bde:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <Leds_On>
}
    5be2:	cf 91       	pop	r28
    5be4:	df 91       	pop	r29
    5be6:	08 95       	ret

00005be8 <Leds_AllOff>:
void Leds_AllOff(void){
    5be8:	df 93       	push	r29
    5bea:	cf 93       	push	r28
    5bec:	cd b7       	in	r28, 0x3d	; 61
    5bee:	de b7       	in	r29, 0x3e	; 62
	Leds_Off(LEDS_MSK);
    5bf0:	80 e7       	ldi	r24, 0x70	; 112
    5bf2:	0e 94 b8 2d 	call	0x5b70	; 0x5b70 <Leds_Off>
}
    5bf6:	cf 91       	pop	r28
    5bf8:	df 91       	pop	r29
    5bfa:	08 95       	ret

00005bfc <Leds_AllToggle>:
void Leds_AllToggle(void){
    5bfc:	df 93       	push	r29
    5bfe:	cf 93       	push	r28
    5c00:	cd b7       	in	r28, 0x3d	; 61
    5c02:	de b7       	in	r29, 0x3e	; 62
	Leds_Toggle(LEDS_MSK);
    5c04:	80 e7       	ldi	r24, 0x70	; 112
    5c06:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <Leds_Toggle>
}
    5c0a:	cf 91       	pop	r28
    5c0c:	df 91       	pop	r29
    5c0e:	08 95       	ret

00005c10 <Buz_Init>:

/* Buzzer */
void Buz_Init(void){
    5c10:	df 93       	push	r29
    5c12:	cf 93       	push	r28
    5c14:	cd b7       	in	r28, 0x3d	; 61
    5c16:	de b7       	in	r29, 0x3e	; 62
	setBit(BUZ_DDR, BUZ_PIN);
    5c18:	a4 e3       	ldi	r26, 0x34	; 52
    5c1a:	b0 e0       	ldi	r27, 0x00	; 0
    5c1c:	e4 e3       	ldi	r30, 0x34	; 52
    5c1e:	f0 e0       	ldi	r31, 0x00	; 0
    5c20:	80 81       	ld	r24, Z
    5c22:	80 64       	ori	r24, 0x40	; 64
    5c24:	8c 93       	st	X, r24
	Buz_Off();
    5c26:	0e 94 26 2e 	call	0x5c4c	; 0x5c4c <Buz_Off>
}
    5c2a:	cf 91       	pop	r28
    5c2c:	df 91       	pop	r29
    5c2e:	08 95       	ret

00005c30 <Buz_On>:
void Buz_On(void){
    5c30:	df 93       	push	r29
    5c32:	cf 93       	push	r28
    5c34:	cd b7       	in	r28, 0x3d	; 61
    5c36:	de b7       	in	r29, 0x3e	; 62
	setBit(BUZ_PORT, BUZ_PIN);
    5c38:	a5 e3       	ldi	r26, 0x35	; 53
    5c3a:	b0 e0       	ldi	r27, 0x00	; 0
    5c3c:	e5 e3       	ldi	r30, 0x35	; 53
    5c3e:	f0 e0       	ldi	r31, 0x00	; 0
    5c40:	80 81       	ld	r24, Z
    5c42:	80 64       	ori	r24, 0x40	; 64
    5c44:	8c 93       	st	X, r24
}
    5c46:	cf 91       	pop	r28
    5c48:	df 91       	pop	r29
    5c4a:	08 95       	ret

00005c4c <Buz_Off>:
void Buz_Off(void){
    5c4c:	df 93       	push	r29
    5c4e:	cf 93       	push	r28
    5c50:	cd b7       	in	r28, 0x3d	; 61
    5c52:	de b7       	in	r29, 0x3e	; 62
	clearBit(BUZ_PORT, BUZ_PIN);
    5c54:	a5 e3       	ldi	r26, 0x35	; 53
    5c56:	b0 e0       	ldi	r27, 0x00	; 0
    5c58:	e5 e3       	ldi	r30, 0x35	; 53
    5c5a:	f0 e0       	ldi	r31, 0x00	; 0
    5c5c:	80 81       	ld	r24, Z
    5c5e:	8f 7b       	andi	r24, 0xBF	; 191
    5c60:	8c 93       	st	X, r24
}
    5c62:	cf 91       	pop	r28
    5c64:	df 91       	pop	r29
    5c66:	08 95       	ret

00005c68 <Buz_Toggle>:
void Buz_Toggle(void){
    5c68:	df 93       	push	r29
    5c6a:	cf 93       	push	r28
    5c6c:	cd b7       	in	r28, 0x3d	; 61
    5c6e:	de b7       	in	r29, 0x3e	; 62
	toggleBit(BUZ_PORT, BUZ_PIN);
    5c70:	a5 e3       	ldi	r26, 0x35	; 53
    5c72:	b0 e0       	ldi	r27, 0x00	; 0
    5c74:	e5 e3       	ldi	r30, 0x35	; 53
    5c76:	f0 e0       	ldi	r31, 0x00	; 0
    5c78:	90 81       	ld	r25, Z
    5c7a:	80 e4       	ldi	r24, 0x40	; 64
    5c7c:	89 27       	eor	r24, r25
    5c7e:	8c 93       	st	X, r24
}
    5c80:	cf 91       	pop	r28
    5c82:	df 91       	pop	r29
    5c84:	08 95       	ret

00005c86 <Uart_Init>:
 * Created: 8/19/2021 10:08:13 AM
 *  Author: MahmoudH
 */ 
#include "uart.h"

void	Uart_Init(u32 baudrate){
    5c86:	df 93       	push	r29
    5c88:	cf 93       	push	r28
    5c8a:	00 d0       	rcall	.+0      	; 0x5c8c <Uart_Init+0x6>
    5c8c:	00 d0       	rcall	.+0      	; 0x5c8e <Uart_Init+0x8>
    5c8e:	00 d0       	rcall	.+0      	; 0x5c90 <Uart_Init+0xa>
    5c90:	cd b7       	in	r28, 0x3d	; 61
    5c92:	de b7       	in	r29, 0x3e	; 62
    5c94:	6b 83       	std	Y+3, r22	; 0x03
    5c96:	7c 83       	std	Y+4, r23	; 0x04
    5c98:	8d 83       	std	Y+5, r24	; 0x05
    5c9a:	9e 83       	std	Y+6, r25	; 0x06
	u16 baud = (F_CPU)/((16UL*baudrate)-1);
    5c9c:	8b 81       	ldd	r24, Y+3	; 0x03
    5c9e:	9c 81       	ldd	r25, Y+4	; 0x04
    5ca0:	ad 81       	ldd	r26, Y+5	; 0x05
    5ca2:	be 81       	ldd	r27, Y+6	; 0x06
    5ca4:	88 0f       	add	r24, r24
    5ca6:	99 1f       	adc	r25, r25
    5ca8:	aa 1f       	adc	r26, r26
    5caa:	bb 1f       	adc	r27, r27
    5cac:	88 0f       	add	r24, r24
    5cae:	99 1f       	adc	r25, r25
    5cb0:	aa 1f       	adc	r26, r26
    5cb2:	bb 1f       	adc	r27, r27
    5cb4:	88 0f       	add	r24, r24
    5cb6:	99 1f       	adc	r25, r25
    5cb8:	aa 1f       	adc	r26, r26
    5cba:	bb 1f       	adc	r27, r27
    5cbc:	88 0f       	add	r24, r24
    5cbe:	99 1f       	adc	r25, r25
    5cc0:	aa 1f       	adc	r26, r26
    5cc2:	bb 1f       	adc	r27, r27
    5cc4:	9c 01       	movw	r18, r24
    5cc6:	ad 01       	movw	r20, r26
    5cc8:	21 50       	subi	r18, 0x01	; 1
    5cca:	30 40       	sbci	r19, 0x00	; 0
    5ccc:	40 40       	sbci	r20, 0x00	; 0
    5cce:	50 40       	sbci	r21, 0x00	; 0
    5cd0:	80 e0       	ldi	r24, 0x00	; 0
    5cd2:	94 e2       	ldi	r25, 0x24	; 36
    5cd4:	a4 ef       	ldi	r26, 0xF4	; 244
    5cd6:	b0 e0       	ldi	r27, 0x00	; 0
    5cd8:	bc 01       	movw	r22, r24
    5cda:	cd 01       	movw	r24, r26
    5cdc:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <__udivmodsi4>
    5ce0:	da 01       	movw	r26, r20
    5ce2:	c9 01       	movw	r24, r18
    5ce4:	9a 83       	std	Y+2, r25	; 0x02
    5ce6:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
	UBRRH = (unsigned char)(baud>>8);
    5ce8:	e0 e4       	ldi	r30, 0x40	; 64
    5cea:	f0 e0       	ldi	r31, 0x00	; 0
    5cec:	89 81       	ldd	r24, Y+1	; 0x01
    5cee:	9a 81       	ldd	r25, Y+2	; 0x02
    5cf0:	89 2f       	mov	r24, r25
    5cf2:	99 27       	eor	r25, r25
    5cf4:	80 83       	st	Z, r24
	UBRRL = (unsigned char)baud;
    5cf6:	e9 e2       	ldi	r30, 0x29	; 41
    5cf8:	f0 e0       	ldi	r31, 0x00	; 0
    5cfa:	89 81       	ldd	r24, Y+1	; 0x01
    5cfc:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);
    5cfe:	ea e2       	ldi	r30, 0x2A	; 42
    5d00:	f0 e0       	ldi	r31, 0x00	; 0
    5d02:	88 e1       	ldi	r24, 0x18	; 24
    5d04:	80 83       	st	Z, r24
	/* Set frame format: 8data, 1stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
    5d06:	e0 e4       	ldi	r30, 0x40	; 64
    5d08:	f0 e0       	ldi	r31, 0x00	; 0
    5d0a:	86 e8       	ldi	r24, 0x86	; 134
    5d0c:	80 83       	st	Z, r24
}
    5d0e:	26 96       	adiw	r28, 0x06	; 6
    5d10:	0f b6       	in	r0, 0x3f	; 63
    5d12:	f8 94       	cli
    5d14:	de bf       	out	0x3e, r29	; 62
    5d16:	0f be       	out	0x3f, r0	; 63
    5d18:	cd bf       	out	0x3d, r28	; 61
    5d1a:	cf 91       	pop	r28
    5d1c:	df 91       	pop	r29
    5d1e:	08 95       	ret

00005d20 <Uart_SendByte>:
void	Uart_SendByte(u8 data){
    5d20:	df 93       	push	r29
    5d22:	cf 93       	push	r28
    5d24:	0f 92       	push	r0
    5d26:	cd b7       	in	r28, 0x3d	; 61
    5d28:	de b7       	in	r29, 0x3e	; 62
    5d2a:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
    5d2c:	eb e2       	ldi	r30, 0x2B	; 43
    5d2e:	f0 e0       	ldi	r31, 0x00	; 0
    5d30:	80 81       	ld	r24, Z
    5d32:	88 2f       	mov	r24, r24
    5d34:	90 e0       	ldi	r25, 0x00	; 0
    5d36:	80 72       	andi	r24, 0x20	; 32
    5d38:	90 70       	andi	r25, 0x00	; 0
    5d3a:	00 97       	sbiw	r24, 0x00	; 0
    5d3c:	b9 f3       	breq	.-18     	; 0x5d2c <Uart_SendByte+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
    5d3e:	ec e2       	ldi	r30, 0x2C	; 44
    5d40:	f0 e0       	ldi	r31, 0x00	; 0
    5d42:	89 81       	ldd	r24, Y+1	; 0x01
    5d44:	80 83       	st	Z, r24
}
    5d46:	0f 90       	pop	r0
    5d48:	cf 91       	pop	r28
    5d4a:	df 91       	pop	r29
    5d4c:	08 95       	ret

00005d4e <Uart_ReceiveByte>:
u8		Uart_ReceiveByte(void){
    5d4e:	df 93       	push	r29
    5d50:	cf 93       	push	r28
    5d52:	cd b7       	in	r28, 0x3d	; 61
    5d54:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    5d56:	eb e2       	ldi	r30, 0x2B	; 43
    5d58:	f0 e0       	ldi	r31, 0x00	; 0
    5d5a:	80 81       	ld	r24, Z
    5d5c:	88 23       	and	r24, r24
    5d5e:	dc f7       	brge	.-10     	; 0x5d56 <Uart_ReceiveByte+0x8>
	/* Get and return received data from buffer */
	return UDR;
    5d60:	ec e2       	ldi	r30, 0x2C	; 44
    5d62:	f0 e0       	ldi	r31, 0x00	; 0
    5d64:	80 81       	ld	r24, Z
}
    5d66:	cf 91       	pop	r28
    5d68:	df 91       	pop	r29
    5d6a:	08 95       	ret

00005d6c <Uart_ReceiveByte_unblock>:
Bool	Uart_ReceiveByte_unblock(u8* pData){
    5d6c:	df 93       	push	r29
    5d6e:	cf 93       	push	r28
    5d70:	00 d0       	rcall	.+0      	; 0x5d72 <Uart_ReceiveByte_unblock+0x6>
    5d72:	0f 92       	push	r0
    5d74:	cd b7       	in	r28, 0x3d	; 61
    5d76:	de b7       	in	r29, 0x3e	; 62
    5d78:	9b 83       	std	Y+3, r25	; 0x03
    5d7a:	8a 83       	std	Y+2, r24	; 0x02
	Bool result = FALSE;
    5d7c:	19 82       	std	Y+1, r1	; 0x01
	if ( UCSRA & (1<<RXC) ){
    5d7e:	eb e2       	ldi	r30, 0x2B	; 43
    5d80:	f0 e0       	ldi	r31, 0x00	; 0
    5d82:	80 81       	ld	r24, Z
    5d84:	88 23       	and	r24, r24
    5d86:	4c f4       	brge	.+18     	; 0x5d9a <Uart_ReceiveByte_unblock+0x2e>
		(*pData) = UDR;
    5d88:	ec e2       	ldi	r30, 0x2C	; 44
    5d8a:	f0 e0       	ldi	r31, 0x00	; 0
    5d8c:	80 81       	ld	r24, Z
    5d8e:	ea 81       	ldd	r30, Y+2	; 0x02
    5d90:	fb 81       	ldd	r31, Y+3	; 0x03
    5d92:	80 83       	st	Z, r24
		result =  TRUE;		
    5d94:	81 e0       	ldi	r24, 0x01	; 1
    5d96:	89 83       	std	Y+1, r24	; 0x01
    5d98:	01 c0       	rjmp	.+2      	; 0x5d9c <Uart_ReceiveByte_unblock+0x30>
	}
	else{
		result = FALSE;
    5d9a:	19 82       	std	Y+1, r1	; 0x01
	}
	return result;
    5d9c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d9e:	0f 90       	pop	r0
    5da0:	0f 90       	pop	r0
    5da2:	0f 90       	pop	r0
    5da4:	cf 91       	pop	r28
    5da6:	df 91       	pop	r29
    5da8:	08 95       	ret

00005daa <Uart_SendStr>:

void	Uart_SendStr(u8* str){
    5daa:	df 93       	push	r29
    5dac:	cf 93       	push	r28
    5dae:	00 d0       	rcall	.+0      	; 0x5db0 <Uart_SendStr+0x6>
    5db0:	00 d0       	rcall	.+0      	; 0x5db2 <Uart_SendStr+0x8>
    5db2:	00 d0       	rcall	.+0      	; 0x5db4 <Uart_SendStr+0xa>
    5db4:	cd b7       	in	r28, 0x3d	; 61
    5db6:	de b7       	in	r29, 0x3e	; 62
    5db8:	9e 83       	std	Y+6, r25	; 0x06
    5dba:	8d 83       	std	Y+5, r24	; 0x05
	u32 ind = 0;
    5dbc:	19 82       	std	Y+1, r1	; 0x01
    5dbe:	1a 82       	std	Y+2, r1	; 0x02
    5dc0:	1b 82       	std	Y+3, r1	; 0x03
    5dc2:	1c 82       	std	Y+4, r1	; 0x04
    5dc4:	15 c0       	rjmp	.+42     	; 0x5df0 <Uart_SendStr+0x46>
	while(str[ind] != 0){
		Uart_SendByte(str[ind]);
    5dc6:	29 81       	ldd	r18, Y+1	; 0x01
    5dc8:	3a 81       	ldd	r19, Y+2	; 0x02
    5dca:	8d 81       	ldd	r24, Y+5	; 0x05
    5dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    5dce:	fc 01       	movw	r30, r24
    5dd0:	e2 0f       	add	r30, r18
    5dd2:	f3 1f       	adc	r31, r19
    5dd4:	80 81       	ld	r24, Z
    5dd6:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <Uart_SendByte>
		ind++;
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	ab 81       	ldd	r26, Y+3	; 0x03
    5de0:	bc 81       	ldd	r27, Y+4	; 0x04
    5de2:	01 96       	adiw	r24, 0x01	; 1
    5de4:	a1 1d       	adc	r26, r1
    5de6:	b1 1d       	adc	r27, r1
    5de8:	89 83       	std	Y+1, r24	; 0x01
    5dea:	9a 83       	std	Y+2, r25	; 0x02
    5dec:	ab 83       	std	Y+3, r26	; 0x03
    5dee:	bc 83       	std	Y+4, r27	; 0x04
	return result;
}

void	Uart_SendStr(u8* str){
	u32 ind = 0;
	while(str[ind] != 0){
    5df0:	29 81       	ldd	r18, Y+1	; 0x01
    5df2:	3a 81       	ldd	r19, Y+2	; 0x02
    5df4:	8d 81       	ldd	r24, Y+5	; 0x05
    5df6:	9e 81       	ldd	r25, Y+6	; 0x06
    5df8:	fc 01       	movw	r30, r24
    5dfa:	e2 0f       	add	r30, r18
    5dfc:	f3 1f       	adc	r31, r19
    5dfe:	80 81       	ld	r24, Z
    5e00:	88 23       	and	r24, r24
    5e02:	09 f7       	brne	.-62     	; 0x5dc6 <Uart_SendStr+0x1c>
		Uart_SendByte(str[ind]);
		ind++;
	}
    5e04:	26 96       	adiw	r28, 0x06	; 6
    5e06:	0f b6       	in	r0, 0x3f	; 63
    5e08:	f8 94       	cli
    5e0a:	de bf       	out	0x3e, r29	; 62
    5e0c:	0f be       	out	0x3f, r0	; 63
    5e0e:	cd bf       	out	0x3d, r28	; 61
    5e10:	cf 91       	pop	r28
    5e12:	df 91       	pop	r29
    5e14:	08 95       	ret

00005e16 <main>:
xSemaphoreHandle BmUART = NULL;
/*this line to define pointer to the shared event */
 

int main(void)
{
    5e16:	af 92       	push	r10
    5e18:	bf 92       	push	r11
    5e1a:	cf 92       	push	r12
    5e1c:	df 92       	push	r13
    5e1e:	ef 92       	push	r14
    5e20:	ff 92       	push	r15
    5e22:	0f 93       	push	r16
    5e24:	df 93       	push	r29
    5e26:	cf 93       	push	r28
    5e28:	cd b7       	in	r28, 0x3d	; 61
    5e2a:	de b7       	in	r29, 0x3e	; 62
	system_int();
    5e2c:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <system_int>
	/*create semaphore for the event */
	BmUART = xSemaphoreCreateMutex();
    5e30:	81 e0       	ldi	r24, 0x01	; 1
    5e32:	0e 94 8c 13 	call	0x2718	; 0x2718 <xQueueCreateMutex>
    5e36:	90 93 f1 05 	sts	0x05F1, r25
    5e3a:	80 93 f0 05 	sts	0x05F0, r24

	xTaskCreate(T_T1,NULL,100,NULL,2,NULL);
    5e3e:	8e e7       	ldi	r24, 0x7E	; 126
    5e40:	9f e2       	ldi	r25, 0x2F	; 47
    5e42:	60 e0       	ldi	r22, 0x00	; 0
    5e44:	70 e0       	ldi	r23, 0x00	; 0
    5e46:	44 e6       	ldi	r20, 0x64	; 100
    5e48:	50 e0       	ldi	r21, 0x00	; 0
    5e4a:	20 e0       	ldi	r18, 0x00	; 0
    5e4c:	30 e0       	ldi	r19, 0x00	; 0
    5e4e:	02 e0       	ldi	r16, 0x02	; 2
    5e50:	ee 24       	eor	r14, r14
    5e52:	ff 24       	eor	r15, r15
    5e54:	cc 24       	eor	r12, r12
    5e56:	dd 24       	eor	r13, r13
    5e58:	aa 24       	eor	r10, r10
    5e5a:	bb 24       	eor	r11, r11
    5e5c:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>
	xTaskCreate(T_T2,NULL,100,NULL,3,NULL);
    5e60:	84 ea       	ldi	r24, 0xA4	; 164
    5e62:	9f e2       	ldi	r25, 0x2F	; 47
    5e64:	60 e0       	ldi	r22, 0x00	; 0
    5e66:	70 e0       	ldi	r23, 0x00	; 0
    5e68:	44 e6       	ldi	r20, 0x64	; 100
    5e6a:	50 e0       	ldi	r21, 0x00	; 0
    5e6c:	20 e0       	ldi	r18, 0x00	; 0
    5e6e:	30 e0       	ldi	r19, 0x00	; 0
    5e70:	03 e0       	ldi	r16, 0x03	; 3
    5e72:	ee 24       	eor	r14, r14
    5e74:	ff 24       	eor	r15, r15
    5e76:	cc 24       	eor	r12, r12
    5e78:	dd 24       	eor	r13, r13
    5e7a:	aa 24       	eor	r10, r10
    5e7c:	bb 24       	eor	r11, r11
    5e7e:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>
	xTaskCreate(T_T3,NULL,100,NULL,1,NULL);
    5e82:	8e ec       	ldi	r24, 0xCE	; 206
    5e84:	9f e2       	ldi	r25, 0x2F	; 47
    5e86:	60 e0       	ldi	r22, 0x00	; 0
    5e88:	70 e0       	ldi	r23, 0x00	; 0
    5e8a:	44 e6       	ldi	r20, 0x64	; 100
    5e8c:	50 e0       	ldi	r21, 0x00	; 0
    5e8e:	20 e0       	ldi	r18, 0x00	; 0
    5e90:	30 e0       	ldi	r19, 0x00	; 0
    5e92:	01 e0       	ldi	r16, 0x01	; 1
    5e94:	ee 24       	eor	r14, r14
    5e96:	ff 24       	eor	r15, r15
    5e98:	cc 24       	eor	r12, r12
    5e9a:	dd 24       	eor	r13, r13
    5e9c:	aa 24       	eor	r10, r10
    5e9e:	bb 24       	eor	r11, r11
    5ea0:	0e 94 55 1a 	call	0x34aa	; 0x34aa <xTaskGenericCreate>

	vTaskStartScheduler();
    5ea4:	0e 94 40 1d 	call	0x3a80	; 0x3a80 <vTaskStartScheduler>

	return 0;
    5ea8:	80 e0       	ldi	r24, 0x00	; 0
    5eaa:	90 e0       	ldi	r25, 0x00	; 0
}
    5eac:	cf 91       	pop	r28
    5eae:	df 91       	pop	r29
    5eb0:	0f 91       	pop	r16
    5eb2:	ff 90       	pop	r15
    5eb4:	ef 90       	pop	r14
    5eb6:	df 90       	pop	r13
    5eb8:	cf 90       	pop	r12
    5eba:	bf 90       	pop	r11
    5ebc:	af 90       	pop	r10
    5ebe:	08 95       	ret

00005ec0 <system_int>:
void system_int (void)
{
    5ec0:	df 93       	push	r29
    5ec2:	cf 93       	push	r28
    5ec4:	cd b7       	in	r28, 0x3d	; 61
    5ec6:	de b7       	in	r29, 0x3e	; 62
	Uart_Init(9600);
    5ec8:	60 e8       	ldi	r22, 0x80	; 128
    5eca:	75 e2       	ldi	r23, 0x25	; 37
    5ecc:	80 e0       	ldi	r24, 0x00	; 0
    5ece:	90 e0       	ldi	r25, 0x00	; 0
    5ed0:	0e 94 43 2e 	call	0x5c86	; 0x5c86 <Uart_Init>
	Leds_AllInit();
    5ed4:	0e 94 de 2d 	call	0x5bbc	; 0x5bbc <Leds_AllInit>
	LCD_Init();
    5ed8:	0e 94 8f 2a 	call	0x551e	; 0x551e <LCD_Init>
	LCD_DispStrXY(1,1,"started");
    5edc:	23 e8       	ldi	r18, 0x83	; 131
    5ede:	30 e0       	ldi	r19, 0x00	; 0
    5ee0:	81 e0       	ldi	r24, 0x01	; 1
    5ee2:	61 e0       	ldi	r22, 0x01	; 1
    5ee4:	a9 01       	movw	r20, r18
    5ee6:	0e 94 89 2b 	call	0x5712	; 0x5712 <LCD_DispStrXY>
	Key_Init();
    5eea:	0e 94 f5 24 	call	0x49ea	; 0x49ea <Key_Init>
	Uart_SendStr("Res App:");
    5eee:	8b e8       	ldi	r24, 0x8B	; 139
    5ef0:	90 e0       	ldi	r25, 0x00	; 0
    5ef2:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <Uart_SendStr>
}
    5ef6:	cf 91       	pop	r28
    5ef8:	df 91       	pop	r29
    5efa:	08 95       	ret

00005efc <T_T1>:

void T_T1(void *pvParameter)
{
    5efc:	df 93       	push	r29
    5efe:	cf 93       	push	r28
    5f00:	00 d0       	rcall	.+0      	; 0x5f02 <T_T1+0x6>
    5f02:	cd b7       	in	r28, 0x3d	; 61
    5f04:	de b7       	in	r29, 0x3e	; 62
    5f06:	9a 83       	std	Y+2, r25	; 0x02
    5f08:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(BmUART,portMAX_DELAY));
    5f0a:	80 91 f0 05 	lds	r24, 0x05F0
    5f0e:	90 91 f1 05 	lds	r25, 0x05F1
    5f12:	60 e0       	ldi	r22, 0x00	; 0
    5f14:	70 e0       	ldi	r23, 0x00	; 0
    5f16:	4f ef       	ldi	r20, 0xFF	; 255
    5f18:	5f ef       	ldi	r21, 0xFF	; 255
    5f1a:	20 e0       	ldi	r18, 0x00	; 0
    5f1c:	0e 94 08 15 	call	0x2a10	; 0x2a10 <xQueueGenericReceive>
		{
			Uart_SendStr("AT+SMS1\r\n");
    5f20:	84 e9       	ldi	r24, 0x94	; 148
    5f22:	90 e0       	ldi	r25, 0x00	; 0
    5f24:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <Uart_SendStr>
			Uart_SendStr("AT+SMS2\r\n");
    5f28:	8e e9       	ldi	r24, 0x9E	; 158
    5f2a:	90 e0       	ldi	r25, 0x00	; 0
    5f2c:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <Uart_SendStr>
			xSemaphoreGive(BmUART);
    5f30:	80 91 f0 05 	lds	r24, 0x05F0
    5f34:	90 91 f1 05 	lds	r25, 0x05F1
    5f38:	60 e0       	ldi	r22, 0x00	; 0
    5f3a:	70 e0       	ldi	r23, 0x00	; 0
    5f3c:	40 e0       	ldi	r20, 0x00	; 0
    5f3e:	50 e0       	ldi	r21, 0x00	; 0
    5f40:	20 e0       	ldi	r18, 0x00	; 0
    5f42:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <xQueueGenericSend>
    5f46:	e1 cf       	rjmp	.-62     	; 0x5f0a <T_T1+0xe>

00005f48 <T_T2>:
		}
		
	}
}
void T_T2(void *pvParameter)
{
    5f48:	df 93       	push	r29
    5f4a:	cf 93       	push	r28
    5f4c:	00 d0       	rcall	.+0      	; 0x5f4e <T_T2+0x6>
    5f4e:	cd b7       	in	r28, 0x3d	; 61
    5f50:	de b7       	in	r29, 0x3e	; 62
    5f52:	9a 83       	std	Y+2, r25	; 0x02
    5f54:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(BmUART,portMAX_DELAY));
    5f56:	80 91 f0 05 	lds	r24, 0x05F0
    5f5a:	90 91 f1 05 	lds	r25, 0x05F1
    5f5e:	60 e0       	ldi	r22, 0x00	; 0
    5f60:	70 e0       	ldi	r23, 0x00	; 0
    5f62:	4f ef       	ldi	r20, 0xFF	; 255
    5f64:	5f ef       	ldi	r21, 0xFF	; 255
    5f66:	20 e0       	ldi	r18, 0x00	; 0
    5f68:	0e 94 08 15 	call	0x2a10	; 0x2a10 <xQueueGenericReceive>
		{
			Uart_SendStr("AT+Server1\r\n");
    5f6c:	88 ea       	ldi	r24, 0xA8	; 168
    5f6e:	90 e0       	ldi	r25, 0x00	; 0
    5f70:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <Uart_SendStr>
			Uart_SendStr("AT+Server2\r\n");
    5f74:	85 eb       	ldi	r24, 0xB5	; 181
    5f76:	90 e0       	ldi	r25, 0x00	; 0
    5f78:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <Uart_SendStr>
			xSemaphoreGive(BmUART);
    5f7c:	80 91 f0 05 	lds	r24, 0x05F0
    5f80:	90 91 f1 05 	lds	r25, 0x05F1
    5f84:	60 e0       	ldi	r22, 0x00	; 0
    5f86:	70 e0       	ldi	r23, 0x00	; 0
    5f88:	40 e0       	ldi	r20, 0x00	; 0
    5f8a:	50 e0       	ldi	r21, 0x00	; 0
    5f8c:	20 e0       	ldi	r18, 0x00	; 0
    5f8e:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <xQueueGenericSend>
		}
		vTaskDelay(5);
    5f92:	85 e0       	ldi	r24, 0x05	; 5
    5f94:	90 e0       	ldi	r25, 0x00	; 0
    5f96:	0e 94 0f 1c 	call	0x381e	; 0x381e <vTaskDelay>
    5f9a:	dd cf       	rjmp	.-70     	; 0x5f56 <T_T2+0xe>

00005f9c <T_T3>:
	}
}
void T_T3(void *pvParameter)
{
    5f9c:	df 93       	push	r29
    5f9e:	cf 93       	push	r28
    5fa0:	00 d0       	rcall	.+0      	; 0x5fa2 <T_T3+0x6>
    5fa2:	cd b7       	in	r28, 0x3d	; 61
    5fa4:	de b7       	in	r29, 0x3e	; 62
    5fa6:	9a 83       	std	Y+2, r25	; 0x02
    5fa8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		Led_Toggle(LED_GREEN);
    5faa:	84 e0       	ldi	r24, 0x04	; 4
    5fac:	0e 94 74 2d 	call	0x5ae8	; 0x5ae8 <Led_Toggle>
		vTaskDelay(300);
    5fb0:	8c e2       	ldi	r24, 0x2C	; 44
    5fb2:	91 e0       	ldi	r25, 0x01	; 1
    5fb4:	0e 94 0f 1c 	call	0x381e	; 0x381e <vTaskDelay>
    5fb8:	f8 cf       	rjmp	.-16     	; 0x5faa <T_T3+0xe>

00005fba <__mulsi3>:
    5fba:	62 9f       	mul	r22, r18
    5fbc:	d0 01       	movw	r26, r0
    5fbe:	73 9f       	mul	r23, r19
    5fc0:	f0 01       	movw	r30, r0
    5fc2:	82 9f       	mul	r24, r18
    5fc4:	e0 0d       	add	r30, r0
    5fc6:	f1 1d       	adc	r31, r1
    5fc8:	64 9f       	mul	r22, r20
    5fca:	e0 0d       	add	r30, r0
    5fcc:	f1 1d       	adc	r31, r1
    5fce:	92 9f       	mul	r25, r18
    5fd0:	f0 0d       	add	r31, r0
    5fd2:	83 9f       	mul	r24, r19
    5fd4:	f0 0d       	add	r31, r0
    5fd6:	74 9f       	mul	r23, r20
    5fd8:	f0 0d       	add	r31, r0
    5fda:	65 9f       	mul	r22, r21
    5fdc:	f0 0d       	add	r31, r0
    5fde:	99 27       	eor	r25, r25
    5fe0:	72 9f       	mul	r23, r18
    5fe2:	b0 0d       	add	r27, r0
    5fe4:	e1 1d       	adc	r30, r1
    5fe6:	f9 1f       	adc	r31, r25
    5fe8:	63 9f       	mul	r22, r19
    5fea:	b0 0d       	add	r27, r0
    5fec:	e1 1d       	adc	r30, r1
    5fee:	f9 1f       	adc	r31, r25
    5ff0:	bd 01       	movw	r22, r26
    5ff2:	cf 01       	movw	r24, r30
    5ff4:	11 24       	eor	r1, r1
    5ff6:	08 95       	ret

00005ff8 <__udivmodsi4>:
    5ff8:	a1 e2       	ldi	r26, 0x21	; 33
    5ffa:	1a 2e       	mov	r1, r26
    5ffc:	aa 1b       	sub	r26, r26
    5ffe:	bb 1b       	sub	r27, r27
    6000:	fd 01       	movw	r30, r26
    6002:	0d c0       	rjmp	.+26     	; 0x601e <__udivmodsi4_ep>

00006004 <__udivmodsi4_loop>:
    6004:	aa 1f       	adc	r26, r26
    6006:	bb 1f       	adc	r27, r27
    6008:	ee 1f       	adc	r30, r30
    600a:	ff 1f       	adc	r31, r31
    600c:	a2 17       	cp	r26, r18
    600e:	b3 07       	cpc	r27, r19
    6010:	e4 07       	cpc	r30, r20
    6012:	f5 07       	cpc	r31, r21
    6014:	20 f0       	brcs	.+8      	; 0x601e <__udivmodsi4_ep>
    6016:	a2 1b       	sub	r26, r18
    6018:	b3 0b       	sbc	r27, r19
    601a:	e4 0b       	sbc	r30, r20
    601c:	f5 0b       	sbc	r31, r21

0000601e <__udivmodsi4_ep>:
    601e:	66 1f       	adc	r22, r22
    6020:	77 1f       	adc	r23, r23
    6022:	88 1f       	adc	r24, r24
    6024:	99 1f       	adc	r25, r25
    6026:	1a 94       	dec	r1
    6028:	69 f7       	brne	.-38     	; 0x6004 <__udivmodsi4_loop>
    602a:	60 95       	com	r22
    602c:	70 95       	com	r23
    602e:	80 95       	com	r24
    6030:	90 95       	com	r25
    6032:	9b 01       	movw	r18, r22
    6034:	ac 01       	movw	r20, r24
    6036:	bd 01       	movw	r22, r26
    6038:	cf 01       	movw	r24, r30
    603a:	08 95       	ret

0000603c <__divmodsi4>:
    603c:	97 fb       	bst	r25, 7
    603e:	09 2e       	mov	r0, r25
    6040:	05 26       	eor	r0, r21
    6042:	0e d0       	rcall	.+28     	; 0x6060 <__divmodsi4_neg1>
    6044:	57 fd       	sbrc	r21, 7
    6046:	04 d0       	rcall	.+8      	; 0x6050 <__divmodsi4_neg2>
    6048:	d7 df       	rcall	.-82     	; 0x5ff8 <__udivmodsi4>
    604a:	0a d0       	rcall	.+20     	; 0x6060 <__divmodsi4_neg1>
    604c:	00 1c       	adc	r0, r0
    604e:	38 f4       	brcc	.+14     	; 0x605e <__divmodsi4_exit>

00006050 <__divmodsi4_neg2>:
    6050:	50 95       	com	r21
    6052:	40 95       	com	r20
    6054:	30 95       	com	r19
    6056:	21 95       	neg	r18
    6058:	3f 4f       	sbci	r19, 0xFF	; 255
    605a:	4f 4f       	sbci	r20, 0xFF	; 255
    605c:	5f 4f       	sbci	r21, 0xFF	; 255

0000605e <__divmodsi4_exit>:
    605e:	08 95       	ret

00006060 <__divmodsi4_neg1>:
    6060:	f6 f7       	brtc	.-4      	; 0x605e <__divmodsi4_exit>
    6062:	90 95       	com	r25
    6064:	80 95       	com	r24
    6066:	70 95       	com	r23
    6068:	61 95       	neg	r22
    606a:	7f 4f       	sbci	r23, 0xFF	; 255
    606c:	8f 4f       	sbci	r24, 0xFF	; 255
    606e:	9f 4f       	sbci	r25, 0xFF	; 255
    6070:	08 95       	ret

00006072 <__prologue_saves__>:
    6072:	2f 92       	push	r2
    6074:	3f 92       	push	r3
    6076:	4f 92       	push	r4
    6078:	5f 92       	push	r5
    607a:	6f 92       	push	r6
    607c:	7f 92       	push	r7
    607e:	8f 92       	push	r8
    6080:	9f 92       	push	r9
    6082:	af 92       	push	r10
    6084:	bf 92       	push	r11
    6086:	cf 92       	push	r12
    6088:	df 92       	push	r13
    608a:	ef 92       	push	r14
    608c:	ff 92       	push	r15
    608e:	0f 93       	push	r16
    6090:	1f 93       	push	r17
    6092:	cf 93       	push	r28
    6094:	df 93       	push	r29
    6096:	cd b7       	in	r28, 0x3d	; 61
    6098:	de b7       	in	r29, 0x3e	; 62
    609a:	ca 1b       	sub	r28, r26
    609c:	db 0b       	sbc	r29, r27
    609e:	0f b6       	in	r0, 0x3f	; 63
    60a0:	f8 94       	cli
    60a2:	de bf       	out	0x3e, r29	; 62
    60a4:	0f be       	out	0x3f, r0	; 63
    60a6:	cd bf       	out	0x3d, r28	; 61
    60a8:	09 94       	ijmp

000060aa <__epilogue_restores__>:
    60aa:	2a 88       	ldd	r2, Y+18	; 0x12
    60ac:	39 88       	ldd	r3, Y+17	; 0x11
    60ae:	48 88       	ldd	r4, Y+16	; 0x10
    60b0:	5f 84       	ldd	r5, Y+15	; 0x0f
    60b2:	6e 84       	ldd	r6, Y+14	; 0x0e
    60b4:	7d 84       	ldd	r7, Y+13	; 0x0d
    60b6:	8c 84       	ldd	r8, Y+12	; 0x0c
    60b8:	9b 84       	ldd	r9, Y+11	; 0x0b
    60ba:	aa 84       	ldd	r10, Y+10	; 0x0a
    60bc:	b9 84       	ldd	r11, Y+9	; 0x09
    60be:	c8 84       	ldd	r12, Y+8	; 0x08
    60c0:	df 80       	ldd	r13, Y+7	; 0x07
    60c2:	ee 80       	ldd	r14, Y+6	; 0x06
    60c4:	fd 80       	ldd	r15, Y+5	; 0x05
    60c6:	0c 81       	ldd	r16, Y+4	; 0x04
    60c8:	1b 81       	ldd	r17, Y+3	; 0x03
    60ca:	aa 81       	ldd	r26, Y+2	; 0x02
    60cc:	b9 81       	ldd	r27, Y+1	; 0x01
    60ce:	ce 0f       	add	r28, r30
    60d0:	d1 1d       	adc	r29, r1
    60d2:	0f b6       	in	r0, 0x3f	; 63
    60d4:	f8 94       	cli
    60d6:	de bf       	out	0x3e, r29	; 62
    60d8:	0f be       	out	0x3f, r0	; 63
    60da:	cd bf       	out	0x3d, r28	; 61
    60dc:	ed 01       	movw	r28, r26
    60de:	08 95       	ret

000060e0 <memcpy>:
    60e0:	fb 01       	movw	r30, r22
    60e2:	dc 01       	movw	r26, r24
    60e4:	02 c0       	rjmp	.+4      	; 0x60ea <memcpy+0xa>
    60e6:	01 90       	ld	r0, Z+
    60e8:	0d 92       	st	X+, r0
    60ea:	41 50       	subi	r20, 0x01	; 1
    60ec:	50 40       	sbci	r21, 0x00	; 0
    60ee:	d8 f7       	brcc	.-10     	; 0x60e6 <memcpy+0x6>
    60f0:	08 95       	ret

000060f2 <sprintf>:
    60f2:	ae e0       	ldi	r26, 0x0E	; 14
    60f4:	b0 e0       	ldi	r27, 0x00	; 0
    60f6:	ef e7       	ldi	r30, 0x7F	; 127
    60f8:	f0 e3       	ldi	r31, 0x30	; 48
    60fa:	0c 94 47 30 	jmp	0x608e	; 0x608e <__prologue_saves__+0x1c>
    60fe:	0d 89       	ldd	r16, Y+21	; 0x15
    6100:	1e 89       	ldd	r17, Y+22	; 0x16
    6102:	86 e0       	ldi	r24, 0x06	; 6
    6104:	8c 83       	std	Y+4, r24	; 0x04
    6106:	1a 83       	std	Y+2, r17	; 0x02
    6108:	09 83       	std	Y+1, r16	; 0x01
    610a:	8f ef       	ldi	r24, 0xFF	; 255
    610c:	9f e7       	ldi	r25, 0x7F	; 127
    610e:	9e 83       	std	Y+6, r25	; 0x06
    6110:	8d 83       	std	Y+5, r24	; 0x05
    6112:	9e 01       	movw	r18, r28
    6114:	27 5e       	subi	r18, 0xE7	; 231
    6116:	3f 4f       	sbci	r19, 0xFF	; 255
    6118:	ce 01       	movw	r24, r28
    611a:	01 96       	adiw	r24, 0x01	; 1
    611c:	6f 89       	ldd	r22, Y+23	; 0x17
    611e:	78 8d       	ldd	r23, Y+24	; 0x18
    6120:	a9 01       	movw	r20, r18
    6122:	0e 94 9d 30 	call	0x613a	; 0x613a <vfprintf>
    6126:	2f 81       	ldd	r18, Y+7	; 0x07
    6128:	38 85       	ldd	r19, Y+8	; 0x08
    612a:	02 0f       	add	r16, r18
    612c:	13 1f       	adc	r17, r19
    612e:	f8 01       	movw	r30, r16
    6130:	10 82       	st	Z, r1
    6132:	2e 96       	adiw	r28, 0x0e	; 14
    6134:	e4 e0       	ldi	r30, 0x04	; 4
    6136:	0c 94 63 30 	jmp	0x60c6	; 0x60c6 <__epilogue_restores__+0x1c>

0000613a <vfprintf>:
    613a:	ab e0       	ldi	r26, 0x0B	; 11
    613c:	b0 e0       	ldi	r27, 0x00	; 0
    613e:	e3 ea       	ldi	r30, 0xA3	; 163
    6140:	f0 e3       	ldi	r31, 0x30	; 48
    6142:	0c 94 39 30 	jmp	0x6072	; 0x6072 <__prologue_saves__>
    6146:	3c 01       	movw	r6, r24
    6148:	2b 01       	movw	r4, r22
    614a:	5a 01       	movw	r10, r20
    614c:	fc 01       	movw	r30, r24
    614e:	17 82       	std	Z+7, r1	; 0x07
    6150:	16 82       	std	Z+6, r1	; 0x06
    6152:	83 81       	ldd	r24, Z+3	; 0x03
    6154:	81 fd       	sbrc	r24, 1
    6156:	03 c0       	rjmp	.+6      	; 0x615e <vfprintf+0x24>
    6158:	6f ef       	ldi	r22, 0xFF	; 255
    615a:	7f ef       	ldi	r23, 0xFF	; 255
    615c:	c6 c1       	rjmp	.+908    	; 0x64ea <vfprintf+0x3b0>
    615e:	9a e0       	ldi	r25, 0x0A	; 10
    6160:	89 2e       	mov	r8, r25
    6162:	1e 01       	movw	r2, r28
    6164:	08 94       	sec
    6166:	21 1c       	adc	r2, r1
    6168:	31 1c       	adc	r3, r1
    616a:	f3 01       	movw	r30, r6
    616c:	23 81       	ldd	r18, Z+3	; 0x03
    616e:	f2 01       	movw	r30, r4
    6170:	23 fd       	sbrc	r18, 3
    6172:	85 91       	lpm	r24, Z+
    6174:	23 ff       	sbrs	r18, 3
    6176:	81 91       	ld	r24, Z+
    6178:	2f 01       	movw	r4, r30
    617a:	88 23       	and	r24, r24
    617c:	09 f4       	brne	.+2      	; 0x6180 <vfprintf+0x46>
    617e:	b2 c1       	rjmp	.+868    	; 0x64e4 <vfprintf+0x3aa>
    6180:	85 32       	cpi	r24, 0x25	; 37
    6182:	39 f4       	brne	.+14     	; 0x6192 <vfprintf+0x58>
    6184:	23 fd       	sbrc	r18, 3
    6186:	85 91       	lpm	r24, Z+
    6188:	23 ff       	sbrs	r18, 3
    618a:	81 91       	ld	r24, Z+
    618c:	2f 01       	movw	r4, r30
    618e:	85 32       	cpi	r24, 0x25	; 37
    6190:	29 f4       	brne	.+10     	; 0x619c <vfprintf+0x62>
    6192:	90 e0       	ldi	r25, 0x00	; 0
    6194:	b3 01       	movw	r22, r6
    6196:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    619a:	e7 cf       	rjmp	.-50     	; 0x616a <vfprintf+0x30>
    619c:	98 2f       	mov	r25, r24
    619e:	ff 24       	eor	r15, r15
    61a0:	ee 24       	eor	r14, r14
    61a2:	99 24       	eor	r9, r9
    61a4:	ff e1       	ldi	r31, 0x1F	; 31
    61a6:	ff 15       	cp	r31, r15
    61a8:	d0 f0       	brcs	.+52     	; 0x61de <vfprintf+0xa4>
    61aa:	9b 32       	cpi	r25, 0x2B	; 43
    61ac:	69 f0       	breq	.+26     	; 0x61c8 <vfprintf+0x8e>
    61ae:	9c 32       	cpi	r25, 0x2C	; 44
    61b0:	28 f4       	brcc	.+10     	; 0x61bc <vfprintf+0x82>
    61b2:	90 32       	cpi	r25, 0x20	; 32
    61b4:	59 f0       	breq	.+22     	; 0x61cc <vfprintf+0x92>
    61b6:	93 32       	cpi	r25, 0x23	; 35
    61b8:	91 f4       	brne	.+36     	; 0x61de <vfprintf+0xa4>
    61ba:	0e c0       	rjmp	.+28     	; 0x61d8 <vfprintf+0x9e>
    61bc:	9d 32       	cpi	r25, 0x2D	; 45
    61be:	49 f0       	breq	.+18     	; 0x61d2 <vfprintf+0x98>
    61c0:	90 33       	cpi	r25, 0x30	; 48
    61c2:	69 f4       	brne	.+26     	; 0x61de <vfprintf+0xa4>
    61c4:	41 e0       	ldi	r20, 0x01	; 1
    61c6:	24 c0       	rjmp	.+72     	; 0x6210 <vfprintf+0xd6>
    61c8:	52 e0       	ldi	r21, 0x02	; 2
    61ca:	f5 2a       	or	r15, r21
    61cc:	84 e0       	ldi	r24, 0x04	; 4
    61ce:	f8 2a       	or	r15, r24
    61d0:	28 c0       	rjmp	.+80     	; 0x6222 <vfprintf+0xe8>
    61d2:	98 e0       	ldi	r25, 0x08	; 8
    61d4:	f9 2a       	or	r15, r25
    61d6:	25 c0       	rjmp	.+74     	; 0x6222 <vfprintf+0xe8>
    61d8:	e0 e1       	ldi	r30, 0x10	; 16
    61da:	fe 2a       	or	r15, r30
    61dc:	22 c0       	rjmp	.+68     	; 0x6222 <vfprintf+0xe8>
    61de:	f7 fc       	sbrc	r15, 7
    61e0:	29 c0       	rjmp	.+82     	; 0x6234 <vfprintf+0xfa>
    61e2:	89 2f       	mov	r24, r25
    61e4:	80 53       	subi	r24, 0x30	; 48
    61e6:	8a 30       	cpi	r24, 0x0A	; 10
    61e8:	70 f4       	brcc	.+28     	; 0x6206 <vfprintf+0xcc>
    61ea:	f6 fe       	sbrs	r15, 6
    61ec:	05 c0       	rjmp	.+10     	; 0x61f8 <vfprintf+0xbe>
    61ee:	98 9c       	mul	r9, r8
    61f0:	90 2c       	mov	r9, r0
    61f2:	11 24       	eor	r1, r1
    61f4:	98 0e       	add	r9, r24
    61f6:	15 c0       	rjmp	.+42     	; 0x6222 <vfprintf+0xe8>
    61f8:	e8 9c       	mul	r14, r8
    61fa:	e0 2c       	mov	r14, r0
    61fc:	11 24       	eor	r1, r1
    61fe:	e8 0e       	add	r14, r24
    6200:	f0 e2       	ldi	r31, 0x20	; 32
    6202:	ff 2a       	or	r15, r31
    6204:	0e c0       	rjmp	.+28     	; 0x6222 <vfprintf+0xe8>
    6206:	9e 32       	cpi	r25, 0x2E	; 46
    6208:	29 f4       	brne	.+10     	; 0x6214 <vfprintf+0xda>
    620a:	f6 fc       	sbrc	r15, 6
    620c:	6b c1       	rjmp	.+726    	; 0x64e4 <vfprintf+0x3aa>
    620e:	40 e4       	ldi	r20, 0x40	; 64
    6210:	f4 2a       	or	r15, r20
    6212:	07 c0       	rjmp	.+14     	; 0x6222 <vfprintf+0xe8>
    6214:	9c 36       	cpi	r25, 0x6C	; 108
    6216:	19 f4       	brne	.+6      	; 0x621e <vfprintf+0xe4>
    6218:	50 e8       	ldi	r21, 0x80	; 128
    621a:	f5 2a       	or	r15, r21
    621c:	02 c0       	rjmp	.+4      	; 0x6222 <vfprintf+0xe8>
    621e:	98 36       	cpi	r25, 0x68	; 104
    6220:	49 f4       	brne	.+18     	; 0x6234 <vfprintf+0xfa>
    6222:	f2 01       	movw	r30, r4
    6224:	23 fd       	sbrc	r18, 3
    6226:	95 91       	lpm	r25, Z+
    6228:	23 ff       	sbrs	r18, 3
    622a:	91 91       	ld	r25, Z+
    622c:	2f 01       	movw	r4, r30
    622e:	99 23       	and	r25, r25
    6230:	09 f0       	breq	.+2      	; 0x6234 <vfprintf+0xfa>
    6232:	b8 cf       	rjmp	.-144    	; 0x61a4 <vfprintf+0x6a>
    6234:	89 2f       	mov	r24, r25
    6236:	85 54       	subi	r24, 0x45	; 69
    6238:	83 30       	cpi	r24, 0x03	; 3
    623a:	18 f0       	brcs	.+6      	; 0x6242 <vfprintf+0x108>
    623c:	80 52       	subi	r24, 0x20	; 32
    623e:	83 30       	cpi	r24, 0x03	; 3
    6240:	38 f4       	brcc	.+14     	; 0x6250 <vfprintf+0x116>
    6242:	44 e0       	ldi	r20, 0x04	; 4
    6244:	50 e0       	ldi	r21, 0x00	; 0
    6246:	a4 0e       	add	r10, r20
    6248:	b5 1e       	adc	r11, r21
    624a:	5f e3       	ldi	r21, 0x3F	; 63
    624c:	59 83       	std	Y+1, r21	; 0x01
    624e:	0f c0       	rjmp	.+30     	; 0x626e <vfprintf+0x134>
    6250:	93 36       	cpi	r25, 0x63	; 99
    6252:	31 f0       	breq	.+12     	; 0x6260 <vfprintf+0x126>
    6254:	93 37       	cpi	r25, 0x73	; 115
    6256:	79 f0       	breq	.+30     	; 0x6276 <vfprintf+0x13c>
    6258:	93 35       	cpi	r25, 0x53	; 83
    625a:	09 f0       	breq	.+2      	; 0x625e <vfprintf+0x124>
    625c:	56 c0       	rjmp	.+172    	; 0x630a <vfprintf+0x1d0>
    625e:	20 c0       	rjmp	.+64     	; 0x62a0 <vfprintf+0x166>
    6260:	f5 01       	movw	r30, r10
    6262:	80 81       	ld	r24, Z
    6264:	89 83       	std	Y+1, r24	; 0x01
    6266:	42 e0       	ldi	r20, 0x02	; 2
    6268:	50 e0       	ldi	r21, 0x00	; 0
    626a:	a4 0e       	add	r10, r20
    626c:	b5 1e       	adc	r11, r21
    626e:	61 01       	movw	r12, r2
    6270:	01 e0       	ldi	r16, 0x01	; 1
    6272:	10 e0       	ldi	r17, 0x00	; 0
    6274:	12 c0       	rjmp	.+36     	; 0x629a <vfprintf+0x160>
    6276:	f5 01       	movw	r30, r10
    6278:	c0 80       	ld	r12, Z
    627a:	d1 80       	ldd	r13, Z+1	; 0x01
    627c:	f6 fc       	sbrc	r15, 6
    627e:	03 c0       	rjmp	.+6      	; 0x6286 <vfprintf+0x14c>
    6280:	6f ef       	ldi	r22, 0xFF	; 255
    6282:	7f ef       	ldi	r23, 0xFF	; 255
    6284:	02 c0       	rjmp	.+4      	; 0x628a <vfprintf+0x150>
    6286:	69 2d       	mov	r22, r9
    6288:	70 e0       	ldi	r23, 0x00	; 0
    628a:	42 e0       	ldi	r20, 0x02	; 2
    628c:	50 e0       	ldi	r21, 0x00	; 0
    628e:	a4 0e       	add	r10, r20
    6290:	b5 1e       	adc	r11, r21
    6292:	c6 01       	movw	r24, r12
    6294:	0e 94 85 32 	call	0x650a	; 0x650a <strnlen>
    6298:	8c 01       	movw	r16, r24
    629a:	5f e7       	ldi	r21, 0x7F	; 127
    629c:	f5 22       	and	r15, r21
    629e:	14 c0       	rjmp	.+40     	; 0x62c8 <vfprintf+0x18e>
    62a0:	f5 01       	movw	r30, r10
    62a2:	c0 80       	ld	r12, Z
    62a4:	d1 80       	ldd	r13, Z+1	; 0x01
    62a6:	f6 fc       	sbrc	r15, 6
    62a8:	03 c0       	rjmp	.+6      	; 0x62b0 <vfprintf+0x176>
    62aa:	6f ef       	ldi	r22, 0xFF	; 255
    62ac:	7f ef       	ldi	r23, 0xFF	; 255
    62ae:	02 c0       	rjmp	.+4      	; 0x62b4 <vfprintf+0x17a>
    62b0:	69 2d       	mov	r22, r9
    62b2:	70 e0       	ldi	r23, 0x00	; 0
    62b4:	42 e0       	ldi	r20, 0x02	; 2
    62b6:	50 e0       	ldi	r21, 0x00	; 0
    62b8:	a4 0e       	add	r10, r20
    62ba:	b5 1e       	adc	r11, r21
    62bc:	c6 01       	movw	r24, r12
    62be:	0e 94 7a 32 	call	0x64f4	; 0x64f4 <strnlen_P>
    62c2:	8c 01       	movw	r16, r24
    62c4:	50 e8       	ldi	r21, 0x80	; 128
    62c6:	f5 2a       	or	r15, r21
    62c8:	f3 fe       	sbrs	r15, 3
    62ca:	07 c0       	rjmp	.+14     	; 0x62da <vfprintf+0x1a0>
    62cc:	1a c0       	rjmp	.+52     	; 0x6302 <vfprintf+0x1c8>
    62ce:	80 e2       	ldi	r24, 0x20	; 32
    62d0:	90 e0       	ldi	r25, 0x00	; 0
    62d2:	b3 01       	movw	r22, r6
    62d4:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    62d8:	ea 94       	dec	r14
    62da:	8e 2d       	mov	r24, r14
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	08 17       	cp	r16, r24
    62e0:	19 07       	cpc	r17, r25
    62e2:	a8 f3       	brcs	.-22     	; 0x62ce <vfprintf+0x194>
    62e4:	0e c0       	rjmp	.+28     	; 0x6302 <vfprintf+0x1c8>
    62e6:	f6 01       	movw	r30, r12
    62e8:	f7 fc       	sbrc	r15, 7
    62ea:	85 91       	lpm	r24, Z+
    62ec:	f7 fe       	sbrs	r15, 7
    62ee:	81 91       	ld	r24, Z+
    62f0:	6f 01       	movw	r12, r30
    62f2:	90 e0       	ldi	r25, 0x00	; 0
    62f4:	b3 01       	movw	r22, r6
    62f6:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    62fa:	e1 10       	cpse	r14, r1
    62fc:	ea 94       	dec	r14
    62fe:	01 50       	subi	r16, 0x01	; 1
    6300:	10 40       	sbci	r17, 0x00	; 0
    6302:	01 15       	cp	r16, r1
    6304:	11 05       	cpc	r17, r1
    6306:	79 f7       	brne	.-34     	; 0x62e6 <vfprintf+0x1ac>
    6308:	ea c0       	rjmp	.+468    	; 0x64de <vfprintf+0x3a4>
    630a:	94 36       	cpi	r25, 0x64	; 100
    630c:	11 f0       	breq	.+4      	; 0x6312 <vfprintf+0x1d8>
    630e:	99 36       	cpi	r25, 0x69	; 105
    6310:	69 f5       	brne	.+90     	; 0x636c <vfprintf+0x232>
    6312:	f7 fe       	sbrs	r15, 7
    6314:	08 c0       	rjmp	.+16     	; 0x6326 <vfprintf+0x1ec>
    6316:	f5 01       	movw	r30, r10
    6318:	20 81       	ld	r18, Z
    631a:	31 81       	ldd	r19, Z+1	; 0x01
    631c:	42 81       	ldd	r20, Z+2	; 0x02
    631e:	53 81       	ldd	r21, Z+3	; 0x03
    6320:	84 e0       	ldi	r24, 0x04	; 4
    6322:	90 e0       	ldi	r25, 0x00	; 0
    6324:	0a c0       	rjmp	.+20     	; 0x633a <vfprintf+0x200>
    6326:	f5 01       	movw	r30, r10
    6328:	80 81       	ld	r24, Z
    632a:	91 81       	ldd	r25, Z+1	; 0x01
    632c:	9c 01       	movw	r18, r24
    632e:	44 27       	eor	r20, r20
    6330:	37 fd       	sbrc	r19, 7
    6332:	40 95       	com	r20
    6334:	54 2f       	mov	r21, r20
    6336:	82 e0       	ldi	r24, 0x02	; 2
    6338:	90 e0       	ldi	r25, 0x00	; 0
    633a:	a8 0e       	add	r10, r24
    633c:	b9 1e       	adc	r11, r25
    633e:	9f e6       	ldi	r25, 0x6F	; 111
    6340:	f9 22       	and	r15, r25
    6342:	57 ff       	sbrs	r21, 7
    6344:	09 c0       	rjmp	.+18     	; 0x6358 <vfprintf+0x21e>
    6346:	50 95       	com	r21
    6348:	40 95       	com	r20
    634a:	30 95       	com	r19
    634c:	21 95       	neg	r18
    634e:	3f 4f       	sbci	r19, 0xFF	; 255
    6350:	4f 4f       	sbci	r20, 0xFF	; 255
    6352:	5f 4f       	sbci	r21, 0xFF	; 255
    6354:	e0 e8       	ldi	r30, 0x80	; 128
    6356:	fe 2a       	or	r15, r30
    6358:	ca 01       	movw	r24, r20
    635a:	b9 01       	movw	r22, r18
    635c:	a1 01       	movw	r20, r2
    635e:	2a e0       	ldi	r18, 0x0A	; 10
    6360:	30 e0       	ldi	r19, 0x00	; 0
    6362:	0e 94 bc 32 	call	0x6578	; 0x6578 <__ultoa_invert>
    6366:	d8 2e       	mov	r13, r24
    6368:	d2 18       	sub	r13, r2
    636a:	40 c0       	rjmp	.+128    	; 0x63ec <vfprintf+0x2b2>
    636c:	95 37       	cpi	r25, 0x75	; 117
    636e:	29 f4       	brne	.+10     	; 0x637a <vfprintf+0x240>
    6370:	1f 2d       	mov	r17, r15
    6372:	1f 7e       	andi	r17, 0xEF	; 239
    6374:	2a e0       	ldi	r18, 0x0A	; 10
    6376:	30 e0       	ldi	r19, 0x00	; 0
    6378:	1d c0       	rjmp	.+58     	; 0x63b4 <vfprintf+0x27a>
    637a:	1f 2d       	mov	r17, r15
    637c:	19 7f       	andi	r17, 0xF9	; 249
    637e:	9f 36       	cpi	r25, 0x6F	; 111
    6380:	61 f0       	breq	.+24     	; 0x639a <vfprintf+0x260>
    6382:	90 37       	cpi	r25, 0x70	; 112
    6384:	20 f4       	brcc	.+8      	; 0x638e <vfprintf+0x254>
    6386:	98 35       	cpi	r25, 0x58	; 88
    6388:	09 f0       	breq	.+2      	; 0x638c <vfprintf+0x252>
    638a:	ac c0       	rjmp	.+344    	; 0x64e4 <vfprintf+0x3aa>
    638c:	0f c0       	rjmp	.+30     	; 0x63ac <vfprintf+0x272>
    638e:	90 37       	cpi	r25, 0x70	; 112
    6390:	39 f0       	breq	.+14     	; 0x63a0 <vfprintf+0x266>
    6392:	98 37       	cpi	r25, 0x78	; 120
    6394:	09 f0       	breq	.+2      	; 0x6398 <vfprintf+0x25e>
    6396:	a6 c0       	rjmp	.+332    	; 0x64e4 <vfprintf+0x3aa>
    6398:	04 c0       	rjmp	.+8      	; 0x63a2 <vfprintf+0x268>
    639a:	28 e0       	ldi	r18, 0x08	; 8
    639c:	30 e0       	ldi	r19, 0x00	; 0
    639e:	0a c0       	rjmp	.+20     	; 0x63b4 <vfprintf+0x27a>
    63a0:	10 61       	ori	r17, 0x10	; 16
    63a2:	14 fd       	sbrc	r17, 4
    63a4:	14 60       	ori	r17, 0x04	; 4
    63a6:	20 e1       	ldi	r18, 0x10	; 16
    63a8:	30 e0       	ldi	r19, 0x00	; 0
    63aa:	04 c0       	rjmp	.+8      	; 0x63b4 <vfprintf+0x27a>
    63ac:	14 fd       	sbrc	r17, 4
    63ae:	16 60       	ori	r17, 0x06	; 6
    63b0:	20 e1       	ldi	r18, 0x10	; 16
    63b2:	32 e0       	ldi	r19, 0x02	; 2
    63b4:	17 ff       	sbrs	r17, 7
    63b6:	08 c0       	rjmp	.+16     	; 0x63c8 <vfprintf+0x28e>
    63b8:	f5 01       	movw	r30, r10
    63ba:	60 81       	ld	r22, Z
    63bc:	71 81       	ldd	r23, Z+1	; 0x01
    63be:	82 81       	ldd	r24, Z+2	; 0x02
    63c0:	93 81       	ldd	r25, Z+3	; 0x03
    63c2:	44 e0       	ldi	r20, 0x04	; 4
    63c4:	50 e0       	ldi	r21, 0x00	; 0
    63c6:	08 c0       	rjmp	.+16     	; 0x63d8 <vfprintf+0x29e>
    63c8:	f5 01       	movw	r30, r10
    63ca:	80 81       	ld	r24, Z
    63cc:	91 81       	ldd	r25, Z+1	; 0x01
    63ce:	bc 01       	movw	r22, r24
    63d0:	80 e0       	ldi	r24, 0x00	; 0
    63d2:	90 e0       	ldi	r25, 0x00	; 0
    63d4:	42 e0       	ldi	r20, 0x02	; 2
    63d6:	50 e0       	ldi	r21, 0x00	; 0
    63d8:	a4 0e       	add	r10, r20
    63da:	b5 1e       	adc	r11, r21
    63dc:	a1 01       	movw	r20, r2
    63de:	0e 94 bc 32 	call	0x6578	; 0x6578 <__ultoa_invert>
    63e2:	d8 2e       	mov	r13, r24
    63e4:	d2 18       	sub	r13, r2
    63e6:	8f e7       	ldi	r24, 0x7F	; 127
    63e8:	f8 2e       	mov	r15, r24
    63ea:	f1 22       	and	r15, r17
    63ec:	f6 fe       	sbrs	r15, 6
    63ee:	0b c0       	rjmp	.+22     	; 0x6406 <vfprintf+0x2cc>
    63f0:	5e ef       	ldi	r21, 0xFE	; 254
    63f2:	f5 22       	and	r15, r21
    63f4:	d9 14       	cp	r13, r9
    63f6:	38 f4       	brcc	.+14     	; 0x6406 <vfprintf+0x2cc>
    63f8:	f4 fe       	sbrs	r15, 4
    63fa:	07 c0       	rjmp	.+14     	; 0x640a <vfprintf+0x2d0>
    63fc:	f2 fc       	sbrc	r15, 2
    63fe:	05 c0       	rjmp	.+10     	; 0x640a <vfprintf+0x2d0>
    6400:	8f ee       	ldi	r24, 0xEF	; 239
    6402:	f8 22       	and	r15, r24
    6404:	02 c0       	rjmp	.+4      	; 0x640a <vfprintf+0x2d0>
    6406:	1d 2d       	mov	r17, r13
    6408:	01 c0       	rjmp	.+2      	; 0x640c <vfprintf+0x2d2>
    640a:	19 2d       	mov	r17, r9
    640c:	f4 fe       	sbrs	r15, 4
    640e:	0d c0       	rjmp	.+26     	; 0x642a <vfprintf+0x2f0>
    6410:	fe 01       	movw	r30, r28
    6412:	ed 0d       	add	r30, r13
    6414:	f1 1d       	adc	r31, r1
    6416:	80 81       	ld	r24, Z
    6418:	80 33       	cpi	r24, 0x30	; 48
    641a:	19 f4       	brne	.+6      	; 0x6422 <vfprintf+0x2e8>
    641c:	99 ee       	ldi	r25, 0xE9	; 233
    641e:	f9 22       	and	r15, r25
    6420:	08 c0       	rjmp	.+16     	; 0x6432 <vfprintf+0x2f8>
    6422:	1f 5f       	subi	r17, 0xFF	; 255
    6424:	f2 fe       	sbrs	r15, 2
    6426:	05 c0       	rjmp	.+10     	; 0x6432 <vfprintf+0x2f8>
    6428:	03 c0       	rjmp	.+6      	; 0x6430 <vfprintf+0x2f6>
    642a:	8f 2d       	mov	r24, r15
    642c:	86 78       	andi	r24, 0x86	; 134
    642e:	09 f0       	breq	.+2      	; 0x6432 <vfprintf+0x2f8>
    6430:	1f 5f       	subi	r17, 0xFF	; 255
    6432:	0f 2d       	mov	r16, r15
    6434:	f3 fc       	sbrc	r15, 3
    6436:	14 c0       	rjmp	.+40     	; 0x6460 <vfprintf+0x326>
    6438:	f0 fe       	sbrs	r15, 0
    643a:	0f c0       	rjmp	.+30     	; 0x645a <vfprintf+0x320>
    643c:	1e 15       	cp	r17, r14
    643e:	10 f0       	brcs	.+4      	; 0x6444 <vfprintf+0x30a>
    6440:	9d 2c       	mov	r9, r13
    6442:	0b c0       	rjmp	.+22     	; 0x645a <vfprintf+0x320>
    6444:	9d 2c       	mov	r9, r13
    6446:	9e 0c       	add	r9, r14
    6448:	91 1a       	sub	r9, r17
    644a:	1e 2d       	mov	r17, r14
    644c:	06 c0       	rjmp	.+12     	; 0x645a <vfprintf+0x320>
    644e:	80 e2       	ldi	r24, 0x20	; 32
    6450:	90 e0       	ldi	r25, 0x00	; 0
    6452:	b3 01       	movw	r22, r6
    6454:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    6458:	1f 5f       	subi	r17, 0xFF	; 255
    645a:	1e 15       	cp	r17, r14
    645c:	c0 f3       	brcs	.-16     	; 0x644e <vfprintf+0x314>
    645e:	04 c0       	rjmp	.+8      	; 0x6468 <vfprintf+0x32e>
    6460:	1e 15       	cp	r17, r14
    6462:	10 f4       	brcc	.+4      	; 0x6468 <vfprintf+0x32e>
    6464:	e1 1a       	sub	r14, r17
    6466:	01 c0       	rjmp	.+2      	; 0x646a <vfprintf+0x330>
    6468:	ee 24       	eor	r14, r14
    646a:	04 ff       	sbrs	r16, 4
    646c:	0f c0       	rjmp	.+30     	; 0x648c <vfprintf+0x352>
    646e:	80 e3       	ldi	r24, 0x30	; 48
    6470:	90 e0       	ldi	r25, 0x00	; 0
    6472:	b3 01       	movw	r22, r6
    6474:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    6478:	02 ff       	sbrs	r16, 2
    647a:	1d c0       	rjmp	.+58     	; 0x64b6 <vfprintf+0x37c>
    647c:	01 fd       	sbrc	r16, 1
    647e:	03 c0       	rjmp	.+6      	; 0x6486 <vfprintf+0x34c>
    6480:	88 e7       	ldi	r24, 0x78	; 120
    6482:	90 e0       	ldi	r25, 0x00	; 0
    6484:	0e c0       	rjmp	.+28     	; 0x64a2 <vfprintf+0x368>
    6486:	88 e5       	ldi	r24, 0x58	; 88
    6488:	90 e0       	ldi	r25, 0x00	; 0
    648a:	0b c0       	rjmp	.+22     	; 0x64a2 <vfprintf+0x368>
    648c:	80 2f       	mov	r24, r16
    648e:	86 78       	andi	r24, 0x86	; 134
    6490:	91 f0       	breq	.+36     	; 0x64b6 <vfprintf+0x37c>
    6492:	01 ff       	sbrs	r16, 1
    6494:	02 c0       	rjmp	.+4      	; 0x649a <vfprintf+0x360>
    6496:	8b e2       	ldi	r24, 0x2B	; 43
    6498:	01 c0       	rjmp	.+2      	; 0x649c <vfprintf+0x362>
    649a:	80 e2       	ldi	r24, 0x20	; 32
    649c:	f7 fc       	sbrc	r15, 7
    649e:	8d e2       	ldi	r24, 0x2D	; 45
    64a0:	90 e0       	ldi	r25, 0x00	; 0
    64a2:	b3 01       	movw	r22, r6
    64a4:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    64a8:	06 c0       	rjmp	.+12     	; 0x64b6 <vfprintf+0x37c>
    64aa:	80 e3       	ldi	r24, 0x30	; 48
    64ac:	90 e0       	ldi	r25, 0x00	; 0
    64ae:	b3 01       	movw	r22, r6
    64b0:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    64b4:	9a 94       	dec	r9
    64b6:	d9 14       	cp	r13, r9
    64b8:	c0 f3       	brcs	.-16     	; 0x64aa <vfprintf+0x370>
    64ba:	da 94       	dec	r13
    64bc:	f1 01       	movw	r30, r2
    64be:	ed 0d       	add	r30, r13
    64c0:	f1 1d       	adc	r31, r1
    64c2:	80 81       	ld	r24, Z
    64c4:	90 e0       	ldi	r25, 0x00	; 0
    64c6:	b3 01       	movw	r22, r6
    64c8:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    64cc:	dd 20       	and	r13, r13
    64ce:	a9 f7       	brne	.-22     	; 0x64ba <vfprintf+0x380>
    64d0:	06 c0       	rjmp	.+12     	; 0x64de <vfprintf+0x3a4>
    64d2:	80 e2       	ldi	r24, 0x20	; 32
    64d4:	90 e0       	ldi	r25, 0x00	; 0
    64d6:	b3 01       	movw	r22, r6
    64d8:	0e 94 90 32 	call	0x6520	; 0x6520 <fputc>
    64dc:	ea 94       	dec	r14
    64de:	ee 20       	and	r14, r14
    64e0:	c1 f7       	brne	.-16     	; 0x64d2 <vfprintf+0x398>
    64e2:	43 ce       	rjmp	.-890    	; 0x616a <vfprintf+0x30>
    64e4:	f3 01       	movw	r30, r6
    64e6:	66 81       	ldd	r22, Z+6	; 0x06
    64e8:	77 81       	ldd	r23, Z+7	; 0x07
    64ea:	cb 01       	movw	r24, r22
    64ec:	2b 96       	adiw	r28, 0x0b	; 11
    64ee:	e2 e1       	ldi	r30, 0x12	; 18
    64f0:	0c 94 55 30 	jmp	0x60aa	; 0x60aa <__epilogue_restores__>

000064f4 <strnlen_P>:
    64f4:	fc 01       	movw	r30, r24
    64f6:	05 90       	lpm	r0, Z+
    64f8:	61 50       	subi	r22, 0x01	; 1
    64fa:	70 40       	sbci	r23, 0x00	; 0
    64fc:	01 10       	cpse	r0, r1
    64fe:	d8 f7       	brcc	.-10     	; 0x64f6 <strnlen_P+0x2>
    6500:	80 95       	com	r24
    6502:	90 95       	com	r25
    6504:	8e 0f       	add	r24, r30
    6506:	9f 1f       	adc	r25, r31
    6508:	08 95       	ret

0000650a <strnlen>:
    650a:	fc 01       	movw	r30, r24
    650c:	61 50       	subi	r22, 0x01	; 1
    650e:	70 40       	sbci	r23, 0x00	; 0
    6510:	01 90       	ld	r0, Z+
    6512:	01 10       	cpse	r0, r1
    6514:	d8 f7       	brcc	.-10     	; 0x650c <strnlen+0x2>
    6516:	80 95       	com	r24
    6518:	90 95       	com	r25
    651a:	8e 0f       	add	r24, r30
    651c:	9f 1f       	adc	r25, r31
    651e:	08 95       	ret

00006520 <fputc>:
    6520:	0f 93       	push	r16
    6522:	1f 93       	push	r17
    6524:	cf 93       	push	r28
    6526:	df 93       	push	r29
    6528:	8c 01       	movw	r16, r24
    652a:	eb 01       	movw	r28, r22
    652c:	8b 81       	ldd	r24, Y+3	; 0x03
    652e:	81 ff       	sbrs	r24, 1
    6530:	1b c0       	rjmp	.+54     	; 0x6568 <fputc+0x48>
    6532:	82 ff       	sbrs	r24, 2
    6534:	0d c0       	rjmp	.+26     	; 0x6550 <fputc+0x30>
    6536:	2e 81       	ldd	r18, Y+6	; 0x06
    6538:	3f 81       	ldd	r19, Y+7	; 0x07
    653a:	8c 81       	ldd	r24, Y+4	; 0x04
    653c:	9d 81       	ldd	r25, Y+5	; 0x05
    653e:	28 17       	cp	r18, r24
    6540:	39 07       	cpc	r19, r25
    6542:	64 f4       	brge	.+24     	; 0x655c <fputc+0x3c>
    6544:	e8 81       	ld	r30, Y
    6546:	f9 81       	ldd	r31, Y+1	; 0x01
    6548:	01 93       	st	Z+, r16
    654a:	f9 83       	std	Y+1, r31	; 0x01
    654c:	e8 83       	st	Y, r30
    654e:	06 c0       	rjmp	.+12     	; 0x655c <fputc+0x3c>
    6550:	e8 85       	ldd	r30, Y+8	; 0x08
    6552:	f9 85       	ldd	r31, Y+9	; 0x09
    6554:	80 2f       	mov	r24, r16
    6556:	09 95       	icall
    6558:	89 2b       	or	r24, r25
    655a:	31 f4       	brne	.+12     	; 0x6568 <fputc+0x48>
    655c:	8e 81       	ldd	r24, Y+6	; 0x06
    655e:	9f 81       	ldd	r25, Y+7	; 0x07
    6560:	01 96       	adiw	r24, 0x01	; 1
    6562:	9f 83       	std	Y+7, r25	; 0x07
    6564:	8e 83       	std	Y+6, r24	; 0x06
    6566:	02 c0       	rjmp	.+4      	; 0x656c <fputc+0x4c>
    6568:	0f ef       	ldi	r16, 0xFF	; 255
    656a:	1f ef       	ldi	r17, 0xFF	; 255
    656c:	c8 01       	movw	r24, r16
    656e:	df 91       	pop	r29
    6570:	cf 91       	pop	r28
    6572:	1f 91       	pop	r17
    6574:	0f 91       	pop	r16
    6576:	08 95       	ret

00006578 <__ultoa_invert>:
    6578:	fa 01       	movw	r30, r20
    657a:	aa 27       	eor	r26, r26
    657c:	28 30       	cpi	r18, 0x08	; 8
    657e:	51 f1       	breq	.+84     	; 0x65d4 <__ultoa_invert+0x5c>
    6580:	20 31       	cpi	r18, 0x10	; 16
    6582:	81 f1       	breq	.+96     	; 0x65e4 <__ultoa_invert+0x6c>
    6584:	e8 94       	clt
    6586:	6f 93       	push	r22
    6588:	6e 7f       	andi	r22, 0xFE	; 254
    658a:	6e 5f       	subi	r22, 0xFE	; 254
    658c:	7f 4f       	sbci	r23, 0xFF	; 255
    658e:	8f 4f       	sbci	r24, 0xFF	; 255
    6590:	9f 4f       	sbci	r25, 0xFF	; 255
    6592:	af 4f       	sbci	r26, 0xFF	; 255
    6594:	b1 e0       	ldi	r27, 0x01	; 1
    6596:	3e d0       	rcall	.+124    	; 0x6614 <__ultoa_invert+0x9c>
    6598:	b4 e0       	ldi	r27, 0x04	; 4
    659a:	3c d0       	rcall	.+120    	; 0x6614 <__ultoa_invert+0x9c>
    659c:	67 0f       	add	r22, r23
    659e:	78 1f       	adc	r23, r24
    65a0:	89 1f       	adc	r24, r25
    65a2:	9a 1f       	adc	r25, r26
    65a4:	a1 1d       	adc	r26, r1
    65a6:	68 0f       	add	r22, r24
    65a8:	79 1f       	adc	r23, r25
    65aa:	8a 1f       	adc	r24, r26
    65ac:	91 1d       	adc	r25, r1
    65ae:	a1 1d       	adc	r26, r1
    65b0:	6a 0f       	add	r22, r26
    65b2:	71 1d       	adc	r23, r1
    65b4:	81 1d       	adc	r24, r1
    65b6:	91 1d       	adc	r25, r1
    65b8:	a1 1d       	adc	r26, r1
    65ba:	20 d0       	rcall	.+64     	; 0x65fc <__ultoa_invert+0x84>
    65bc:	09 f4       	brne	.+2      	; 0x65c0 <__ultoa_invert+0x48>
    65be:	68 94       	set
    65c0:	3f 91       	pop	r19
    65c2:	2a e0       	ldi	r18, 0x0A	; 10
    65c4:	26 9f       	mul	r18, r22
    65c6:	11 24       	eor	r1, r1
    65c8:	30 19       	sub	r19, r0
    65ca:	30 5d       	subi	r19, 0xD0	; 208
    65cc:	31 93       	st	Z+, r19
    65ce:	de f6       	brtc	.-74     	; 0x6586 <__ultoa_invert+0xe>
    65d0:	cf 01       	movw	r24, r30
    65d2:	08 95       	ret
    65d4:	46 2f       	mov	r20, r22
    65d6:	47 70       	andi	r20, 0x07	; 7
    65d8:	40 5d       	subi	r20, 0xD0	; 208
    65da:	41 93       	st	Z+, r20
    65dc:	b3 e0       	ldi	r27, 0x03	; 3
    65de:	0f d0       	rcall	.+30     	; 0x65fe <__ultoa_invert+0x86>
    65e0:	c9 f7       	brne	.-14     	; 0x65d4 <__ultoa_invert+0x5c>
    65e2:	f6 cf       	rjmp	.-20     	; 0x65d0 <__ultoa_invert+0x58>
    65e4:	46 2f       	mov	r20, r22
    65e6:	4f 70       	andi	r20, 0x0F	; 15
    65e8:	40 5d       	subi	r20, 0xD0	; 208
    65ea:	4a 33       	cpi	r20, 0x3A	; 58
    65ec:	18 f0       	brcs	.+6      	; 0x65f4 <__ultoa_invert+0x7c>
    65ee:	49 5d       	subi	r20, 0xD9	; 217
    65f0:	31 fd       	sbrc	r19, 1
    65f2:	40 52       	subi	r20, 0x20	; 32
    65f4:	41 93       	st	Z+, r20
    65f6:	02 d0       	rcall	.+4      	; 0x65fc <__ultoa_invert+0x84>
    65f8:	a9 f7       	brne	.-22     	; 0x65e4 <__ultoa_invert+0x6c>
    65fa:	ea cf       	rjmp	.-44     	; 0x65d0 <__ultoa_invert+0x58>
    65fc:	b4 e0       	ldi	r27, 0x04	; 4
    65fe:	a6 95       	lsr	r26
    6600:	97 95       	ror	r25
    6602:	87 95       	ror	r24
    6604:	77 95       	ror	r23
    6606:	67 95       	ror	r22
    6608:	ba 95       	dec	r27
    660a:	c9 f7       	brne	.-14     	; 0x65fe <__ultoa_invert+0x86>
    660c:	00 97       	sbiw	r24, 0x00	; 0
    660e:	61 05       	cpc	r22, r1
    6610:	71 05       	cpc	r23, r1
    6612:	08 95       	ret
    6614:	9b 01       	movw	r18, r22
    6616:	ac 01       	movw	r20, r24
    6618:	0a 2e       	mov	r0, r26
    661a:	06 94       	lsr	r0
    661c:	57 95       	ror	r21
    661e:	47 95       	ror	r20
    6620:	37 95       	ror	r19
    6622:	27 95       	ror	r18
    6624:	ba 95       	dec	r27
    6626:	c9 f7       	brne	.-14     	; 0x661a <__ultoa_invert+0xa2>
    6628:	62 0f       	add	r22, r18
    662a:	73 1f       	adc	r23, r19
    662c:	84 1f       	adc	r24, r20
    662e:	95 1f       	adc	r25, r21
    6630:	a0 1d       	adc	r26, r0
    6632:	08 95       	ret

00006634 <_exit>:
    6634:	f8 94       	cli

00006636 <__stop_program>:
    6636:	ff cf       	rjmp	.-2      	; 0x6636 <__stop_program>
